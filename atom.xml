<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Infrequent, Pragmatic, Lambda Blog</title>
    <link href="https://rpeszek.github.io//atom.xml" rel="self" />
    <link href="https://rpeszek.github.io/" />
    <id>https://rpeszek.github.io//atom.xml</id>
    <author>
        <name>Robert Peszek</name>
        <email>rpeszek.io@gmail.com</email>
    </author>
    <updated>2022-03-13T00:00:00Z</updated>
    <entry>
    <title>Type Enthusiast's Notes about TypeScript. Part 6. Reasoning using Types</title>
    <link href="https://rpeszek.github.io//posts/2022-03-13-ts-types-part6.html" />
    <id>https://rpeszek.github.io//posts/2022-03-13-ts-types-part6.html</id>
    <published>2022-03-13T00:00:00Z</published>
    <updated>2022-03-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
    <section class="header">
        Posted on March 13, 2022
        
            by Robert Peszek
        
        
        
        <div class="changelog"> <div>Revision History: <ul> <li> (2021.03.15) Edited <a href="#enums">Enums</a> section</li> <li> (2022.04.30 - Present) Minor edits </li> </ul> </div></div>
        
        
        <div class="info">Tags: <a title="All pages tagged 'TypeScript-Notes'." href="../tags/TypeScript-Notes.html">TypeScript-Notes</a></div>
        
    </section>
    <section>

    </section>
    <section>
        <div class="toc"><div class="header">Table of Contents</div>
<ul>
<li><a href="#nutshell">Nutshell</a></li>
<li><a href="#about-clarity">About Clarity</a>
<ul>
<li><a href="#declare-function-return-types">Declare function return types</a></li>
<li><a href="#variables-named-x">Variables named <code>x</code></a></li>
<li><a href="#enums">Enums</a></li>
<li><a href="#clarity-vs-encapsulation">Clarity vs encapsulation</a></li>
<li><a href="#referential-transparency-purity-and-explicit-types">Referential transparency, purity, and explicit types</a></li>
</ul></li>
<li><a href="#about-productivity">About Productivity</a>
<ul>
<li><a href="#a-walk-in-the-park">A walk in the park</a></li>
<li><a href="#inference-reversed-and-typedd">Inference reversed and T(ype)DD</a></li>
</ul></li>
<li><a href="#about-simplicity">About Simplicity</a>
<ul>
<li><a href="#total-vs-partial">Total vs Partial</a></li>
</ul></li>
<li><a href="#about-safety">About Safety</a>
<ul>
<li><a href="#monads">Monads</a></li>
</ul></li>
<li><a href="#about-correctness">About Correctness</a></li>
<li><a href="#about-maintainability">About Maintainability</a></li>
<li><a href="#universal">Universal</a>
<ul>
<li><a href="#advanced-types-as-patterns">Advanced Types as Patterns</a></li>
</ul></li>
<li><a href="#unpopular">Unpopular</a>
<ul>
<li><a href="#gradual-progress">Gradual Progress</a></li>
</ul></li>
<li><a href="#final-words">Final words</a></li>
</ul>
</div>
<p><em>Please Leave Feedback in: <a href="https://github.com/rpeszek/rpeszek.github.io/discussions/1" target="_blank">git discussions</a></em></p>
<p>Previous post: <a href="2022-02-13-ts-types-part5.html" target="_blank">Part 5. Advanced Types</a>.<br />
Back to the beginning post: <a href="2021-12-12-ts-types-part1.html" target="_blank">Part 1. Typing in Anger</a></p>
<p><strong>DRAFT version</strong> <em>(I am sorry about any misprints. It seems I have goblins in my laptop that toy with me, remove or change words. When this note disappears, you will know that I gave up.)</em></p>
<h2 id="nutshell">Nutshell</h2>
<p>This post wraps up my series about types in TS. In this series, we explored type-centric approaches to writing code and pushed TS to its limits, sometimes a little beyond its limits.</p>
<p>In any mainstream programming language there is a group of users interested in using types. Similarly to the rest of the industry, this group is a very small subset of the TS community. Developers interested in types tend to be unappreciated and underutilized.</p>
<p>Types in programming get very formal and are very interesting for mathematically inclined developers. Mathematical inclinations are probably a necessary condition for enjoying types. This partially explains why types are such a niche, but IMO there are other reasons I will try to discuss some of them in this post.</p>
<p>This post will discuss these aspects of types: types are</p>
<ul>
<li>About Clarity</li>
<li>About Productivity</li>
<li>About Simplicity</li>
<li>About Safety</li>
<li>About Correctness</li>
<li>About Maintainability</li>
<li>Universal</li>
<li>Unpopular</li>
</ul>
<p>I will finish my series with a short rant about each of the bullet points. This will allow me to revisit and summarize some of the things we have discussed in previous parts and mention a few things this series did not cover.<br />
This post will be mostly a high level rant. I want to talk a bit about what is possible. Some of the discussion will not be very relevant to TS as the language lacks the capabilities. I think these topics are still relevant to TS developers as the ideas behind these concepts can still be useful.<br />
Simply put, my goal is to discuss how types (including advanced stuff) can be used in TS.</p>
<p>Like all of my other posts in the series, this one is a big longish and tries to cover a lot of ground. I hope you will find it worth the effort.</p>
<p>Some readers may disagree when reading this post. You may have valid reasons for disagreeing with me. Please let me know what they are.</p>
<h2 id="about-clarity">About Clarity</h2>
<p>What are coding conventions and standards? When I hear these terms being used, I know I will soon hear about code formatting and linting, importance of code comments, even things like readme files and git hygiene. However, I am unlikely to hear about types. It is not that types are not important, they are. They are also harder to discuss. This phenomenon has a name, it is called <a href="https://wiki.haskell.org/Wadler%27s_Law" target="_blank">Wadler’s Law</a> or <a href="https://bikeshed.com/" target="_blank">bikeshed</a>.</p>
<p>I have discussed using types to achieve code clarity in <a href="2021-12-24-ts-types-part2.html#referential-transparency" target="_blank">referential transparency</a> and <a href="2021-12-24-ts-types-part2.html#types-as-documentation" target="_blank">types as documentation</a> sections of Part 2. Let’s revisit the topic here.</p>
<p>It is much harder to comprehend the whole program than it is to comprehend its types. Types can provide a high level information about the program the way that theorems provide high level information about proofs in mathematics. Types can give a valid high level representation of the app. Programs often can’t, they often contain tedious details, performance optimizations, and lots of other persisted developer’s sweat.<br />
When done right, one can use types as <em>specs</em>, at least on a unit level types could be viewed as specifications.</p>
<p>Types have a synergy with FP. This series was not about FP but it was hard for me to completely stay away, the synergy is so deep. Types help express functional concepts clearly.</p>
<p>Advanced types come with a learning curve. It is important to acknowledge that clarity is subjective and can easily be replaced with confusion unless developers are familiar with the concepts.</p>
<blockquote>
<p><em>“WTFPM: WTF Per Minute is an actual measurement for code value.”</em></p>
</blockquote>
<p>I imagine some topics covered in <a href="2022-01-09-ts-types-part4.html" target="_blank">Part 4</a> or <a href="2022-02-13-ts-types-part5.html" target="_blank">Part 5</a> could have a high WTFPM number. IMO, types used in production projects should be accessible to the project contributors. This means pushing the envelope just a bit but not too far.</p>
<p>The following subsections examine a few concepts related to clarity.</p>
<h3 id="declare-function-return-types">Declare function return types</h3>
<p>TS does not require it but why would you not do that?</p>
<h3 id="variables-named-x">Variables named <code>x</code></h3>
<p>Are variable names essential to clarity? It is a bit of a telltale. One of the most common criticisms of languages that heavily use types (like Haskell) is:</p>
<blockquote>
<p><em>“Whats up with the variable names, why everything is <code>x,y,z</code>, <code>xs,ys,zs</code>, <code>f,g,h</code> or <code>a,b,c</code>?”</em></p>
</blockquote>
<p>Part of the reason is that the code can be very general. If a variable can be literally anything, why not call it <code>x</code>? The other reason is where the reader gets the information from: variable names or types? Personally, I believe in more explicit variable names when implementing a specific business logic and the implementation is long. However, even in such cases, the info should be in the types. If it is not, the code probably can benefit from refactoring.</p>
<h3 id="enums">Enums</h3>
<p><em>This section is now somewhat misplaced. I am keeping this edited version for consistency with my original post. It reflects, IMO, valid points made by the reddit community. My original position was that <em>enums</em> are obsoleted by union types.</em></p>
<p>Are enums clearer than literal types? This code has 3 types (“foo”, “bar” and the union):</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>type FooBar <span class="op">=</span> <span class="st">&quot;foo&quot;</span> <span class="op">|</span> <span class="st">&quot;bar&quot;</span></span></code></pre></div>
<p>This code defines one type (<code>FooBar</code>) and is more verbose:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">enum</span> FooBar {</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>  Foo <span class="op">=</span> <span class="st">&quot;foo&quot;</span><span class="op">,</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>  Bar <span class="op">=</span> <span class="st">&quot;bar&quot;</span><span class="op">,</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>}</span></code></pre></div>
<p>What is the advantage of using this <code>enum</code>?</p>
<p><strong>EDIT:</strong> <em>I got a pushback to my criticism of <code>enum</code> (<a href="https://www.reddit.com/r/typescript/comments/tdymsp/comment/i0p5q8c/?utm_source=share&amp;utm_medium=web2x&amp;context=3" target="_blank">reddit</a>). Here is a list of valid reasons to use <code>enum</code> in TS:</em></p>
<ul>
<li><em>Intellisense is likely to work better (go to definition, search for usage - these niceties may not even make sense with union types)</em></li>
<li><em>Type inference is likely to be much better as the name of the <code>enum</code> is specified at the usage point</em></li>
<li><em>Enums can be more descriptive than some literals (e.g. <code>OK</code> is nicer than <code>200</code>)</em></li>
<li><em>Enums are nominally typed which can be often useful. Two enums have different types even if they have the same content. (note that in TS even classes are structurally typed, class content matters, class name not so much)</em></li>
</ul>
<p><em>However, most type safety appears to be identical. For example, switch statement exhaustive checks are equivalent. IMO literal string types are often more readable. Readers familiar with languages that have a nice implementation of Algebraic Data Types are likely to gravitate towards unions.</em></p>
<h3 id="clarity-vs-encapsulation">Clarity vs encapsulation</h3>
<p>Encapsulation does not help clarity. I consider encapsulation to be very useful when designing micro-services, not so much when designing programs. Encapsulation often means not expressive types. Encapsulating is hiding things from the types. It often makes types simpler than they should be. To get the benefits of types, we need to give them a chance. Type checker will not type check what is invisible to it.</p>
<p>On the other hand, explicit types (types that contain a lot of information) have a higher maintenance cost.<br />
I like to compare this to documentation. If app functionality changes you should change the documentation. You are likely to do that only in the most obvious places. Explicit types are different, they create domino effects forcing you to propagate the changes to all the relevant places.<br />
This overhead is not always desirable and there are patterns and tools to minimize such cost (e.g. TS subtyping, existential types, FP concept called <em>smart constructors</em>). Changing functionality should create compilation errors but ideally these errors should not be hard to fix.</p>
<p>Encapsulated code does not test well and often requires mocking frameworks. You will know you are doing something right when you stop using mocks for unit tests.</p>
<h3 id="referential-transparency-purity-and-explicit-types">Referential transparency, purity, and explicit types</h3>
<p>I have discussed these concepts already in <a href="2021-12-24-ts-types-part2.html#referential-transparency" target="_blank">Referential Transparency (Part 2)</a>. I want to return to this topic for another rant.<br />
Referential transparency does not have an agreed upon formal definition. It typically means:</p>
<p><em>A computation is referentially transparent if it can be safely replaced with its return value<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</em></p>
<p>This is clearly related to clarity and simplicity. It is hard to reason about code that does different things every time it is called.</p>
<p><em>Function is pure if it does not perform any side-effects (e.g. does not mutate things)</em></p>
<p>These concepts are related but not equivalent, e.g. a function that finds a shortest path in a graph is likely to be referentially transparent even if its implementation mutates its local variables (most standard graph algorithms are imperative and mutate stuff). Such functions “look” pure from the outside and maybe in some cases that is good enough. I may want to care about referential transparency more than about strict purity.</p>
<p>I like to treat referential transparency loosely. In my loose approach, referential transparency simply means that what the function does is exposed in its type (so <em>referentially transparent</em> and <em>has an explicit type</em> become the same thing). Thinking in these lines makes referential transparency less of a checkbox and more a progress bar.</p>
<p>Consider the following versions of code that are supposed to establish a WebSocket using some imaginary API (we are implementing a PetStore):</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="co">//(1) gets config from a global place and globally stores WS connection</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a><span class="kw">const</span> initWs<span class="op">:</span> ()<span class="op">:</span> <span class="kw">void</span> <span class="op">=</span> <span class="op">...</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a><span class="co">//(2) gets config from a global place</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a><span class="kw">const</span> connectWs<span class="op">:</span> () <span class="kw">=&gt;</span> WsConnection <span class="op">=</span> <span class="op">...</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a><span class="co">//(3) gets config from passed parameter, incomplete return type</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a><span class="kw">const</span> connectWs<span class="op">:</span> (conf<span class="op">:</span> PetStoreConfig) <span class="kw">=&gt;</span> WsConnection <span class="op">=</span> <span class="op">...</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a><span class="co">//(4) gets config from passed parameter, incomplete return type</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a><span class="kw">const</span> connectWs<span class="op">:</span> (conf<span class="op">:</span> {<span class="dt">loggerConf</span><span class="op">:</span> LoggerConfig<span class="op">;</span> <span class="dt">wsUrl</span><span class="op">:</span> Url}) <span class="kw">=&gt;</span> WsConnection <span class="op">=</span> <span class="op">...</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true"></a><span class="co">//(5) null, option, optional, maybe ... types do not contain much error context</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true"></a><span class="kw">const</span> connectWs<span class="op">:</span> (conf<span class="op">:</span> {<span class="dt">loggerConf</span><span class="op">:</span> LoggerConfig<span class="op">;</span> <span class="dt">wsUrl</span><span class="op">:</span> Url}) <span class="kw">=&gt;</span> WsConnection <span class="op">|</span> <span class="kw">null</span> <span class="op">=</span> <span class="op">...</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true"></a><span class="co">//(6) gets config from passed parameter, complete return type </span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true"></a><span class="co">//(most likely will involve subtyping at usage point) </span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true"></a><span class="kw">const</span> connectWs<span class="op">:</span> (conf<span class="op">:</span> {<span class="dt">loggerConf</span><span class="op">:</span> LoggerConfig<span class="op">;</span> <span class="dt">wsUrl</span><span class="op">:</span> Url}) <span class="kw">=&gt;</span> WsConnection <span class="op">|</span> WsError <span class="op">=</span> <span class="op">...</span></span></code></pre></div>
<p>Note that there is no much benefit between using <code>PetStoreConfig</code> and <code>{loggerConf: LoggerConfig; wsUrl: Url}</code> or between <code>WsConnection | null</code> vs <code>WsConnection | WsError</code> from the point of view of strict referential transparency. There is, however, a big difference if you think about the information contained in the types.<br />
(1) and (2) are very opaque, (3) and (4) are similar but not all <code>PetStoreConfig</code> is relevant, thus (4) type is more transparent and precise.<br />
In my experience, even programmers who know a lot about types end up not thinking about exceptions and will code some equivalent of (5). The goal is to get to (6). (6) is very explicit, IMO it is the best. Subtyping is likely to be used at some point as <code>PetStoreConfig</code> probably will be passed to it. However, the first (the least explicit) approach is probably more commonly used at large.</p>
<p>Readers working with React can alternatively think about a component that uses an internal state hook (encapsulates state) vs a component that accepts a setter callback and a getter property as input arguments. You can also think about React Context API or a similar approach and compare it with explicit setters/getters.</p>
<p>Each computation has an input and an output even if TypeScript / JavaScript code does its darndest to hide it. TS code can pull the inputs out of thin air (configuration, stuff stored on the window object, etc) and sink the output by saving it somewhere. The above <code>initWs</code> is guilty of both of these felonies. Still, there is a referentially transparent computation hiding somewhere. In the above example the last <code>connectWs</code> type describes the inputs and output within the heavily encapsulated <code>initWs</code>.</p>
<p>Inputs and outputs are essential to clarity. The developer should try to understand what these inputs and outputs are at the very least. Ideally, the explicitly typed computation within can be factored out. This is not just for clarity, you are likely to find future uses for it (e.g. the last example above could be factored out of the PetStore and used in other apps or used to open 2 connections). And, it will be easier to test.</p>
<h2 id="about-productivity">About Productivity</h2>
<p>We are not leaving clarity behind. Clarity and productivity are obviously related. I am only changing the angle.</p>
<p>When I write code in an untyped language, I still think about types, the only difference is that I do not have any verification from the type checker. Not having a type checker or working with poorly designed types slows me down. Moving to a strongly typed functional language has made me much more effective, possibly 4x-5x times more effective (I am sure such stats are very personal and depend on many factors).</p>
<p>IMO all developers, whether they admit it or not, use types in their heads. The question is: how effectively?</p>
<p>The following subsections examine some concepts related to productivity.</p>
<h3 id="a-walk-in-the-park">A walk in the park</h3>
<p>Types can guide the process of writing code. I can write code by ‘following the types’ if the API gives me well designed types to follow. The analogy is following a path in the park.</p>
<p>We have seen examples of this in <a href="2021-12-24-ts-types-part2.html" target="_blank">Part 2</a> where I twisted <em>office.js</em> arm to get the types right and was able to type predicate myself to a much faster to write and safer code.</p>
<p>We have also seen this in Part 4 (<a href="2022-01-09-ts-types-part4.html#preventing-information-escape" target="_blank">preventing information escape</a>, <a href="2022-01-09-ts-types-part4.html#phantom-types" target="_blank">phantom types</a>) where types formed jigsaw puzzles allowing the computations to fit together in only certain ways.</p>
<p> <div class="side-note">There is a technique often called <em>Hole Driven Development</em> in which the developer interacts with the type checker to write code. You can try to use this <a href="2021-12-12-ts-types-part1.html#type-holes" target="_blank">type hole</a> with a mixed success to accomplish some of it in TS.<br />
The idea is that by examining the type of a still missing code (the hole) you should be able to figure out the right piece of the puzzle to fit in (replace that hole with a piece of code that has the needed type). The new piece can have some type holes too and the process is iterative. The language that provides the best experience (and a lot of fun) doing this is Idris. You can implement certain functions by just using keyboard shortcuts to deconstruct, pattern match, search solution space for the right function in scope and insert it to the program<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.<br />
OK, TS does not do that, but you do not need such tooling to benefit from the jigsaw approach to designing your code.  </div></p>
<h3 id="inference-reversed-and-typedd">Inference reversed and T(ype)DD</h3>
<p>This section is not very relevant to TS, but I think it is interesting to note.</p>
<p>Type inference allows a programming language to compute the types without needing the developer to specify them.<br />
Ideally, the future will bring tooling where the developer defines the types and the compiler computes the program.</p>
<p> <div class="side-note">A lot of this unicornish utopia is available today in some FP languages like Haskell. Certain code is considered boilerplate and the tooling can derive it automatically. Examples are: equality, ordering, JSON parsing/formatting, <code>map</code> functions for non-list types, folding/unfolding for non-list types, traversing non-list types, recursion scheme folds and unfolds, optics… All of this boilerplate would be available for free for something like the <code>Json</code> grammar example from Part 1 and Part 5. Programming in Haskell often involves creating some involved custom type and automatically deriving a lot of boilerplate for it.<br />
The are also many experimental (typically short lived) projects for auto generating code. I have curated a short list <a href="https://github.com/rpeszek/IdrisTddNotes/wiki/Part2_Sec3_2_3_gen#program-synthesis-some-relevant-links" target="_blank">here</a> (I expect it to be mostly outdated now).<br />
The stronger the types, the more code generation is possible (I have already mentioned interactive code development in the dependently typed Idris).  </div></p>
<p>TS will not automatically implement code for us, however, starting with types and following with (a manually written for now) programs is often quite productive. This is the TDD approach to programming, only T means <em>Type</em>. The simplest way to go about it is to start on a small unit level (define types for small building blocks first). It helps to know some solid building blocks (e.g. FP types) and to use a lot of type variables.</p>
<h2 id="about-simplicity">About Simplicity</h2>
<p>I consider the terms <em>simple</em> and <em>easy</em> to have different meaning. Easy: The low barrier to entry (e.g. language). Simple: Low effort to reason about (e.g. code written in that language). There is no free lunch, to get simplicity you need to accept that things will not be easy.<br />
Simplicity is about ability to reason about things and as such is closely related to all other bullet points in this post.<br />
IMO, the popularity of easy and the unpopularity of simple are a systemic problem in today’s programming and elsewhere.</p>
<p>I consider TS to be complex (the opposite of simple). I devoted <a href="2022-01-03-ts-types-part3.html" target="_blank">Part 3</a> to explaining why.</p>
<p>On some basic level, simplicity is associated with strictness. Flexibility seems to cause complexity. <em>Flow’s exact</em> objects are strict and simple, existential types are more flexible and more complex, subtyping makes types very flexible and very complex. However, there are many modern concepts that programming languages are still trying to figure out, e.g. dependent types (Idris, Agda, Coq), linear types (Rust, Haskell v.9, Idris 2). These concepts should be filed under strict and complex today. I have a feeling that in 5 years I will consider them less complex than subtyping (see the current <a href="https://doc.rust-lang.org/nomicon/subtyping.html" target="_blank">subtyping</a> doc from Rust).</p>
<p>One aspect critical to simplicity that is <em>easy</em> to explain and one that we have not discussed yet is <em>totality</em>.</p>
<h3 id="total-vs-partial">Total vs Partial</h3>
<p>Another related term is non-termination. Does the function return a value as expected? Bunch of things can go wrong: function can throw exception, loop forever, have unbounded recursion, return unexpected <code>null</code> or <code>undefined</code><a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>. Functions that return a result for all inputs are called <em>total</em> otherwise are called <em>partial</em>.</p>
<p>Total is simple. Reasoning about partial functions is much harder. Any non-termination bypasses the type checker. <em>Using partial functions means that the types are misleading.</em></p>
<p>Exceptions seem to be the most frequent reason for the non-termination. Developers who like types avoid throwing exceptions, they will favor TS union types instead.</p>
<p>Let’s think again about computations from the input-output perspective and consider conditional control flow of the program.<br />
TS’s ternary can be viewed as a function. <em>if-else</em> not so much. <em>if_else</em> does not have a type. It was designed for mutating things and in today’s more immutable approach to programming it should feel antiquated. However, it is idiomatic to both JS and TS and is impossible to avoid.<br />
I use <em>if_else</em> blocks only with return statements (with exception of <code>void</code> functions). I do not use <em>if</em> without the matching <em>else</em> even if the code looks repetitive (again, with exception of <code>void</code> functions).<br />
If you think about the “referentially transparent computation within”, you will notice that <em>if</em> without <em>else</em> is partial. Several programming languages offer <em>if_else</em> syntax without the <em>if</em> only option.</p>
<p>One could go (IMO too) far with this approach and use <code>if-else</code> as a lambda:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="co">// if-else as a lambda, this seems overkill</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="kw">const</span> x <span class="op">=</span> (() <span class="kw">=&gt;</span> {</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>    <span class="cf">if</span> (condition) {</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>        <span class="op">...</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>        <span class="cf">return</span> <span class="st">&quot;yes&quot;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>    } </span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>    <span class="cf">else</span> {</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>        <span class="op">...</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>        <span class="cf">return</span> <span class="st">&quot;no&quot;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>    }</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a>    }) ()</span></code></pre></div>
<p>I fully expect some pushback on this. My view is opposite to what you can frequently find on the internet (<em>else</em> is sometimes considered evil). Developers consider a sequence of <em>if</em>-s better than <em>if_else</em> chains.<br />
For simple control flows it should not matter. For more complex code using partial <em>if</em>-s is concerning.</p>
<p> <div class="side-note">In general case verifying totality is <em>undecidable</em> (it is impossible to write a static analysis tool (e.g. compiler) that checks if programs are total or not). This is the famous Turing’s counterexample to Hilbert’s <a href="https://en.wikipedia.org/wiki/Entscheidungsproblem" target="_blank">decidability problem</a>. You may also know it as the <a href="https://en.wikipedia.org/wiki/Halting_problem" target="_blank">halting problem</a>. However, interesting things can be done and languages like Agda, COQ, Idris can guarantee totality for a large subset of programs<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>.<br />
Outside of this small set of dependently typed languages, the totality is something that developers need to try to enforce on their own (that obviously includes TS).  </div></p>
<h2 id="about-safety">About Safety</h2>
<p>Here are some interesting examples of safety that could be provided by types: safe routing in a single page app (no broken routes), safe use of environment configuration (e.g. types prevent accessing arbitrary environment variables), safe backend communication (imagine the same types in frontend and backend with safety preventing broken urls and payload parsing errors).<br />
Safety can be very interesting, we have seen some examples specific to TS e.g. <a href="2022-01-09-ts-types-part4.html#preventing-information-escape" target="_blank">no information escape</a>, <a href="2022-01-09-ts-types-part4.html#safety-preventing-unknown" target="_blank">no <code>unknown</code></a>, <a href="2022-01-09-ts-types-part4.html#safety-preventing-subtyping" target="_blank">no subtyping</a>.</p>
<p> <div class="side-note">Here are some very sophisticated examples of safety (outside of TS scope): safe linear algebra (e.g. consistent sizes of matrices in matrix multiplication), safety preventing deadlocks, safe resource management (e.g. no memory leaks, type safety over which resources are used, etc.). One of the wildest type guarantees I have encountered was a guarantee for a linear computation cost.</p>
<p>Safety is really needed and often missing. Here are some examples outside of TS scope (related to memory manangement): <a href="https://visualstudiomagazine.com/articles/2019/07/18/microsoft-eyes-rust.aspx" target="_blank">Microsoft eyes Rust</a>, <a href="https://www.zdnet.com/article/chrome-70-of-all-security-bugs-are-memory-safety-issues/" target="_blank">Security bugs in Chrome</a>.</p>
<p>To summarize what has been said:</p>
<ul>
<li>Best programming practices are not good enough to avoid these problems</li>
<li>Approaches like smart pointers in newer versions of C++ are not good enough either</li>
<li>Type safety: works  </div></li>
</ul>
<p>It should be noted that <code>subtyping</code> reduces safety. We have discussed it extensively in <a href="2022-01-03-ts-types-part3.html#subtyping" target="_blank">Part 3</a></p>
<p>We are seeing a slow industry shift towards a more sophisticated use of types, IMO, TS could play a role in that shift.</p>
<h3 id="monads">Monads</h3>
<p>I have stayed away from the topic thinking that there are enough monad tutorials already, but it is hard to not mention this concept. Monad types provide interesting safety: monads can control the ability to leave monadic computation. A value can easily enter a monad but once there it is hard to leave. This is clearly interesting from the safety standpoint and can be used to achieve all kinds of interesting guarantees. Things get really very interesting in the jigsaw puzzle building department with the addition of dependent types<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>.</p>
<p>Monads allow for a very imperative code. However, this requires some syntax sugar that the programming language needs to offer. This is called <em>do notation</em> in several languages or <em>for comprehension</em> in Scala. TS does not offer it. That makes monadic computing far less accessible.</p>
<p><a href="https://www.npmjs.com/package/fp-ts" target="_blank"><em>fp-ts</em></a> library provides support for monads and other functional types in TS. Thumbs up to all developers who use it or work on <em>fp-ts</em>.<br />
I am not using <em>fp-ts</em> in my TS project (even though Haskell development is my main job function).<br />
Each project needs to decide on the level of abstraction it allows to make developers working in it productive.</p>
<h2 id="about-correctness">About Correctness</h2>
<p>This series is not about formal verification, types and correctness could be its own blog (or book) series, one I am not qualified to write. I will only point out that, gradual typing or not, in TS correctness and soundness are a baby thrown with the bath water.<br />
Making things conceptually easy at the cost of correctness (e.g. <a href="2022-01-03-ts-types-part3.html#variance-problems" target="_blank">incorrect variance</a>, incorrect or at least very unclear <a href="2022-01-03-ts-types-part3.html#semantics-rejected-overlap" target="_blank">narrowing semantics</a>) should not be on the table.</p>
<p>Subtle falsehoods can sometimes be more concerning than the obvious once.<br />
Here is a coding challenge: There is a common belief that compilation flags like <code>strictNullChecks</code> prevent escaped <code>null</code> and <code>undefined</code>. Exploit the incorrectness of variance in TS to create a partial function that has <code>number</code> return type but returns <code>undefined</code> for some of its input parameter values.</p>
<p>This series discouraged the use of TS’s <code>any</code> type. Undeniably, combining <code>any</code> with stricter types can lead to some very interesting and useful code if one is careful. In a way, I view <code>any</code> to be more straightforward and less damaging than other violations of logical soundness in the TypeScript language.</p>
<h2 id="about-maintainability">About Maintainability</h2>
<p>Considering who is still reading this, I am now only preaching to the quire so I will keep this short. Clearly all the points I have made so far are very related to maintainability.</p>
<p>My favorite definition of high code quality is, simply, a code with a low maintenance cost. IMO, everything else is subjective. Types have a big beneficial impact on that cost.</p>
<p>Developers often go to great lengths to avoid compilation errors. Sure, committing code that does not compile is not very professional but this attitude sometimes goes beyond that. IMO, designing types to be resilient to changes in functionality is not what you want to do. Compilation errors are why we use types, compilation errors are a good thing. What you want are errors that are easy to fix.</p>
<p>It is well known that types can prevent trivial errors (like using a <code>string</code> instead of <code>object</code>). It is hard to catch all such cases in tests and they do show up in production. This is the reason, I believe, TS is used in most of its projects.<br />
Let me point out a less trivial high level bit. Types can simplify adding new functionality! If you think about the app as a big union type of various requirements (this is an oversimplification but let me keep going), then adding a new piece of functionality to that union could give you compilation errors unless you fix all the relevant places. Think about TS-s <a href="2022-01-03-ts-types-part3.html#switch-exhaustive-check" target="_blank"><code>switch</code></a> or <a href="https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k" target="_blank"><em>ts-pattern</em></a> library exhaustive checks<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>.</p>
<h2 id="universal">Universal</h2>
<p>Types are more fundamental than a programming language. For example, most FP languages are effectively a syntax sugar over some version of lambda calculus. Lambda calculi come with very well understood formal type semantics.<br />
I am reminded about the <a href="https://www.youtube.com/watch?v=IOiZatlZtGU&amp;t=1816s" target="_blank">Propositions as Types</a> presentation by Phil Wadler himself. It makes a compelling and funny argument that the movie <em>Independence Day</em> got it all wrong. Aliens would not have used C. C is being created by an engineering effort, types and LC are being discovered<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>. Aliens would have discovered typed lambda calculi or have engineered something much different than C or Java.<br />
This is very philosophical, but it also has a pragmatic implication. Discovered programs are, by definition, timeless. If Wadler is right (and if we will keep programming in the future) that would be kinda amazing. In Part 4, I have referenced the <a href="https://www.goodreads.com/book/show/112252.Types_and_Programming_Languages" target="_blank">TAPL</a> book, IMO, the best textbook to learn types. This book is 20 years old. Recursion schemes (Part 5) are 20+ years old. Rank-2 types discussed in Part 4 were studied in 1980-ties and 90-ties. Many language features we consider new and modern are really old ideas, some date back to 1970ties.</p>
<p>Robert Harper has coined a term <a href="https://existentialtype.wordpress.com/2011/03/27/the-holy-trinity/" target="_blank">The Holly Trinity of CS</a> and types are one of the three.</p>
<p>Types are playing an increasing role in foundations of mathematics, the new and “hot” topic is <a href="https://en.wikipedia.org/wiki/Homotopy_type_theory" target="_blank">HoTT</a>.</p>
<p>This series was written by a TypeScript newb. I am using TS since November 2021 and only on one project.<br />
We have covered a lot of ground that probably is not well known to many seasoned TypeScripters. I think the existence of this series provides a good verification for my claim: it is more about knowing the types than it is about knowing the programming language.</p>
<p>Types could unify how we think and talk about programs. Effective development teams are small, the threshold seems to be somewhere around 4-5. Why is that? I had worked once inside a team of 8 (two teams with different core competencies were merged to work on a new project). Design meetings, OMG, we had a hard time agreeing on anything.<br />
Nobody disputes that natural numbers satisfy <code>2 + 2 = 4</code>, and that has to do with types. One of my goals in this series was to sell the idea that types are fundamental to programming and are mostly not something open to endless debates. Types could help facilitate an agreement.</p>
<h3 id="advanced-types-as-patterns">Advanced Types as Patterns</h3>
<p>Advanced types are worth learning even if TypeScript is not able to support them. Advanced uses of types often come with very well behaving principled computations. TypeScript may not be able to express such types in full generality, but it is often possible to use the principled approach as a pattern.<br />
An example is the <a href="https://github.com/rpeszek/ts-experiments/blob/master/ts-notes/src/RecSchemes.ts" target="_blank">Recursion Scheme</a> code I wrote for Part 5. I see <code>map</code> being added to all kinds of types as a pattern. Monads are used as a pattern too. The concept of <em>async</em>, <em>await</em> uses monads as a pattern. <a href="https://www.npmjs.com/package/fast-check" target="_blank"><em>fast_check</em></a> library uses monadic computing as a pattern to accomplish randomized property testing.</p>
<p>The burden to understand the principles lies on the authors of libraries and APIs. For example, developers using <em>async</em> / <em>await</em> do not need to understand the concept of a monad. You need to understand it to create the <em>async / await</em> concept.<br />
It is also much easier to learn the underlying concept after experiencing examples of its use.</p>
<h2 id="unpopular">Unpopular</h2>
<p>There are two directions to writing high quality low defect rate software. Both approaches complement each other.</p>
<ol type="1">
<li>Increase project effort and cost (e.g. testing)</li>
<li>Increase effort / cost outside of project scope (e.g. learning types)</li>
</ol>
<p>In the industry focused on short term goals 2 will be unpopular even if benefits of 2 are significant.<br />
The ramp up time for the projects needs to be short. This explains why all mainstream languages look and feel alike. As far as programming languages go, the software industry is not innovation friendly. Any progress needs to be very gradual. Developers need to be able to “hit the ground running” when using a new language.</p>
<p>I have already mentioned <a href="https://wiki.haskell.org/Wadler%27s_Law" target="_blank">Wadler’s Law</a> and <a href="https://bikeshed.com/" target="_blank">bikeshed</a>. Types are about semantics. That puts them at the far end of the popularity ranking scale. I have mentioned the easy vs simple dilemma. Simple is less popular. Types are theoretical, that makes them less popular as well.</p>
<p>Let’s look at the job market. The job market for typed functional programming jobs is, frankly, dismal. At the same time, languages like Haskell and Rust top the weekend use stats based on stackoverflow surveys<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>.</p>
<p>How can we explain both of these phenomena? One issue is that only a small minority of programmers are interested in the more principled methods of writing code. Weekend learners playing with Rust appear to outnumber devs doing weekend project work in, say, PHP. That is good, but the numbers are still not there. There needs to be a critical mass of enthusiasts and there isn’t one. At the very minimum, managers expect to have a solid supply of headcounts. Managers will consider use of an FP language risky. You do not get fired or criticized for selecting Java.<br />
The other issue is the correlation between interest in types with interest in mathematics. Current rush towards machine learning sways the precious few mathematically inclined CS students towards well paying data science careers.<br />
Yet another issue is education and how mathematics and CS are being taught.</p>
<p>Let’s take a bit more controversial take on this. A stronger version of “Someone is wrong on the internet” is this statement:</p>
<p><em>Lack of popularity is a necessary (not sufficient) condition of doing something right.</em></p>
<p>“Popular =&gt; wrong” is a law (or hypothesis) of life that dates back to at least Socrates.<br />
If you assume this to be true, you can view the progress as a process of being less and less wrong.<br />
People look at the history of the software industry and see a never ending aggressive progress. A more insightful hindsight exposes a history of embracing bad ideas (e.g. <code>null</code>) and resisting good ideas (e.g. type parameters<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a>).<br />
You probably think of all of this as too hyperbolic. The benefit of taking this stance is a chance of noticing things that others don’t.</p>
<p>Lack of popularity can translate to some <strong>frustration</strong> for the type enthusiasts. The frustration comes in the form of rejected designs, rejected pool requests, failed job interviews. I heard stories and experienced some of it first hand. That is just part of life, the criticism can have validity as more advanced programming techniques could make the project confusing and not accessible to its contributors.<br />
It also should be expected. One comment I received about Part 1 of this series said “this code is quite different from what we do”. “Different” could imply worth pursuing but unavoidably will at some point lead to a confrontation.</p>
<p>Types lack the critical mass of acceptance to become disruptive, they work well when the team is ready and/or when applied in a gradual way. Thumbs up to projects and developer teams who learn types and select the unpopular!</p>
<blockquote>
<p><em>“Only in our dreams are we free. The rest of the time we need wages.”</em> <em>Terry Pratchett and <a href="https://wiki.lspace.org/Hwel" target="_blank">Hwel</a>. A good metaphor to describe the life of a programmer.</em></p>
</blockquote>
<h3 id="gradual-progress">Gradual Progress</h3>
<p>There is a steady and slow progress. Mainstream languages are introducing a little bit of types and FP.<br />
<code>async</code>-<code>await</code> is now supported by many languages. <em>Sum/variant types</em> are supported by many languages (TS’s union types stand out for their readability). Record types are being introduced as well (e.g. Java 14 <em>records</em>, C# 10 record struts, …). C# has type safe <code>equals</code>. Advanced types in TS we have discussed in <a href="2022-01-09-ts-types-part4.html" target="_blank">Part 4</a> and <a href="2022-02-13-ts-types-part5.html" target="_blank">Part 5</a>. The list slowly grows.</p>
<h2 id="final-words">Final words</h2>
<p>TS does a poor job implementing types. However, it has types and it even allows to do some advanced things with them. The last two installments (<a href="2022-01-09-ts-types-part4.html" target="_blank">Part 4</a> and <a href="2022-02-13-ts-types-part5.html" target="_blank">Part 5</a>) allowed me to go places I would not be able to reach in most mainstream languages.</p>
<p>If developers start using types, the languages will expand support for them.<br />
This will feed some gradual change. The hope for existence of such a feedback loop is what prompted me to write this series.</p>
<p><strong>Should more advanced types be used in a project?</strong> Ideally (and IMO) that decision should be made by the developers. I have presented plenty of <em>pros</em>. The biggest obstacle is the learning curve. I am afraid this learning needs to happen outside of the project work. In reality, this means that the decision has to be made based on what the team knows already. So the answer for some teams could <em>yes</em> today, for some could be <em>no</em> today but a <em>yes</em> in the future.<br />
My personal approach is to make sure that TS code is approachable and my goal is to make it principled within this constraint.<br />
This is not very easy to do, it is much easier to use principled types than principled patterns. It is also easier to write principled code in an environment where principled is not considered odd.<br />
It is also good to be able to scratch the itch and keep practicing the real thing, I have my backend work to do that, lots of people do not have that luxury.</p>
<p>This series was a long journey, I am happy I took it, but I am also happy the effort is now mostly behind me. Big thanks to all of you who stayed with me all the way to this end.<br />
Thank you to everyone who messaged me corrections and comments. Please let me know your thoughts on this installment.<br />
Good luck with your projects, I hope you will use types!</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Not very relevant to TS, but could be interesting to philosophically inclined readers. Can a function returning, say, the current time be ever referentially transparent? Some languages (like Idris or Haskell) are big on referential transparency. In such languages functions can be executed only inside <code>main</code>. Evaluating a timestamp function would not return the current time. Instead, it would return a computation that returns the time when eventually executed inside <code>main</code>. This allows some purists to claim that the function is referentially transparent and has practical implications too. You could simulate a similar purity in TS by returning <a href="2022-02-13-ts-types-part5.html#thunks-and-callbacks-never-and-unknown." target="_blank">thunks</a>.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>You can see some of it in this <a href="https://www.youtube.com/watch?v=DRq2NgeFcO0" target="_blank">youtuble</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>In TS, of course, we have the ability to configure the compiler to verify null safety. In some languages (e.g. JS) you also get partial function by writing code that in certain cases simply does not return. TS is relatively good in preventing this situation, compiler will say “Not all code paths return a value”.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>These languages can be used as proof assistants. One could prove anything (including falsehoods) using, say, unbound recursion. Proof assistant that does not check totality would not be assisting well, would it?<br />
Side note: When using proof assistant, you are proving a type and you are proving it by implementing it.<br />
This equivalence has a name: Curry-Howard correspondence. “Propositions are types, proofs are programs”.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p><a href="https://www.manning.com/books/type-driven-development-with-idris" target="_blank">TDD in Idris</a> book contains some very interesting and accessible examples of monadic computations in dependently typed setting.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>It is good to note that this safety is unique to union types, you will not get the same safety when adding a property to an object. It is interesting and telling that the industry is adding co-product types to programming languages just now.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>A similar and relevant philosophical discussion has been happening in mathematics for centuries (see <a href="https://en.wikipedia.org/wiki/Philosophy_of_mathematics#Mathematical_realism" target="_blank">wikipedia</a>). My opinion on this is that a creative process tends to be iterative leaving a historical evidence of iterations. Mathematics, for most part, has been additive. There was rarely a need to rewire an old theory. As far as I know not in last 100 years.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8" role="doc-endnote"><p>I remember Haskell firmly in the first position for the stackoverflow weekend use statistics for several years. I found this link: <a href="https://stackoverflow.blog/2017/02/07/what-programming-languages-weekends/" target="_blank">2017</a>. These stats are hard to find but I also found this one: <a href="https://stackoverflow.blog/2019/10/28/research-update-coding-on-the-weekends/" target="_blank">2019</a>. In 2019 Rust moved ahead of Haskell.<br />
At the same time, the job ranking (based on the UK’s <a href="https://www.itjobswatch.co.uk/jobs/uk/haskell.do" target="_blank">IT Jobs Watch</a>, I have not found a similar ranking for the US.) puts Haskell at 932 as of 2022/02/06. Haskell moved ahead of COBOL in that ranking in 2017.<br />
This ranking is possibly exaggerated too, lots of jobs list Haskell and good to have but will have you code in PHP. This bias exist in any language but is stronger for something like Haskell than say COBOL.<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9" role="doc-endnote"><p>As an example, Java has resisted type variables for a long time. “Although our generics extensions were put on hold for six years, Sun developed a much keener interest in the compiler I had written for GJ. It proved to be more stable and maintainable than their first Java compiler. So they decided to make the GJ compiler the standard javac compiler from their 1.3 release on, which came out in 2000.” (<a href="https://www.artima.com/articles/the-origins-of-scala" target="_blank">quote from Martin Odersky</a>). Generics remained disabled until Java version 1.5 (2004). Oderky is always very diplomatic in his statements.<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

    </section>
</article>
]]></summary>
</entry>
<entry>
    <title>Type Enthusiast's Notes about TypeScript. Part 5. Advanced Types</title>
    <link href="https://rpeszek.github.io//posts/2022-02-13-ts-types-part5.html" />
    <id>https://rpeszek.github.io//posts/2022-02-13-ts-types-part5.html</id>
    <published>2022-02-13T00:00:00Z</published>
    <updated>2022-02-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
    <section class="header">
        Posted on February 13, 2022
        
            by Robert Peszek
        
        
        
        <div class="changelog"> <div>Revision History: <ul> <li> (2022.02.14) Fixed list example <a href="#fn2">footnote [2]</a> </li> <li> (2022.02.15) Clarifying comments in <a href="#type-level-programming" < a>type level programming</a> code examples</li> </ul> </div></div>
        
        
        <div class="info">Tags: <a title="All pages tagged 'TypeScript-Notes'." href="../tags/TypeScript-Notes.html">TypeScript-Notes</a></div>
        
    </section>
    <section>

    </section>
    <section>
        <div class="toc"><div class="header">Table of Contents</div>
<ul>
<li><a href="#nutshell">Nutshell</a></li>
<li><a href="#recursive-types">Recursive types</a></li>
<li><a href="#type-level-programming">Type level programming</a></li>
<li><a href="#subtyping">Subtyping</a></li>
<li><a href="#thunks-and-callbacks-never-and-unknown.">Thunks and callbacks, <code>never</code> and <code>unknown</code>.</a></li>
<li><a href="#next-and-the-final-chapter">Next and the final Chapter</a></li>
</ul>
</div>
<p><em>Please Leave Feedback in: <a href="https://github.com/rpeszek/rpeszek.github.io/discussions/1" target="_blank">git discussions</a></em></p>
<p>Previous post: <a href="2022-01-09-ts-types-part4.html" target="_blank">Part 4. Programming with Type Variables</a>.</p>
<p><strong>DRAFT version</strong> <em>(I am sorry about any misprints. It seems I have goblins in my laptop that toy with me, remove or change words. When this note disappears, you will know that I gave up.)</em></p>
<p><strong>Disclaimers:</strong> (imagine this is a very small font, read it very fast in a half whisper)<br />
<em>I assume strict compiler flags are on, something you get by default with scaffolding, e.g. using <code>create-react-app my-project --template typescript</code> is close enough.<br />
The code examples have been tested with TypeScript v4.5.2.<br />
This post is a pandoc output of a markdown document and code examples are not interactive.<br />
Most of the code examples are published in <a href="https://github.com/rpeszek/ts-experiments/tree/master/ts-notes" target="_blank">ts-notes</a> folder in this github repo: <a href="https://github.com/rpeszek/ts-experiments" target="_blank">ts-experiments</a>.</em></p>
<p><strong>Motivating Quote for the series:</strong></p>
<blockquote>
<p>“TypeScript began its life as an attempt to bring traditional object-oriented types to JavaScript so that the programmers at Microsoft could bring traditional object-oriented programs to the web. As it has developed, TypeScript’s type system has evolved to model code written by native JavaScripters. The resulting system is <em>powerful, interesting and messy.</em>”</p>
</blockquote>
<p><em>From typescriptlang <a href="https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html" target="_blank">TypeScript for Functional Programmers</a></em></p>
<h2 id="nutshell">Nutshell</h2>
<p>This is the fifth post in the series devoted to types in TypeScript. In this series, I explore type-centric approaches to writing code and push TS to its limits in doing so. I am writing these posts for like minded developers who are interested in types and either use or consider using TypeScript.</p>
<p>In the last post I referenced the <a href="https://www.goodreads.com/book/show/112252.Types_and_Programming_Languages" target="_blank">Types and Programming Languages</a> book. Similarly to the previous post, this installment will be a little more advanced and a little TAPL-ish. I will also introduce a tiny bit of Category Theory. A great blog series (really a book) about Categories is <a href="https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/" target="_blank">Category Theory for Programmers</a>, here it is <a href="https://www.goodreads.com/en/book/show/33618151-category-theory-for-programmers" target="_blank">on goodreads</a>.</p>
<h2 id="recursive-types">Recursive types</h2>
<p><code>type JsonVal</code> from <a href="2021-12-12-ts-types-part1.html#typescript-is-great" target="_blank">Part 1</a> surprised me. It is recursive, the name <code>JsonVal</code> appears on both the LHS and the RHS of the definition. Here is this definition repeated:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>type JsonVal <span class="op">=</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="op">|</span> {<span class="dt">type</span><span class="op">:</span> <span class="st">&quot;object&quot;</span><span class="op">,</span> <span class="dt">val</span><span class="op">:</span> <span class="bu">Map</span><span class="op">&lt;</span>string<span class="op">,</span> JsonVal<span class="op">&gt;</span>}</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="op">|</span> {<span class="dt">type</span><span class="op">:</span> <span class="st">&quot;array&quot;</span><span class="op">,</span> <span class="dt">val</span><span class="op">:</span> JsonVal[]}</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="op">|</span> {<span class="dt">type</span><span class="op">:</span> <span class="st">&quot;string&quot;</span><span class="op">,</span> <span class="dt">val</span><span class="op">:</span> string}</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a><span class="op">|</span> {<span class="dt">type</span><span class="op">:</span> <span class="st">&quot;number&quot;</span><span class="op">,</span> <span class="dt">val</span><span class="op">:</span> number}</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a><span class="op">|</span> {<span class="dt">type</span><span class="op">:</span> <span class="st">&quot;bool&quot;</span><span class="op">,</span> <span class="dt">val</span><span class="op">:</span> boolean}</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a><span class="op">|</span> {<span class="dt">type</span><span class="op">:</span> <span class="st">&quot;null&quot;</span>}</span></code></pre></div>
<p>and there are TAPLish reasons why this is interesting:</p>
<p> <div class="side-note">The two established approaches for implementing recursive types in a programming language are</p>
<ul>
<li><em>iso-recursion</em> (good fit for nominal types<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>). If you know <em>recursion schemes</em>, the compilation technique is very similar to how the <code>Fix</code> type and the <em>recursion schemes</em> work in nominally typed languages like <em>Scala</em>, <em>Haskell</em>, etc. You kinda roll (Fix) or unroll (unFix) one layer of recursion at the time.</li>
<li><em>equi-recursion</em> (good fit for structural types). There is no <code>Fix/unFix</code> game. The structure is already unraveled into a potentially infinite beast. The compiler needs to deal with the whole beast. This approach is much harder to implement.</li>
</ul>
<p><code>JsonVal</code> looks like an equi-recursive definition. The methodology behind equi-recursion involves monotone functions and other things I never found time to understand very well. Hard stuff and quite a bit of math. I have not dug deep enough to know how TS compiles <code>JsonVal</code> like types. No matter what it does, it is IMO impressive.<br />
 </div></p>
<p><code>JsonVal</code>-like types appear to be hard on the TS type checker. I have played with some advanced recursive types and have experienced it first hand. I got quite a few</p>
<blockquote>
<p>‘Type instantiation is excessively deep and possibly infinite’</p>
</blockquote>
<p>compiler errors (e.g. code in <a href="https://github.com/rpeszek/ts-typecheck-peano" target="_blank">https://github.com/rpeszek/ts-typecheck-peano</a>). However, I did not succeed in creating a simple example to demonstrate this.</p>
<p>Here is another example of a recursive type:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>type List<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">=</span> </span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="op">|</span> {<span class="dt">type</span><span class="op">:</span> <span class="st">&quot;nil&quot;</span>} </span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="op">|</span> {<span class="dt">type</span><span class="op">:</span> <span class="st">&quot;cons&quot;</span><span class="op">,</span> <span class="dt">head</span><span class="op">:</span> T<span class="op">,</span> <span class="dt">tail</span><span class="op">:</span> List<span class="op">&lt;</span>T<span class="op">&gt;</span>}</span></code></pre></div>
<p>That is a recursive definition of a functional <em>cons</em> list<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.</p>
<p>IMO, it is impressive that TS is able to pull these off. I consider this feature very useful and underutilized by the ecosystem. Here is some more advanced use of recursive types:</p>
<p> <div class="side-note">The github repo with code examples for this series includes <a href="https://github.com/rpeszek/ts-experiments/blob/master/ts-notes/src/RecSchemes.ts" target="_blank">RecSchemes.ts</a>. This module contains code that allows for <em>folding</em> (TS/JS ecosystem tends to use the term <em>reduce</em>) and <em>unfolding</em> of arbitrary JSON values (expressed as the above <code>JsonVal</code>).</p>
<p>Such approach is called <em>Recursion Schemes</em>. If you are not familiar with this concept, you are likely to have two reactions: “the code looks surprisingly terse” and “WTF is going on”. IMO any code that solicits these 2 reactions is worth exploring. The first suggests a principled code, the second suggests an opportunity to internalize some fundamental principles.</p>
<p>One high level intuition about recursion schemes is that they abstract out/hide recursion.<br />
Readers not familiar with Recursion Schemes should try implementing an analogous <code>fold</code> for the above <code>List</code> type and compare its type with TS’s array <code>reduce</code>. Recursion schemes are not easy, at least they were not easy to learn for me.<br />
Since this technique can be applied to many other recursive types, recursion schemes could be used as a pattern in TS.</p>
<p>Recursion Schemes are firmly rooted in theory. For example, the <code>fold</code> and <code>unfold</code> definitions in my example follow from categorical concepts explained <a href="https://bartoszmilewski.com/2017/02/28/f-algebras/" target="_blank">here</a><a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>.<br />
This technique is also very useful. Examples are: manipulating XML documents, rewriting AST (syntax trees) of interpreted programs. A lot of code at my current work is using recursion schemes (we are not doing it in TS though). In the TS/JS world, you could think about presenting very nested data by folding it into a nested React component. Working with any recursive type is likely to benefit from using recursion schemes.</p>
<p>Even though TS is not capable of implementing recursion schemes the way they are done in Haskell or Scala, there is some simplifying benefit of TS’s structural typing. The linked code examples explain this in code comments. It is really nice that code like this is possible in TS.  </div></p>
<h2 id="type-level-programming">Type level programming</h2>
<p>TS literal types are singletons (i.e. type <code>"boo"</code> has exactly one value <code>"boo":"boo"</code>). This allows singletons to magically connect types with values and values with types. That provides a lot of power to create very precise types.<br />
Literal types should not be that hard to implement in a programming language and it is interesting why they are so uncommon. Kudos to TS for introducing these! They are, clearly, a great fit for JS.<br />
However, TS literal types are very limited in scope (I remember reading somewhere that it was a design decision). For example, you can do some very basic type level string manipulation but you cannot concatenate strings or do any arithmetic on type level numbers and you have no way of defining any additional features on your own (e.g. DIY number addition).</p>
<p>TypeScript allows for type-level ternary (<em>Conditional Types</em>) as well as various type-level built-in functions (e.g. <code>keyof</code>).<br />
Apparently, the type level programming in TypeScript is <em>Turing Complete</em> (see <a href="https://github.com/microsoft/TypeScript/issues/14833" target="_blank">https://github.com/microsoft/TypeScript/issues/14833</a>).<br />
However, type level programming in TS is focused on creating type safety for various JS code idioms rather than creating a foundation for DIY type level programming. IMO this makes it harder to learn. The <em>Turing completeness</em> appears to be a completely accidental language feature.</p>
<p>Type level programming can be very useful, we have seen some of it in action in the <a href="2022-01-09-ts-types-part4.html" target="_blank">previous post</a> where we were able to prevent subtyping and prevent compiler from using the <code>unknown</code> type.</p>
<p>IMO the best language design direction is for the type level and the value level code to look the same (e.g. dependently typed language like Idris). The second best approach is for type level and value level to be very similar (e.g. Haskell).<br />
TS cannot and should not do either. We do not want JavaScript (or very similar) on the type level!</p>
<p>At the same time, the lack of synergy between type level and value level programs makes things very complicated. E.g.:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="co">//example type from https://www.typescriptlang.org/docs/handbook/2/conditional-types.html</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>type Flatten<span class="op">&lt;</span>Type<span class="op">&gt;</span> <span class="op">=</span> Type <span class="kw">extends</span> <span class="bu">Array</span><span class="op">&lt;</span>infer Item<span class="op">&gt;</span> <span class="op">?</span> Item <span class="op">:</span> Type<span class="op">;</span> </span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a><span class="kw">const</span> head <span class="op">=</span> <span class="op">&lt;</span>T<span class="op">&gt;</span> (t<span class="op">:</span> T[]) <span class="op">:</span> Flatten<span class="op">&lt;</span>T[]<span class="op">&gt;</span> <span class="kw">=&gt;</span> {</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>    <span class="cf">return</span> t[<span class="dv">0</span>] <span class="co">//compiles (as expected)</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="dt">const</span> generalizedHead = &lt;T&gt; (t: T) : Flatten&lt;T&gt; =&gt; {</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>    <span class="kw">if</span>(<span class="bu">Array</span>.<span class="fu">isArray</span>(t)) </span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>        <span class="kw">return</span> t[<span class="dv">0</span>]  <span class="co">//still compiles (as expected)</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>    <span class="kw">else</span> </span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>        <span class="kw">return</span> t <span class="co">//compiler error: Type 'T' is not assignable to type 'Flatten&lt;T&gt;' (not as I would expect)</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>}</span></code></pre></div>
<p>here is another one:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>type HasContent<span class="op">&lt;</span>C<span class="op">&gt;</span> <span class="op">=</span> {<span class="dt">content</span><span class="op">:</span> C}</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>type GetContent<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">=</span> T <span class="kw">extends</span> HasContent <span class="op">&lt;</span>infer C<span class="op">&gt;</span> <span class="op">?</span> C <span class="op">:</span> T</span></code></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="dt">const</span> getContent = &lt;C, T <span class="kw">extends</span> HasContent&lt;C&gt;&gt; (t: T): GetContent&lt;T&gt; =&gt; {</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>   <span class="co">//return t.content //compiler error:  Type 'C' is not assignable to type 'GetContent&lt;T&gt;' (not as expected)</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>}</span></code></pre></div>
<p>It feels clunky. It feels like type level and value level have a broken marriage. This lack of synergy also feels very confusing.</p>
<p>I think TS type level programming will keep improving and we may see some very interesting use cases in the future.</p>
<h2 id="subtyping">Subtyping</h2>
<p>This series has discussed subtyping already. I will keep this section comparatively short.</p>
<p>Personally, I try to avoid using subtyping features. Subtyping is related to Object Orientation. OO programming has an appeal of simplicity and I was seduced by it for many years. It took me a long time to realize that OO is not that simple. Today, I think about OO as very complex. Even language designers often get it wrong (this series has provided a lot of evidence for this statement in the context of TypeScript). This comment should be filed under IMO as many developers disagree.</p>
<p>Before continuing reading pass this code, please try to implement (at least in your head) the <code>amIFooOrBar</code> function:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">function</span> verifyExtends<span class="op">&lt;</span>T2 <span class="kw">extends</span> T1<span class="op">,</span> T1<span class="op">&gt;</span>() {}</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a><span class="co">//more specific, fewer variants</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>type FooOrBar <span class="op">=</span>  </span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a><span class="op">|</span> {<span class="dt">foo</span><span class="op">:</span> string} </span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a><span class="op">|</span> {<span class="dt">bar</span><span class="op">:</span> string}</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a><span class="co">//A challenge: implement this function:</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>declare <span class="kw">function</span> <span class="fu">amIFooOrBar</span>(o<span class="op">:</span> FooOrBar)<span class="op">:</span> <span class="st">&quot;foo&quot;</span> <span class="op">|</span> <span class="st">&quot;bar&quot;</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a>declare <span class="kw">function</span> <span class="fu">genFooOrBar</span>()<span class="op">:</span> FooOrBar</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true"></a><span class="co">//more general, more variants</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true"></a>type FooOrBarOrBuz <span class="op">=</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true"></a><span class="op">|</span> {<span class="dt">foo</span><span class="op">:</span> string} </span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true"></a><span class="op">|</span> {<span class="dt">bar</span><span class="op">:</span> string}</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true"></a><span class="op">|</span> {<span class="dt">baz</span><span class="op">:</span> string}</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true"></a></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true"></a>declare <span class="kw">function</span> <span class="fu">genFooOrBarOrBuz</span>()<span class="op">:</span> FooOrBarOrBuz</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true"></a></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true"></a><span class="kw">const</span> fooOrBarOrBuz<span class="op">:</span> FooOrBarOrBuz <span class="op">=</span> <span class="fu">genFooOrBar</span>() <span class="co">//compiles assigns specific to more general </span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true"></a><span class="co">//const fooOrBar: FooOrBar = genFooOrBarOrBuz() //will not compile tries to assign general to more specific</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true"></a></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true"></a>verifyExtends<span class="op">&lt;</span>FooOrBar<span class="op">,</span> FooOrBarOrBuz<span class="op">&gt;</span>() <span class="co">//compiles, FooOrBar extends FooOrBarOrBuz</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true"></a><span class="co">//verifyExtends&lt;FooOrBarOrBuz, FooOrBar&gt;() //does not compile, FooOrBarOrBuz does not extend FooOrBar</span></span></code></pre></div>
<p>The thing to remember is that <code>{foo: string} | {bar: string}</code> extends <code>{foo: string} | {bar: string}| {baz: string}</code> not the other way around.</p>
<p>Did you implement <code>amIFooOrBar</code>, great, let’s move on.</p>
<p>Subtyping in object types will feel familiar to OO developers. Roughly speaking, you can assign object with more properties to object with fewer properties:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>type FooAndBar <span class="op">=</span> {<span class="dt">foo</span><span class="op">:</span> string<span class="op">,</span> <span class="dt">bar</span><span class="op">:</span> string} <span class="co">//more general</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>declare <span class="kw">function</span> <span class="fu">genFooAndBar</span>()<span class="op">:</span> FooAndBar</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>type FooAndBarAndBaz <span class="op">=</span> {<span class="dt">foo</span><span class="op">:</span> string<span class="op">,</span> <span class="dt">bar</span><span class="op">:</span> string<span class="op">,</span> <span class="dt">baz</span><span class="op">:</span> string} <span class="co">//more specific</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>declare <span class="kw">function</span> <span class="fu">genFooAndBarAndBaz</span>()<span class="op">:</span> FooAndBarAndBaz</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a><span class="kw">const</span> fooAndBar<span class="op">:</span> FooAndBar <span class="op">=</span> <span class="fu">genFooAndBarAndBaz</span>()  <span class="co">//specific assigned to general is valid assignment</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a><span class="co">//const fooAndBarAndBuz: FooAndBarAndBaz = genFooAndBar() // will not compile, tries to assign general to specific</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a>verifyExtends<span class="op">&lt;</span>FooAndBarAndBaz<span class="op">,</span> FooAndBar<span class="op">&gt;</span>() <span class="co">//compiles, FooAndBarAndBaz extends FooAndBar</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a><span class="co">//verifyExtends&lt;FooAndBar, FooAndBarAndBaz&gt;() //does not compile, FooAndBar does not extend FooAndBarAndBaz</span></span></code></pre></div>
<p>Subtyping gets more involved if you combine adding properties to objects and variants to union types. In TS subtyping extends to functions which makes things even more complex (leading to what I called <a href="2021-12-12-ts-types-part1.html#compilation-bloopers" target="_blank">compilation bloopers</a> in Part 1). But I think the above examples cover the basic idea.</p>
<p>Now let’s revisit the above challenge. What will your function return in this call:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="co">// challenge check:</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a><span class="co">// what does your function return when used on this value?</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a><span class="co">// </span><span class="al">NOTE</span><span class="co"> this does compile, you can assign FooAndBar to FooOrBar, since 'and' implies 'or'</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a><span class="kw">const</span> whatIsThat <span class="op">=</span> <span class="fu">amIFooOrBar</span>({<span class="dt">foo</span><span class="op">:</span> <span class="st">&quot;foo&quot;</span><span class="op">,</span> <span class="dt">bar</span><span class="op">:</span> <span class="st">&quot;bar&quot;</span>}) </span></code></pre></div>
<p>This is just one of the many gotchas associated with subtyping.</p>
<h2 id="thunks-and-callbacks-never-and-unknown.">Thunks and callbacks, <code>never</code> and <code>unknown</code>.</h2>
<p>To finish this post I want to pick 4 concepts fundamental to TypeScript: variables, callbacks, <code>never</code> and <code>unknown</code> types and discuss how they relate in a somewhat more theoretical setting. I believe the relationship between these concepts is not commonly understood.</p>
<p>We have seen <code>&lt;T&gt; () =&gt; T</code> before, we called it a <a href="2021-12-12-ts-types-part1.html#type-holes" target="_blank">type hole <code>_: &lt;T&gt;() =&gt; T</code></a>. Now I am changing my mind and want to call it a generic thunk.<br />
We can think about it as a ‘lazy’ value.<br />
Instead of defining <code>const t: T</code> (which, incidentally, TS does not allow on the top level<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>) I can define a function that, when called, will return me that <code>t</code>. Basically thunks are variables you put the <code>()</code> after. A referentially transparent (no side-effects) <code>&lt;T&gt; () =&gt; T</code> thunk is morally equivalent to a variable of type <code>T</code>.</p>
<p>A thunk produces a value of type <code>T</code>. A generic callback <code>&lt;T&gt; (_: T) =&gt; void</code> consumes a value of type <code>T</code>. There is, clearly, some type of duality between thunks and callbacks.<br />
Incidentally, many programming languages define a <em>unit</em> type often denoted as <code>()</code> instead of the <em>C</em>-style <code>void</code>. If this was the case for TS, we would have written: <code>&lt;T&gt; T =&gt; ()</code> for the callback and <code>&lt;T&gt; () =&gt; T</code> for the thunk. You can get from one type to the other by reversing the arrow <code>=&gt;</code>. These concepts become dual in the categorical sense. This post is not about Category Theory but this section has just a tiny bit of it.</p>
<p>In TS, the generic thunk <code>&lt;T&gt; () =&gt; T</code> type is equivalent to <code>never</code>.<br />
You may remember that the <a href="2021-12-12-ts-types-part1.html#type-holes" target="_blank">type hole <code>_()</code></a>, was implemented by throwing an error (that is <code>never</code> in TS).<br />
<code>never</code> assigns to everything but you cannot assign anything else to it. Well, except for the generic thunk:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="co">//thunk assigned to never</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a><span class="kw">const</span> nevr <span class="op">:</span> never <span class="op">=</span> <span class="fu">_</span>()</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a><span class="im">export</span> <span class="kw">const</span> __neverFn<span class="op">:</span> () <span class="kw">=&gt;</span> never <span class="op">=</span>  _</span></code></pre></div>
<p>In other words <code>&lt;T&gt; () =&gt; T</code> and <code>() =&gt; never</code> can be assigned to each other, thus, I consider them equivalent.</p>
<p>If you replay the same argument with arrows reversed, you will establish equivalence between the generic callback <code>&lt;T&gt; (_: T) =&gt; ()</code> and the <code>unknown</code> callback types:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a>declare <span class="kw">function</span> <span class="fu">someUnknownCallback</span>(t<span class="op">:</span> unknown)<span class="op">:</span> <span class="kw">void</span> </span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a><span class="kw">const</span> overbar<span class="op">:</span> <span class="op">&lt;</span>T<span class="op">&gt;</span>(_<span class="op">:</span>T) <span class="kw">=&gt;</span> <span class="kw">void</span> <span class="op">=</span>  someUnknownCallback</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>declare <span class="kw">function</span> someOverbar<span class="op">&lt;</span>T<span class="op">&gt;</span>(t<span class="op">:</span>T)<span class="op">:</span> <span class="kw">void</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a><span class="kw">const</span> unknownCallback<span class="op">:</span> (_<span class="op">:</span> unknown) <span class="kw">=&gt;</span> <span class="kw">void</span> <span class="op">=</span> someOverbar</span></code></pre></div>
<p>The <code>never</code> type is the TS’s <em>bottom</em> type (can be assigned to anything), while the <a href="2021-12-24-ts-types-part2.html#note-about-the-unknown-type" target="_blank"><code>unknown</code></a> type is the TS’s <em>top</em> type (anything can be assigned to it). These concepts are also dual in the sense of reversing the direction of assignment.</p>
<p>Let’s think about referential transparency again. There are no interesting referentially transparent functions that return <code>void</code>. To do something meaningful, such a function would need to mutate some shared state or do some other effectful things. E.g. when coding in React, a callback could compute a new state (let me call it <code>r: R</code>) and invoke a state hook to make the change. I like to think about such a callback as having an imaginary type <code>&lt;T,R&gt; (t: T) =&gt; R</code>.</p>
<p>The duality between variables/thunks and callback is quite fascinating and has some depth.<br />
Let’s fix the type variable <code>T</code> to, say, <code>Person</code>. Any type would do, I just want to remove the quantification (remove the genericity) to simplify my explanation.<br />
JS / TS programs often use higher order functions that accept callbacks as parameters. Consider a callback that accepts a callback <code>(f: (_: Person) =&gt; void) =&gt; void</code> and computes the same value. The imaginary referentially transparent type for it could be</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode typescript"><code class="sourceCode typescript"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="co">//TS-like pseudocode</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a><span class="op">&lt;</span>R<span class="op">&gt;</span> (f<span class="op">:</span> (_<span class="op">:</span> Person) <span class="kw">=&gt;</span> R) <span class="kw">=&gt;</span> R</span></code></pre></div>
<p>As it turns out, this type is equivalent (isomorphic) to the thunk <code>() =&gt; Person</code> (or, ignoring side-effects, to just <code>Person</code>)!<br />
They are not equivalent based on assignments, they are equivalent because one can be easily converted to the other.</p>
<p>It kinda makes sense for a dual of a dual to end up back where we started.<br />
However, this equivalence is a bit stronger, in a sense that it holds for every fixed type <code>T</code>. It is also weaker, since what we get is only isomorphism<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>.</p>
<p>This equivalence is a special case of <a href="https://bartoszmilewski.com/2015/09/01/the-yoneda-lemma/" target="_blank"><em>Yoneda Lemma</em></a> in Category Theory<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>.</p>
<p>I can express this succinctly in TS (note a <a href="2022-01-09-ts-types-part4.html#higher-rank-types" target="_blank">higher rank type</a> is used) as:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="co">//all of these compile</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>type Yoneda<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">=</span> () <span class="kw">=&gt;</span> <span class="op">&lt;</span>R<span class="op">&gt;</span>(f<span class="op">:</span> (_<span class="op">:</span> T) <span class="kw">=&gt;</span> R) <span class="kw">=&gt;</span> R</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>type Thunk<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">=</span> () <span class="kw">=&gt;</span> T</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a><span class="co">//Yoneda&lt;T&gt; is isomorphic to Thunk&lt;T&gt;</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a><span class="co">//here are functions defining the isomorphism:</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a><span class="kw">const</span> toYoneda <span class="op">=</span> <span class="op">&lt;</span>T<span class="op">&gt;</span> (th<span class="op">:</span> Thunk<span class="op">&lt;</span>T<span class="op">&gt;</span>)<span class="op">:</span> Yoneda<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="kw">=&gt;</span> {</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a>   <span class="kw">const</span> res <span class="op">=</span> () <span class="kw">=&gt;</span> <span class="op">&lt;</span>R<span class="op">&gt;</span> (<span class="dt">f</span><span class="op">:</span> (<span class="dt">_</span><span class="op">:</span> T) <span class="kw">=&gt;</span> R)<span class="op">:</span> R <span class="kw">=&gt;</span> <span class="fu">f</span>(<span class="fu">th</span>())</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a>   <span class="cf">return</span> res</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a>}</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true"></a></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true"></a><span class="kw">const</span> fromYoneda <span class="op">=</span> <span class="op">&lt;</span>T<span class="op">&gt;</span> (y<span class="op">:</span> Yoneda<span class="op">&lt;</span>T<span class="op">&gt;</span>)<span class="op">:</span> Thunk<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="kw">=&gt;</span> {</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true"></a>    <span class="kw">const</span> res <span class="op">=</span> ()<span class="op">:</span> T <span class="kw">=&gt;</span> <span class="fu">y</span>()(x <span class="kw">=&gt;</span> x)</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true"></a>    <span class="cf">return</span> res</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true"></a> }</span></code></pre></div>
<p>Programmers are divided into 2 camps when exploring this type of information: some consider it fascinating and important, some consider it a lot of useless nonsense. If you are still reading this series, chances are you are in the first camp.</p>
<p> <div class="side-note"><strong>Callback in JS:</strong> I believe, JavaScripters intuitively know that equivalence and callbacks are viewed almost as a coding style. JS uses callbacks to accomplish all kinds of things. Except, for some reason, JS decided to endure <em>callback hell</em> for about 2 decades. Today’s <code>async</code> / <code>await</code> code finally brings an end to that mystery.<br />
Understanding that programming with callbacks (often called <em>Continuation Passing Style</em><a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>) and vanilla synchronous programming can offer very similar interface dates back to very early 1990-ties. This has to do with the programming abstraction that also comes from Category Theory called <em>Monad</em>.  </div></p>
<p>Category Theory is very related to types and to programming in general, I found it only fitting to finish this installment with a note that discussed a little bit of it.<br />
Bartosz Milewski’s CTFP book linked above starts with code examples in C++ and in Haskell. Bartosz gives up on C++ very fast. I think it would be possible to stay on a little longer by selecting TS instead of C++. Kudos to TS!</p>
<h2 id="next-and-the-final-chapter">Next and the final Chapter</h2>
<p>I will finish the series with some final thoughts and rants.<br />
The last 2 installments got a little on an advanced side of things. One question I have been asking myself is: When should more advanced types be used in a TS project?</p>
<p>Here is the link: <a href="2022-03-13-ts-types-part6.html" target="_blank">Part 6</a></p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>As we have discussed in <a href="2022-01-09-ts-types-part4.html#phantom-types" target="_blank">Part 3</a>, TS types are structural. That means the name <code>Person</code> in <code>type Person = {firstNm: String, lastNm: String}</code> is only an alias, what defines the type is the RHS of the definition, not the LHS. Contrast this with an OO class definition in a language like Java. Two structurally identical classes are still considered different types (this is called <em>nominal</em> typing).<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>I originally posted an issue related to the list and I misinterpreted the problem behind it. Thanks to <a href="https://www.reddit.com/user/joelahoover" target="_blank">u/joelahoover</a> for pointing it out. TS tends to widen literal strings to <code>string</code>. So a value defined as <code>const v = {type: "cons", 1, tail: {type: 'nil'}}</code> or even <code>const empty = {type: 'nil'}</code> are not valid lists unless you use something like <code>as const</code>, e.g. <code>const empty = {type: "nil"} as const</code>. TS does not try to infer the best possible type (it does not care about what is called principal typing).<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>The code examples in the linked CTFP chapter require a <code>Fix</code> type that allows for rolling (applying <code>Fix</code>) and unrolling (deconstructing <code>Fix</code>), this complexity is due to nominal typing and iso-recursion, TS makes things actually simpler.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>You can use <code>const t: T</code> only inside functions that declare <code>T</code> in its type.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>Think about isomorphism as being able to convert one type to the other without any information loss or gain<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>It is Yoneda applied to the <em>Identity functor</em><a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>I believe the term Continuation Passing Style goes back as far as 1950ties.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

    </section>
</article>
]]></summary>
</entry>
<entry>
    <title>Type Enthusiast's Notes about TypeScript. Part 4. Programming with Type Variables</title>
    <link href="https://rpeszek.github.io//posts/2022-01-09-ts-types-part4.html" />
    <id>https://rpeszek.github.io//posts/2022-01-09-ts-types-part4.html</id>
    <published>2022-01-09T00:00:00Z</published>
    <updated>2022-01-09T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
    <section class="header">
        Posted on January  9, 2022
        
            by Robert Peszek
        
        
        
        <div class="changelog"> <div>Revision History: <ul> <li> (2022.05.10 - Present) Minor edits </li> </ul> </div></div>
        
        
        <div class="info">Tags: <a title="All pages tagged 'TypeScript-Notes'." href="../tags/TypeScript-Notes.html">TypeScript-Notes</a></div>
        
    </section>
    <section>

    </section>
    <section>
        <div class="toc"><div class="header">Table of Contents</div>
<ul>
<li><a href="#nutshell">Nutshell</a></li>
<li><a href="#safety-preventing-unknown">Safety preventing <code>unknown</code></a></li>
<li><a href="#type-variable-scoping">Type variable scoping</a></li>
<li><a href="#higher-rank-types">Higher Rank types</a></li>
<li><a href="#existential-types">Existential types</a>
<ul>
<li><a href="#replacing-factory-pattern">Replacing factory pattern</a></li>
<li><a href="#preventing-information-escape">Preventing information escape</a></li>
</ul></li>
<li><a href="#safety-preventing-subtyping">Safety preventing subtyping</a></li>
<li><a href="#phantom-types">Phantom types</a></li>
<li><a href="#next-chapter">Next Chapter</a></li>
</ul>
</div>
<p><em>Please Leave Feedback in: <a href="https://github.com/rpeszek/rpeszek.github.io/discussions/1" target="_blank">git discussions</a></em></p>
<p>Previous post: <a href="2022-01-03-ts-types-part3.html" target="_blank">Part 3. TS Complexity</a>.</p>
<p><strong>DRAFT version</strong> <em>(I am sorry about any misprints. It seems I have goblins in my laptop that toy with me, remove or change words. When this note disappears, you will know that I gave up.)</em></p>
<p><strong>Disclaimers:</strong> (imagine this is a very small font, read it very fast in a half whisper)<br />
<em>I assume strict compiler flags are on, something you get by default with scaffolding, e.g. using <code>create-react-app my-project --template typescript</code> is close enough.<br />
The code examples have been tested with TypeScript v4.5.2.<br />
This post is a pandoc output of a markdown document and code examples are not interactive.<br />
Most of the code examples are published in <a href="https://github.com/rpeszek/ts-experiments/tree/master/ts-notes" target="_blank">ts-notes</a> folder in this github repo: <a href="https://github.com/rpeszek/ts-experiments" target="_blank">ts-experiments</a>.</em></p>
<p><strong>Motivating Quote for the series:</strong></p>
<blockquote>
<p>“TypeScript began its life as an attempt to bring traditional object-oriented types to JavaScript so that the programmers at Microsoft could bring traditional object-oriented programs to the web. As it has developed, TypeScript’s type system has evolved to model code written by native JavaScripters. The resulting system is <em>powerful, interesting and messy.</em>”</p>
</blockquote>
<p><em>From typescriptlang <a href="https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html" target="_blank">TypeScript for Functional Programmers</a></em></p>
<h2 id="nutshell">Nutshell</h2>
<p>This is the fourth post in the series devoted to types in TypeScript. In this series, I explore type-centric approaches to writing code and push TS to its limits in doing so. I am writing these posts for like minded developers who are interested in types and either use or consider using TypeScript.</p>
<p>This post will be a little more advanced and will focus on programming with type variables.</p>
<p><a href="https://www.goodreads.com/book/show/112252.Types_and_Programming_Languages" target="_blank">Types and Programming Languages</a> is the book about types I recommend to everyone (… even if not very successfully). Reading TAPL will be a big eye opener for many developers. The good news is that types dramatically increase programming efficiency so learning them is a good investment.<br />
This section of the post will be a little more TAPL-ish with some more advanced CS. The topics I am about to present are IMO very useful and I will try my best to present them in a digestible way.</p>
<p>I will discuss type variable scoping, rank-2 types, and existential types. Some examples show a level of safety that I did not expect to be able to pull off! As it turns out, we can even prevent subtyping in TS.</p>
<p>Before we start I need to build up some tooling. I will start with a tiny bit of type level programming.</p>
<h2 id="safety-preventing-unknown">Safety preventing <code>unknown</code></h2>
<p>In previous posts, we have seen examples where TS decided to widen types to <code>unknown</code> rather than report a compilation error.<br />
Interestingly, TS allows enough type level programming so we can try to fix such issues ourselves.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>type IsUnknown<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">=</span> unknown <span class="kw">extends</span> T<span class="op">?</span> <span class="kw">true</span><span class="op">:</span> <span class="kw">false</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="kw">function</span> verifyUnknown<span class="op">&lt;</span>T<span class="op">&gt;</span>(p<span class="op">:</span> IsUnknown<span class="op">&lt;</span>T<span class="op">&gt;,</span> t<span class="op">:</span> T)<span class="op">:</span> T {</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>    <span class="cf">return</span> t</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>}</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a><span class="fu">verifyUnknown</span>(<span class="kw">false</span><span class="op">,</span> <span class="st">&quot;test&quot;</span>)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a><span class="kw">const</span> unk<span class="op">:</span> unknown <span class="op">=</span> {}</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a><span class="fu">verifyUnknown</span>(<span class="kw">true</span><span class="op">,</span> unk)</span></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="co">//Compilation Error</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="co">//Argument of type 'false' is not assignable to parameter of type 'true'.ts(2345)</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="fu">verifyUnknown</span>(<span class="kw">false</span>, unk)</span></code></pre></div>
<p>In my first post, I had an example of incorrect code <a href="2021-12-12-ts-types-part1.html#bumps-on-the-path" target="_blank"><code>body4</code></a> inferred as <code>unknown</code> instead of a <code>string</code>. Wrapping such code in <code>verifyUnknown(false, body4)</code> would have alerted me with a compilation error.<br />
You may point out that a much simpler solution is to just type annotate: <code>const body4: string</code>.<br />
I agree. However, having a more generic solution at our disposal is also useful. We will see shortly why.</p>
<p>Here is a short TAPL-ish explanation of what just happened. TS allows me to use type level ternaries. <code>IsUnknown&lt;T&gt;</code> is a type level function (TAPL’sh term for this is <em>Type Family</em>) that maps types <code>T</code> to literal boolean types <code>true</code> or <code>false</code>. These types have only a single (a <em>singleton</em>) value: <code>true: true</code> and <code>false: false</code>. If I write <code>verifyUnknown(false, someExpression)</code>, TS will figure out that it has to use <code>false</code> as the type. <code>false</code> matches the second part of the type level ternary and, thus, implies that the ternary predicate <code>unknown extends T</code> is not true. Hence <code>T</code> is not <code>unknown</code>.</p>
<p>I will use <code>verifyUnknown</code> to do some type level trickery. You may wonder if we can extend this approach to other types, not just to <code>unknown</code>. I will get there in this post as well.</p>
<h2 id="type-variable-scoping">Type variable scoping</h2>
<p>Type variable scoping has two aspects. Let’s start with the most obvious one. The type variable being visible inside of the implementation body. This is simple stuff, I just want to share an obvious gotcha that got me at some point:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="im">export</span> <span class="kw">const</span> bodyScopeExample1 <span class="op">=</span> <span class="op">&lt;</span>T<span class="op">&gt;</span>(value<span class="op">:</span> T <span class="op">|</span> <span class="kw">undefined</span> <span class="op">|</span> <span class="kw">null</span>)<span class="op">:</span> <span class="kw">void</span> <span class="kw">=&gt;</span> {</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>    <span class="cf">if</span>(value) {</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>        <span class="kw">const</span> <span class="dt">t</span><span class="op">:</span> T <span class="op">=</span> value <span class="co">//you can access type variables in function body</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>    }</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>}</span></code></pre></div>
<p>This approach to defining type signatures (actually my preferred way to write function type signatures) puts <code>T</code> out of scope:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>export <span class="dt">const</span> bodyScopeExample2: &lt;T&gt;(_: T | undefined | <span class="kw">null</span>) =&gt; <span class="dt">void</span> = value =&gt; {</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>    <span class="kw">if</span>(value) {</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>        <span class="dt">const</span> t: T = value  <span class="co">//Cannot find name 'T'.ts(2304)</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>    }</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>}</span></code></pre></div>
<p>For the type variables to be visible in the implementation they need to be on the <em>RHS</em> of <code>=</code>.</p>
<p>The other aspect of type variable scoping is much more interesting:</p>
<h2 id="higher-rank-types">Higher Rank types</h2>
<p>Consider these 2 function declarations:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>declare <span class="kw">function</span> fn1<span class="op">&lt;</span>T<span class="op">&gt;</span> (f<span class="op">:</span>(t<span class="op">:</span>T)<span class="kw">=&gt;</span> <span class="kw">void</span>)<span class="op">:</span> <span class="kw">void</span> </span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>declare <span class="kw">function</span> <span class="fu">fn2</span>(f<span class="op">:</span> <span class="op">&lt;</span>T<span class="op">&gt;</span>(t<span class="op">:</span>T)<span class="kw">=&gt;</span> <span class="kw">void</span>)<span class="op">:</span> <span class="kw">void</span> </span></code></pre></div>
<p>In <code>fn2</code> the scope of <code>T</code> is much narrower. In TAPL-ish this would be called a rank-2 type.<br />
So what is the difference? Let’s try to use both:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="kw">const</span> useStr <span class="op">=</span> (s<span class="op">:</span>string)<span class="op">:</span> <span class="kw">void</span> <span class="kw">=&gt;</span> {}</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="fu">fn1</span>(useStr)</span></code></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="co">//Compilation Error:</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="co">//const useStr: (s: string) =&gt; void</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a><span class="co">//Argument of type '(s: string) =&gt; void' is not assignable to parameter of type '&lt;T&gt;(t: T) =&gt; void'.</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a><span class="co">//  Types of parameters 's' and 't' are incompatible.</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a><span class="co">//    Type 'T' is not assignable to type 'string'.ts(2345)</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a><span class="fu">fn2</span>(useStr)</span></code></pre></div>
<p>Basically <code>fn2</code> requires the argument to be fully generic and <code>useStr</code> is not.</p>
<p>I can play the same games with generic arguments that return <code>T</code></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>declare <span class="kw">function</span> <span class="fu">fn4</span>(f<span class="op">:</span> <span class="op">&lt;</span>T<span class="op">&gt;</span>() <span class="kw">=&gt;</span> T)<span class="op">:</span> <span class="kw">void</span></span></code></pre></div>
<p>but will not do that here as these tend to be less practically useful.</p>
<p>Here is how I think about it:</p>
<p><em>Higher rank means generics are first class</em></p>
<h2 id="existential-types">Existential types</h2>
<p>In TAPL-ish this is called <em>existential quantification</em> and it has to do with the ownership of definitions. In OO you would say “code to interfaces, not implementation”, it is also related to the OO concepts of <em>inversion of control</em> and <em>dependency injection</em>. Here is how the story goes:</p>
<h3 id="replacing-factory-pattern">Replacing factory pattern</h3>
<div class="sourceCode" id="cb9"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">interface</span> Foo {</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>    <span class="dt">foo</span><span class="op">:</span> string</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>}</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a><span class="kw">class</span> MyFoo <span class="kw">implements</span> Foo{</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>    <span class="dt">foo</span><span class="op">:</span> string</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>    <span class="fu">constructor</span>() {</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>        <span class="kw">this</span><span class="op">.</span><span class="at">foo</span> <span class="op">=</span> <span class="st">&quot;bar&quot;</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a>    }</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a>}</span></code></pre></div>
<p>We want to be able to hide which implementation of <code>Foo</code> we are passing to a callback.<br />
Our first approach tries to use a vanilla TS generic function with a callback argument.<br />
The input function parameter uses some <code>&lt;T extends Foo&gt;</code> of an unknown exact implementation type:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>function factoryWithCallback&lt;T <span class="kw">extends</span> Foo&gt; (f:(_:T) =&gt; <span class="dt">void</span>): <span class="dt">void</span> {</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>    <span class="co">//Argument of type 'MyFoo' is not assignable to parameter of type 'T'.</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>    <span class="co">// 'MyFoo' is assignable to the constraint of type 'T', but 'T' could be instantiated with a different subtype of constraint 'Foo'.ts(2345)</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>    <span class="fu">f</span>(<span class="kw">new</span> <span class="fu">MyFoo</span>()) <span class="co">//Compilation Error</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>}</span></code></pre></div>
<p>It does not work and it should not work! We need to use a rank-2 definition:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="co">//Compiles!</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a><span class="kw">function</span> <span class="fu">existencialFactory</span>(f<span class="op">:</span> <span class="op">&lt;</span>T <span class="kw">extends</span> Foo<span class="op">&gt;</span>(_<span class="op">:</span>T) <span class="kw">=&gt;</span> <span class="kw">void</span>)<span class="op">:</span> <span class="kw">void</span> {</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>    <span class="fu">f</span>(<span class="kw">new</span> <span class="fu">MyFoo</span>())</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>}</span></code></pre></div>
<p>This simulates what is called an existential type. The function that accepts a callback owns the definition of the exact type that is passed to the callback. The callback itself needs to be generic and accept any possible implementation.<br />
Note the scoping of <code>T</code> inside the type defining the function parameter.</p>
<p>This <em>inverts the control</em> from the implementation of the callback to the caller.</p>
<p> <div class="side-note"><strong>Note on terminology:</strong> Repeating the above definitions</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a>declare <span class="kw">function</span> fn1<span class="op">&lt;</span>T<span class="op">&gt;</span> (f<span class="op">:</span>(t<span class="op">:</span>T)<span class="kw">=&gt;</span> <span class="kw">void</span>)<span class="op">:</span> <span class="kw">void</span> </span></code></pre></div>
<p>The <code>fn1</code> needs to be defined for all possible types <code>T</code>. The name for it is <em>universal quantification</em>. Some languages even use the <code>forall</code> keyword to describe it.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a>declare <span class="kw">function</span> <span class="fu">fn2</span>(f<span class="op">:</span> <span class="op">&lt;</span>T<span class="op">&gt;</span>(t<span class="op">:</span>T)<span class="kw">=&gt;</span> <span class="kw">void</span>)<span class="op">:</span> <span class="kw">void</span> </span></code></pre></div>
<p><code>fn2</code> function parameter <code>f</code> needs to be defined for all possible types <code>T</code>. However, <code>fn2</code> can pick whatever type it wants for <code>T</code> and use <code>f</code> with it.<br />
In other words, there exists some type <code>T</code> that will be used but <code>f</code> has no way of knowing which. The name for it is <em>existential quantification</em>. Some languages even use the <code>exists</code> keyword to describe it.</p>
<p>The general concept of existentials is broader than what I am describing here and what TS supports. However, this by itself is plenty powerful.  </div></p>
<h3 id="preventing-information-escape">Preventing information escape</h3>
<p>I am drawing a blank trying to think about an OO analogy for this. It is somewhat related to friend classes in C++, package-private scope in Java … only not exactly.<br />
This example will accomplish more than the above ‘factory’ pattern and will not use any interfaces or classes:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="co">// Using higher rank to protect data</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a><span class="co">// Imaginary world without debuggers, JSON.stringify, etc</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>type Api <span class="op">=</span> {<span class="dt">getGoodies</span><span class="op">:</span> string[]}</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a><span class="co">//provides access to API, password needs to be protected</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a>declare <span class="kw">function</span> login<span class="op">&lt;</span>Password<span class="op">&gt;</span>(p<span class="op">:</span> Password)<span class="op">:</span> Api </span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true"></a><span class="co">//provide password to a computation, that computation should be able to use the password but shouldn't return it</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true"></a><span class="kw">const</span> secretive <span class="op">=</span> <span class="op">&lt;</span>R<span class="op">&gt;</span> (fn<span class="op">:</span> <span class="op">&lt;</span>Password<span class="op">&gt;</span> (p<span class="op">:</span> Password) <span class="kw">=&gt;</span> R)<span class="op">:</span> R  <span class="kw">=&gt;</span> {</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true"></a>   <span class="kw">const</span> <span class="dt">s</span> <span class="op">:</span> any <span class="op">=</span> <span class="st">&quot;topsecret&quot;</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true"></a>   <span class="cf">return</span> <span class="fu">fn</span> (s)</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true"></a>}</span></code></pre></div>
<p>The example is somewhat contrived with the main goal of illustrating the point.<br />
This code exposes building blocks that work together. To get the access to the <code>Api</code> type, you have to use <code>login</code> and you have to use it inside the provided <code>secretive</code> function. Working with an API like this is like assembling a jigsaw puzzle. Types prevent from jamming a square peg into a round hole.<br />
Note, <code>Password</code> is a type variable and we have used the existential type trick.</p>
<p>This code uses the building blocks:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="kw">const</span> goodProgram <span class="op">=</span> <span class="op">&lt;</span>Password<span class="op">&gt;</span>(p<span class="op">:</span> Password)<span class="op">:</span> string[] <span class="kw">=&gt;</span> {</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>    <span class="kw">const</span> api <span class="op">=</span> <span class="fu">login</span>(p)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>    <span class="cf">return</span> api<span class="op">.</span><span class="at">getGoodies</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a>}</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a><span class="kw">const</span> stealPassword <span class="op">=</span> <span class="op">&lt;</span>Password<span class="op">&gt;</span>(p<span class="op">:</span> Password)<span class="op">:</span> Password <span class="kw">=&gt;</span> p</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true"></a><span class="fu">secretive</span>(goodProgram)</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true"></a><span class="fu">secretive</span>(stealPassword)</span></code></pre></div>
<p>Unfortunately, <code>secretive(stealPassword)</code> compiles. Somewhat typical of TS, instead of providing robust type safety, the compiler infers <code>unknown</code> and accepts my questionable code. Hovering over <code>secretive</code> shows me this:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="co">//const secretive: &lt;string[]&gt;(fn: &lt;Password&gt;(p: Password) =&gt; string[]) =&gt; string[]</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a><span class="fu">secretive</span>(goodProgram)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a><span class="co">//const secretive: &lt;unknown&gt;(fn: &lt;Password&gt;(p: Password) =&gt; unknown) =&gt; unknown</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a><span class="fu">secretive</span>(stealPassword)</span></code></pre></div>
<p>That is why I have created the <code>verifyUnknown</code> safety in the previous section:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="kw">const</span> valid <span class="op">=</span> <span class="fu">verifyUnknown</span>(<span class="kw">false</span><span class="op">,</span> <span class="fu">secretive</span>(goodProgram)) <span class="co">//valid: string[]</span></span></code></pre></div>
<div class="sourceCode" id="cb18"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="co">//Argument of type 'false' is not assignable to parameter of type 'true'.ts(2345)</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a><span class="dt">const</span> invalid = <span class="fu">verifyUnknown</span>(<span class="kw">false</span>, <span class="fu">secretive</span>(stealPassword)) <span class="co">//does not compile!</span></span></code></pre></div>
<p>To make it a bit nicer we can package <code>verifyUnknown</code> and <code>secretive</code> into one function:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="kw">const</span> verySecretive <span class="op">=</span> <span class="op">&lt;</span>R<span class="op">&gt;</span> (_<span class="op">:</span> IsUnknown<span class="op">&lt;</span>R<span class="op">&gt;,</span> fn<span class="op">:</span> <span class="op">&lt;</span>Password<span class="op">&gt;</span> (p<span class="op">:</span> Password) <span class="kw">=&gt;</span> R)<span class="op">:</span> R  <span class="kw">=&gt;</span> {</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a>    <span class="kw">const</span> <span class="dt">s</span> <span class="op">:</span> any <span class="op">=</span> <span class="st">&quot;topsecret&quot;</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a>    <span class="cf">return</span> <span class="fu">fn</span> (s)</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a> }</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true"></a><span class="kw">const</span> valid <span class="op">=</span> <span class="fu">verySecretive</span>(<span class="kw">false</span><span class="op">,</span> goodProgram) <span class="co">//valid: string[]</span></span></code></pre></div>
<div class="sourceCode" id="cb20"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="dt">const</span> invalid = <span class="fu">verySecretive</span>(<span class="kw">false</span>, stealPassword) </span></code></pre></div>
<p>This creates some interesting safety. Obviously you could still do a lot of mischief if you wanted to. There is a need for some ‘gentlemen’s agreements’ to not use casting, <code>JSON.stringify</code>, to not use <code>true</code> in <code>verySecretive</code> etc. However, if you think about creating clear contract APIs, this approach could be very powerful.</p>
<p>Existentials are not exactly equivalent to OO. However, using existential types can often accomplish a lot of the same things and often in a cleaner way. Using existentials and disabling OO features like <code>unknown</code> feels a bit contrived, but IMO is still useful. It would be nice if TS provided a cleaner way to disable the use of <code>unknown</code>.<br />
I do not know how robust this type of coding is. I have not played enough with this approach in TS to give you a list of gotchas. In my very limited experience, this seems similar to the rest of TS, TS stops working if I start pushing harder.</p>
<p> <div class="side-note"><strong>Existentials and higher rank at large:</strong> These concepts have lead to some amazing programming.<br />
For example, existentials are related to dependent pairs (dependent sums) in depenently typed programming languages. Dependent typing provides some very strong types. One example could be lists with a type checked length. You want to be able to use such lists when processing runtime data that can have arbitrary size. That size ‘exists’ but cannot be known statically at the compile time. This is in essence an existential construction.</p>
<p>Another amazing example is an old (1993) code called <em>State Threads (ST)</em> (currently part of std base library in Haskell). It allows to use a local mutable state to define computations that have to be <em>referentially transparent</em> (I have discussed referential transparency in <a href="2021-12-24-ts-types-part2.html#referential-transparency" target="_blank">Part 2</a>). This is possible because the access to mutate the state cannot escape outside of these computations. ST API remains unchanged since it was created 30 year ago, you can’t improve on perfection!</p>
<p>I see higher rank types, mostly rank-2 being used a lot. Having ability to pass generic (polymorphic) functions around is very useful. In my non-TS projects, the problem of ‘separating interface from implementation’ is typically solved by defining an EDSL (Embedded Domain Specific Language) and an interpreter. Interpreters are polymorphic (generic in TS lingo). Rank-2 types have to be used to make them first class and pass them around.  </div></p>
<h2 id="safety-preventing-subtyping">Safety preventing subtyping</h2>
<p>Many TS users have observed the need for this. The term <em>exact type</em> is floating around, I believe <em>flow</em> introduced this name. I have seen solutions like this one being proposed:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="kw">function</span> exact<span class="op">&lt;</span>T<span class="op">&gt;</span>(item<span class="op">:</span>T)<span class="op">:</span> T {</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a>    <span class="cf">return</span> item</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a>}</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a>type Hello <span class="op">=</span> {<span class="dt">hello</span><span class="op">:</span> string}</span></code></pre></div>
<div class="sourceCode" id="cb22"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="co">//Argument of type '{ hello: string; since: number; }' is not assignable to parameter of type 'Hello'.</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a><span class="co">//  Object literal may only specify known properties, and 'since' does not exist in type 'Hello'.ts(2345)</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a>exact&lt;Hello&gt;({hello: <span class="st">&quot;world&quot;</span>, since:<span class="dv">2002</span>})</span></code></pre></div>
<p>This safety is fragile (and a TS design inconsistency IMO) as the following example shows:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="kw">const</span> helloSince <span class="op">=</span> {<span class="dt">hello</span><span class="op">:</span> <span class="st">&quot;world&quot;</span><span class="op">,</span> <span class="dt">since</span><span class="op">:</span><span class="dv">2002</span>}</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a>exact<span class="op">&lt;</span>Hello<span class="op">&gt;</span>(helloSince) <span class="co">//complies</span></span></code></pre></div>
<p>To create something more robust, here is a code that combines the above <code>unknown</code> verification idea with existentials:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a>type Same<span class="op">&lt;</span>P<span class="op">,</span>T<span class="op">&gt;</span> <span class="op">=</span> P <span class="kw">extends</span> T<span class="op">?</span> (T <span class="kw">extends</span> P<span class="op">?</span> <span class="kw">true</span><span class="op">:</span> <span class="kw">false</span>)<span class="op">:</span> <span class="kw">false</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a><span class="kw">const</span> verifySame <span class="op">=</span> <span class="op">&lt;</span>P<span class="op">&gt;</span> () <span class="kw">=&gt;</span> <span class="op">&lt;</span>T<span class="op">&gt;</span> (_<span class="op">:</span> Same<span class="op">&lt;</span>P<span class="op">,</span>T<span class="op">&gt;,</span> t<span class="op">:</span>T)<span class="op">:</span> T <span class="kw">=&gt;</span> t</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a>verifySame<span class="op">&lt;</span>Hello<span class="op">&gt;</span>()(<span class="kw">true</span><span class="op">,</span> {<span class="dt">hello</span><span class="op">:</span> <span class="st">&quot;world&quot;</span>}) <span class="co">//'true' indicates that type matches</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true"></a>verifySame<span class="op">&lt;</span>Hello<span class="op">&gt;</span>()(<span class="kw">false</span><span class="op">,</span> {<span class="dt">hello</span><span class="op">:</span> <span class="st">&quot;world&quot;</span><span class="op">,</span> <span class="dt">since</span> <span class="op">:</span> <span class="dv">2020</span>}) <span class="co">//'false' is needed to acknowledge types are different </span></span></code></pre></div>
<div class="sourceCode" id="cb25"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a><span class="co">//Argument of type 'true' is not assignable to parameter of type 'false'.ts(2345)</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a>verifySame&lt;Hello&gt;()(<span class="kw">true</span>, {hello: <span class="st">&quot;world&quot;</span>, since : <span class="dv">2020</span>})</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a>verifySame&lt;Hello&gt;()(<span class="kw">true</span>, helloSince)</span></code></pre></div>
<p>You may have noticed a case of typing euphoria here. I used rank-2 construction because it allows me to type annotate with only one type variable. This is nice but often not essential.</p>
<p>Here is an implementation of <code>safePush</code> that acts invariant, it does not use any existential tricks:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a><span class="co">//Note to get 'safePush' I ended up with casting, this is a quick and dirty example and can be done slightly better</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a><span class="co">// However, this cast could be an indication that we are changing how TS compiler works</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true"></a><span class="co">// Kinda makes sense, to overrule the compiler I may need to cast</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true"></a><span class="kw">const</span> safePush <span class="op">=</span> <span class="op">&lt;</span>P<span class="op">,</span> T<span class="op">&gt;</span> (_<span class="op">:</span> Same<span class="op">&lt;</span>P<span class="op">,</span>T<span class="op">&gt;,</span> ps<span class="op">:</span> P[]<span class="op">,</span> t<span class="op">:</span> T)<span class="op">:</span> number <span class="kw">=&gt;</span> ps<span class="op">.</span><span class="fu">push</span>(t <span class="im">as</span> any)</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true"></a></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true"></a><span class="kw">const</span> intlist<span class="op">:</span> number[] <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>]</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true"></a><span class="kw">const</span> unklist<span class="op">:</span> unknown[] <span class="op">=</span> intlist  <span class="co">//exploits array covariance</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true"></a>unklist<span class="op">.</span><span class="fu">push</span>(<span class="st">&quot;not a number&quot;</span>) <span class="co">//unsafe 'push' adds a 'string' to 'intlist'</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true"></a></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true"></a><span class="fu">safePush</span>(<span class="kw">true</span><span class="op">,</span> intlist<span class="op">,</span> <span class="dv">1</span>) <span class="co">//this is safe</span></span></code></pre></div>
<div class="sourceCode" id="cb27"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a><span class="fu">safePush</span>(<span class="kw">true</span>, unklist, <span class="dv">1</span>)    <span class="co">//this is risky and will not compile </span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true"></a><span class="fu">safePush</span>(<span class="kw">true</span>, unklist, <span class="st">&quot;not a number&quot;</span>) <span class="co">//this is risky (here wrong) and will not compile </span></span></code></pre></div>
<p>Note, to be even safer I would need to prevent <code>unknown</code> as well:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a><span class="kw">const</span> unkstr<span class="op">:</span> unknown <span class="op">=</span> <span class="st">&quot;not a number&quot;</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true"></a><span class="fu">safePush</span>(<span class="kw">true</span><span class="op">,</span> unklist<span class="op">,</span> unkstr)  <span class="co">//unfortunately compiles</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true"></a></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true"></a><span class="co">//An even safer version of 'Same'</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true"></a>type SameAndKnown<span class="op">&lt;</span>P<span class="op">,</span>T<span class="op">&gt;</span> <span class="op">=</span> P <span class="kw">extends</span> T<span class="op">?</span> (T <span class="kw">extends</span> P<span class="op">?</span> (unknown <span class="kw">extends</span> T<span class="op">?</span> <span class="kw">false</span><span class="op">:</span> <span class="kw">true</span>)<span class="op">:</span> <span class="kw">false</span>)<span class="op">:</span> <span class="kw">false</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true"></a></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true"></a><span class="kw">const</span> verySafePush <span class="op">=</span> <span class="op">&lt;</span>P<span class="op">,</span> T<span class="op">&gt;</span> (_<span class="op">:</span> SameAndKnown<span class="op">&lt;</span>P<span class="op">,</span>T<span class="op">&gt;,</span> ps<span class="op">:</span> P[]<span class="op">,</span> t<span class="op">:</span> T)<span class="op">:</span> number <span class="kw">=&gt;</span> ps<span class="op">.</span><span class="fu">push</span>(t <span class="im">as</span> any)</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true"></a></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true"></a><span class="fu">verySafePush</span>(<span class="kw">true</span><span class="op">,</span> intlist<span class="op">,</span> <span class="dv">1</span>)  <span class="co">//this is safe</span></span></code></pre></div>
<div class="sourceCode" id="cb29"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a><span class="fu">verySafePush</span>(<span class="kw">true</span>, unklist, unkstr) <span class="co">//this is risky and will not compile!</span></span></code></pre></div>
<p>We have discussed problems with the TS approach to variance in the <a href="2022-01-03-ts-types-part3.html#variance-problems" target="_blank">previous installment</a>. We have a DIY approach to fight back!</p>
<p>Side Note: The linked github repo has an existentially typed version of <code>safePush</code> (<code>safePush2</code>) that has just one top level type variable. That version is more cumbersome to use. TS ends up not working well with it.</p>
<p>Another fun exercise:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a><span class="kw">const</span> safeEq <span class="op">=</span> <span class="op">&lt;</span>P<span class="op">,</span> T<span class="op">&gt;</span> (_<span class="op">:</span> Same<span class="op">&lt;</span>P<span class="op">,</span>T<span class="op">&gt;,</span> a<span class="op">:</span> P<span class="op">,</span> b<span class="op">:</span> T)<span class="op">:</span> boolean <span class="kw">=&gt;</span> a <span class="op">===</span> (b <span class="im">as</span> unknown)</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true"></a></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true"></a><span class="fu">safeEq</span>(<span class="kw">true</span><span class="op">,</span> {<span class="dt">hello</span><span class="op">:</span> <span class="st">&quot;word&quot;</span>}<span class="op">,</span> {<span class="dt">hello</span><span class="op">:</span><span class="st">&quot;dolly&quot;</span>})</span></code></pre></div>
<div class="sourceCode" id="cb31"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true"></a><span class="fu">safeEq</span>(<span class="kw">true</span>, {hello: <span class="st">&quot;word&quot;</span>}, {hello:<span class="st">&quot;word&quot;</span>, since:<span class="dv">2022</span>}))</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true"></a><span class="fu">safeEq</span>(<span class="kw">true</span>, <span class="dv">1</span>, <span class="st">&quot;str&quot;</span>)</span></code></pre></div>
<p>We have discussed problems with TS approach to <code>===</code> narrowing in the <a href="2022-01-03-ts-types-part3.html#complexity-of-ts-types" target="_blank">previous installment</a>. Again, we have a DIY approach to fight back.</p>
<p>This section is related to a number of feature requests: <a href="https://github.com/microsoft/TypeScript/issues/12936" target="_blank">TypeScript issue 12936</a> and <a href="https://github.com/microsoft/TypeScript/issues/7481" target="_blank">TypeScript issue 7481</a>. Hopefully a future version of TS will provide a simpler way to achieve invariance and disable subtyping.</p>
<h2 id="phantom-types">Phantom types</h2>
<p>TypeScript is somewhat unique in supporting <em>Structural Types</em>. Types like <code>type Person = {firstNm: string, lastNm: string}</code> are structural. That means the name <code>Person</code> is only an alias, what defines the type is the RHS of the definition, not the LHS. Contrast this with an OO class definition in a language like Java. Two structurally identical classes are still considered different types (this is called <em>nominal typing</em>).</p>
<p>It is sometimes convenient to be able to define different types that share the same structure. <em>Phantom types</em> are a way to do that. We say <em>phantom</em> because these types have no impact on runtime values.</p>
<p>Somewhere around 2006, haskell wiki published a write-up about <a href="https://wiki.haskell.org/Phantom_type" target="_blank">phantom types</a>. The write-up was expanded in 2010 to include a form validation example. Since then all blogs (in any programming language) about phantoms show a validation example. I decided to be as unoriginal as everyone else. This will allow me to better focus on how it is done in TS.</p>
<p>My first attempt at phantom types in TS will fail. But this code should make the idea behind phantoms clear:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true"></a><span class="co">//Marker type</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true"></a>type Validated <span class="op">=</span> {<span class="dt">type</span><span class="op">:</span> <span class="st">&quot;validated&quot;</span>}</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true"></a></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true"></a><span class="co">//For simplicity this is just a string</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true"></a>type ValidationError <span class="op">=</span> string</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true"></a></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true"></a><span class="co">//Extra phantom type variable 'T' </span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true"></a>type Person<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">=</span> {<span class="dt">firstNm</span><span class="op">:</span> string<span class="op">,</span> <span class="dt">lastNm</span><span class="op">:</span> string}</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true"></a></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true"></a></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true"></a><span class="co">//Validate person in some way returning 'Validated' phantom marker</span></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true"></a>declare <span class="kw">function</span> validate<span class="op">&lt;</span>T<span class="op">&gt;</span>(p<span class="op">:</span> Person<span class="op">&lt;</span>T<span class="op">&gt;</span>)<span class="op">:</span>  ValidationError <span class="op">|</span> Person<span class="op">&lt;</span>Validated<span class="op">&gt;</span> </span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true"></a></span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true"></a><span class="co">//Function to be used only if phantom 'T' is the 'Validated' type </span></span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true"></a>declare <span class="kw">function</span> <span class="fu">doSomethingValidated</span>(p<span class="op">:</span> Person<span class="op">&lt;</span>Validated<span class="op">&gt;</span>)<span class="op">:</span> <span class="kw">void</span></span></code></pre></div>
<p>Again, these types are trying to create a jigsaw puzzle. One I can assemble in a specific way only.<br />
If the puzzle machinery works, I will have to call <code>validate</code> first to be able to use <code>doSomethingValidated</code>.</p>
<p>Only, this machinery does not work. The following code compiles:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true"></a><span class="kw">function</span> validatedOrNot<span class="op">&lt;</span>T<span class="op">&gt;</span>(p<span class="op">:</span> Person<span class="op">&lt;</span>T<span class="op">&gt;</span>)<span class="op">:</span> <span class="kw">void</span> {</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true"></a>    <span class="fu">doSomethingValidated</span>(p)</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true"></a>}</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true"></a></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true"></a>type ClearlyNotValidated <span class="op">=</span> {<span class="dt">type</span><span class="op">:</span> <span class="st">&quot;notvalidated&quot;</span>}</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true"></a></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true"></a><span class="kw">function</span> <span class="fu">notValidated</span> (p<span class="op">:</span> Person<span class="op">&lt;</span>ClearlyNotValidated<span class="op">&gt;</span>)<span class="op">:</span> <span class="kw">void</span> {</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true"></a>    <span class="fu">doSomethingValidated</span>(p)</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true"></a>}</span></code></pre></div>
<p>The fix is to provide a value level information about <code>T</code> in an optional property.<br />
This type definition replaces the one above:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a><span class="co">//Modified definition adds value level representation `phantom?: T` </span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true"></a>type Person<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">=</span> {<span class="dt">firstNm</span><span class="op">:</span> string<span class="op">,</span> <span class="dt">lastNm</span><span class="op">:</span> string<span class="op">,</span> phantom<span class="op">?:</span> T}  </span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true"></a></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true"></a><span class="co">//provide a way to create person that ignores the additional 'phantom' property:</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true"></a><span class="kw">const</span> createPerson <span class="op">:</span> <span class="op">&lt;</span>T<span class="op">&gt;</span>(fst<span class="op">:</span> string<span class="op">,</span> lst<span class="op">:</span> string) <span class="kw">=&gt;</span> Person<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">=</span> (fst<span class="op">,</span> lst) <span class="kw">=&gt;</span> {</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true"></a>    <span class="cf">return</span> {<span class="dt">firstNm</span><span class="op">:</span> fst<span class="op">,</span> <span class="dt">lastNm</span><span class="op">:</span> lst}</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true"></a>} </span></code></pre></div>
<p>Now this compiles:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true"></a><span class="kw">function</span> <span class="fu">validated</span>(p<span class="op">:</span> Person<span class="op">&lt;</span>Validated<span class="op">&gt;</span>)<span class="op">:</span> <span class="kw">void</span> {</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true"></a>    <span class="fu">doSomethingValidated</span>(p)</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true"></a>}</span></code></pre></div>
<p>But these no longer do:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true"></a><span class="co">// Compilation Error</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true"></a><span class="co">// Argument of type 'Person&lt;T&gt;' is not assignable to parameter of type 'Person&lt;Validated&gt;'.</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true"></a><span class="co">//   Type 'T' is not assignable to type 'Validated'.ts(2345)</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true"></a>function validatedOrNot&lt;T&gt;(p: Person&lt;T&gt;): <span class="dt">void</span>{</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true"></a>    <span class="fu">doSomethingValidated</span>(p)</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true"></a>}</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true"></a></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true"></a><span class="co">// Compilation Error</span></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true"></a><span class="co">// Argument of type 'Person&lt;ClearlyNotValidated&gt;' is not assignable to parameter of type 'Person&lt;Validated&gt;'.</span></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true"></a><span class="co">//   Type 'ClearlyNotValidated' is not assignable to type 'Validated'.</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true"></a><span class="co">//     Types of property 'type' are incompatible.</span></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true"></a><span class="co">//       Type '&quot;notvalidated&quot;' is not assignable to type '&quot;validated&quot;'.ts(2345)</span></span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true"></a>function <span class="fu">notValidated</span> (p: Person&lt;ClearlyNotValidated&gt;): <span class="dt">void</span> {</span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true"></a>    <span class="fu">doSomethingValidated</span>(p)</span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true"></a>}</span></code></pre></div>
<p>I believe phantom types are used by some FP libraries in TS, e.g. <em>fp-ts</em>, these libraries use somewhat different techniques to get phantoms. There may be advantages to doing phantom types differently than what I have presented. The above approach is the simplest I can think of.</p>
<p> <div class="side-note"><strong>Phantom types at large:</strong> Phantom types can be used to do a lot of crazy type level stuff. The most wild use I have seen is <a href="https://iohk.io/en/research/library/papers/ghosts-of-departed-proofsfunctional-pearls/" target="_blank">Ghosts of Departed Proofs</a> (this uses Haskell).<br />
Here is a simplified and easy to understand example in TS. Think about a non-mutable list, your function accepts a list and does something with it, your code needs the list to be sorted to work. You can encapsulate this and conservatively sort it just in case (this approach seems not performance optimal), you can document your function by saying that it is the caller responsibility to sort (do developers read documentation?), … or you can introduce a phantom type:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true"></a><span class="co">//Sort status as a phantom type,  'List' has type level information about its sort status.</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true"></a>type List<span class="op">&lt;</span>T<span class="op">,</span> SortStatus<span class="op">&gt;</span> <span class="op">=</span> <span class="op">...</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true"></a></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true"></a><span class="kw">interface</span> Comparator<span class="op">&lt;</span>T<span class="op">&gt;</span> {</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true"></a>    <span class="fu">compare</span> (<span class="dt">o1</span><span class="op">:</span> T<span class="op">,</span> <span class="dt">o2</span><span class="op">:</span> T)<span class="op">:</span> number</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true"></a>}</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true"></a></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true"></a>declare <span class="kw">function</span> sortAscending <span class="op">&lt;</span>T <span class="kw">extends</span> Comparator<span class="op">&lt;</span>T<span class="op">&gt;,</span> AnyStatus<span class="op">&gt;</span> (list<span class="op">:</span> List<span class="op">&lt;</span>T<span class="op">,</span> AnyStatus<span class="op">&gt;</span>)<span class="op">:</span>  List<span class="op">&lt;</span>T<span class="op">,</span> <span class="st">&quot;ascending&quot;</span><span class="op">&gt;</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true"></a></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true"></a>declare <span class="kw">function</span> doSomethingWithSortedList <span class="op">&lt;</span>T <span class="kw">extends</span> Comparator<span class="op">&lt;</span>T<span class="op">&gt;&gt;</span> (list<span class="op">:</span> List<span class="op">&lt;</span>T<span class="op">,</span> <span class="st">&quot;ascending&quot;</span><span class="op">&gt;</span>)<span class="op">:</span> <span class="kw">void</span></span></code></pre></div>
<p>Again, notice the types form pieces of a puzzle and can be fitted only in a specific way.<br />
You can think about a <code>sort</code> as something that not only does what it says, but also provides a <em>token</em> to use later to prove that the sort was done. This <em>token</em> is a phantom type. You can think about creating a library that helps orchestrate a similar approach to programming and this is what the linked article talks about.<br />
Many FP programming languages support GADTs, these are very powerful types and limit the popularity of (subsume) phantom typing.<br />
 </div></p>
<p>Phantom types could be a very powerful API building tool.<br />
I am sure you can think about many other interesting use cases, … like state machines.</p>
<h2 id="next-chapter">Next Chapter</h2>
<p>I want to talk about recursive types and type level programming. It will be more of a review of TS capabilities in these areas.</p>
<p>I need to take a break from writing posts. The next installment will take me longer, maybe a month or a little more, to finish.<br />
Thank you for reading. Happy New Year!</p>
<p>Here is the link: <a href="2022-02-13-ts-types-part5.html" target="_blank">Part 5</a>.</p>

    </section>
</article>
]]></summary>
</entry>
<entry>
    <title>Blog styling update</title>
    <link href="https://rpeszek.github.io//posts/2022-01-05-Styling.html" />
    <id>https://rpeszek.github.io//posts/2022-01-05-Styling.html</id>
    <published>2022-01-05T00:00:00Z</published>
    <updated>2022-01-05T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
    <section class="header">
        Posted on January  5, 2022
        
        
        
        
        <div class="info">Tags: <a title="All pages tagged 'announcement'." href="../tags/announcement.html">announcement</a></div>
        
    </section>
    <section>

    </section>
    <section>
        <p><em><a href="https://github.com/rpeszek/rpeszek.github.io/discussions/1" target="_blank">git discussions</a></em></p>
<p>This blog has used a vanilla Hakyll styling with slightly modified standard pandoc CSS for code blocks.<br />
Some of the readers have experienced very weird font size irregularities, making it hard to read my blog.</p>
<p>I did a full CSS reset using <a href="https://meyerweb.com/eric/tools/css/reset/reset.css" target="_blank">meyerweb reset.css</a> and have restyled all posts. <em>Sans-Serif</em> fonts are now a hard-coded default (before the <em>font-family</em> was not specified leaving it to the browser defaults to do whatever mischief they fancied).</p>
<p>Please let me know in git discussions if you still experience styling issues.</p>
<p>Thank you to everyone who alerted me about the styling problems.</p>
    </section>
</article>
]]></summary>
</entry>
<entry>
    <title>Type Enthusiast's Notes about TypeScript. Part 3. TS Complexity</title>
    <link href="https://rpeszek.github.io//posts/2022-01-03-ts-types-part3.html" />
    <id>https://rpeszek.github.io//posts/2022-01-03-ts-types-part3.html</id>
    <published>2022-01-03T00:00:00Z</published>
    <updated>2022-01-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
    <section class="header">
        Posted on January  3, 2022
        
            by Robert Peszek
        
        
        
        <div class="changelog"> <div>Revision History: <ul> <li> (2022.01.03 - Present) Changes are documented in <a href="#summary-of-final-edits">Summary of final edits</a>. </ul> </div></div>
        
        
        <div class="info">Tags: <a title="All pages tagged 'TypeScript-Notes'." href="../tags/TypeScript-Notes.html">TypeScript-Notes</a></div>
        
    </section>
    <section>

    </section>
    <section>
        <div class="toc"><div class="header">Table of Contents</div>
<ul>
<li><a href="#nutshell">Nutshell</a></li>
<li><a href="#interesting-safety">Interesting safety</a>
<ul>
<li><a href="#apple-orange-type-safety"><code>apple !== orange</code> type safety</a></li>
<li><a href="#switch-exhaustive-check"><code>switch</code> exhaustive check</a></li>
<li><a href="#null-undefined-safety"><code>null</code> / <code>undefined</code> safety</a></li>
</ul></li>
<li><a href="#complexity-of-ts-types">Complexity of TS types</a>
<ul>
<li><a href="#semantics-rejected-overlap"><code>===</code> semantics, rejected overlap</a></li>
<li><a href="#semantics-whats-an-overlap"><code>===</code> semantics, what’s an overlap?</a></li>
<li><a href="#hidden-blooper-side-note">Hidden blooper (side note)</a></li>
<li><a href="#diy-equality">DIY equality</a></li>
<li><a href="#subtyping">Subtyping</a></li>
<li><a href="#comparative-complexity-rant">Comparative complexity rant</a></li>
<li><a href="#variance-problems">Variance problems</a></li>
<li><a href="#summary">Summary</a></li>
</ul></li>
<li><a href="#next-chapter">Next Chapter</a></li>
<li><a href="#summary-of-final-edits">Summary of final edits</a></li>
</ul>
</div>
<p><em>Please Leave Feedback in: <a href="https://github.com/rpeszek/rpeszek.github.io/discussions/1" target="_blank">git discussions</a></em></p>
<p>Previous post: <a href="2021-12-24-ts-types-part2.html" target="_blank">Part 2. Typing Honestly</a>.</p>
<p><strong>DRAFT version</strong> <em>(I am sorry about any misprints. It seems I have goblins in my laptop that toy with me, remove or change words. When this note disappears, you will know that I gave up.)</em></p>
<p><strong>Disclaimers:</strong> (imagine this is a very small font, read it very fast in a half whisper)<br />
<em>I assume strict compiler flags are on, something you get by default with scaffolding, e.g. using <code>create-react-app my-project --template typescript</code> is close enough.<br />
The code examples have been tested with TypeScript v4.5.2.<br />
This post is a pandoc output of a markdown document and code examples are not interactive.<br />
Most of the code examples are published in <a href="https://github.com/rpeszek/ts-experiments/tree/master/ts-notes" target="_blank">ts-notes</a> folder in this github repo: <a href="https://github.com/rpeszek/ts-experiments" target="_blank">ts-experiments</a>.</em></p>
<p><strong>Motivating Quote for the series:</strong></p>
<blockquote>
<p>“TypeScript began its life as an attempt to bring traditional object-oriented types to JavaScript so that the programmers at Microsoft could bring traditional object-oriented programs to the web. As it has developed, TypeScript’s type system has evolved to model code written by native JavaScripters. The resulting system is <em>powerful, interesting and messy.</em>”</p>
</blockquote>
<p><em>From typescriptlang <a href="https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html" target="_blank">TypeScript for Functional Programmers</a></em></p>
<h2 id="nutshell">Nutshell</h2>
<p>Happy New Year! Let’s hope 2022 it will be way better than 2021. It has to be.</p>
<p>This is the third post in the series devoted to types in TypeScript. In this series, I explore type-centric approaches to writing code and push TS to its limits in doing so. I am writing these posts for like minded developers who are interested in types and either use or consider using TypeScript.</p>
<p>In this post we will see TS struggle. We will see compilation inconsistencies and surprising type checker behavior.<br />
My main goal is to point out the complexity of what TS is trying to accomplish and share my understanding of it.<br />
On a positive note, I will introduce additional tools for asking TS type questions.<br />
Also, I promise, the next installment will be about good things in TS. It will be about programming with type variables.</p>
<p>Before we discuss the messy bits, let’s briefly talk about some cool type safety features.</p>
<h2 id="interesting-safety">Interesting safety</h2>
<p>TypeScript implements special <a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html" target="_blank">narrowing</a> semantics when processing parts of JS code. These semantic rules provide very surprising and useful type safety features. TS can effectively narrow types used in a number of JS operators such as <code>typeof</code>, <code>===</code>, <code>==</code> and apply this information to <code>if-else</code>, <code>switch</code> statements. This post has already shown a few examples where this, almost magically, prevents placing code in a wrong branch of conditional if-else blocks.</p>
<p>Here are some of my favorites with IMO on their use.</p>
<h3 id="apple-orange-type-safety"><code>apple !== orange</code> type safety</h3>
<p>This JavaScript code (I keep reusing <code>type Person = {firstNm: string, lastNm: string}</code> from the first post):</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="co">//Bad code</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="kw">function</span> <span class="fu">blah</span>(lhs<span class="op">:</span> string<span class="op">,</span> rhs<span class="op">:</span> Person) {</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>  <span class="cf">if</span> (lhs <span class="op">===</span> rhs) {</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>    <span class="co">//Do something</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>  } <span class="cf">else</span> {</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>    <span class="co">//Do something else</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>  }</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>}</span></code></pre></div>
<p>is a programming bug and will not type-check in TypeScript. You can just replace it with:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="co">//Actual equivalent</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="kw">function</span> <span class="fu">blah</span>(lhs<span class="op">:</span> string<span class="op">,</span> rhs<span class="op">:</span> Person) {</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>  <span class="co">//Do something else</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>}</span></code></pre></div>
<p>TypeScript prevents from using <code>===</code> if it can guess<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>, by looking at the types, that <code>===</code> will always be <code>false</code>. This is true in general, not just inside <code>if-else</code>, but the <code>if-else</code> use is the killer app IMO.<br />
One cool example of <code>===</code> type safety combines type narrowing with literal types: <code>1 === 2</code> will not compile!</p>
<p>This is a big deal. <code>===</code> is often used to compare things like <code>string</code> or <code>number</code> <em>id</em>-s or <em>hashes</em> and it is not that uncommon to accidentally try to compare something like an <em>id</em> with something completely different.<br />
I have seen analogous issues in many programming languages including even <em>Scala</em>.</p>
<h3 id="switch-exhaustive-check"><code>switch</code> exhaustive check</h3>
<p><code>if-else</code> does not provide any mechanism for the type checker to verify that the program checked all possible conditions.<br />
Interestingly, we can use the <code>switch</code> statement in TS to solve this problem:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="co">//This compiles!</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a><span class="kw">const</span> contrived_better <span class="op">=</span> (n<span class="op">:</span> <span class="dv">1</span> <span class="op">|</span> <span class="dv">2</span>)<span class="op">:</span> number <span class="kw">=&gt;</span> {</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>    <span class="cf">switch</span>(n) {</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>       <span class="cf">case</span> <span class="dv">1</span><span class="op">:</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>       <span class="cf">case</span> <span class="dv">2</span><span class="op">:</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>        <span class="cf">return</span> <span class="dv">2</span> </span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>    } </span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="co">//Compilation error</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="co">//Function lacks ending return statement and return type does not include 'undefined'.ts(</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>export <span class="dt">const</span> contrived_better_ = (n: <span class="dv">1</span> | <span class="dv">2</span> | <span class="dv">3</span>): number =&gt; {</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>    <span class="kw">switch</span>(n) {</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>       <span class="kw">case</span> <span class="dv">1</span>:</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>        <span class="kw">return</span> n</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>       <span class="kw">case</span> <span class="dv">2</span>:</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>        <span class="kw">return</span> n </span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>    } </span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>}</span></code></pre></div>
<p>That is another nice example of TS enhancing JS with a nice type safety feature.</p>
<p>IMO an even better solution is provided by the <em>ts-pattern</em> library. See this blog post: <a href="https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k" target="_blank">Introducing ts-pattern v3.0</a></p>
<h3 id="null-undefined-safety"><code>null</code> / <code>undefined</code> safety</h3>
<p>We have seen <code>null</code> safety already. There is a semantic difference between <code>null</code> and <code>undefined</code> but most code does not care. My personal preference is to unify these two.</p>
<p>In my very first example in the series, <a href="2021-12-12-ts-types-part1.html#typescript-is-great" target="_blank"><code>getName(p: NullablePerson)</code></a>, was not <code>undefined</code> safe, only <code>null</code> safe. Using it with <code>undefined</code> (e.g. on expressions typed as <code>any</code>) will cause an error.</p>
<p>My coding preference would be to rewrite my first example like this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="co">//Reusable utility type</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="im">export</span> type Undefined <span class="op">=</span> <span class="kw">null</span> <span class="op">|</span> <span class="kw">undefined</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a><span class="im">export</span> <span class="kw">const</span> isUndefined <span class="op">=</span> (d<span class="op">:</span> unknown)<span class="op">:</span> d is Undefined <span class="kw">=&gt;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>   (d <span class="op">===</span> <span class="kw">null</span>) <span class="op">||</span> (d <span class="op">===</span> <span class="kw">undefined</span>) <span class="co">//I prefer not to use '=='</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a><span class="kw">const</span> getName2 <span class="op">=</span> (p<span class="op">:</span>Person <span class="op">|</span> Undefined)<span class="op">:</span> string <span class="kw">=&gt;</span> {</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>    <span class="co">//const tst1 = p.firstNm //will not compile</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>    <span class="cf">if</span>(<span class="fu">isUndefined</span>(p)){</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a>        <span class="co">//const tst2 = p.firstNm //will not compile</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a>        <span class="cf">return</span> <span class="st">&quot;John Smith&quot;</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a>    } <span class="cf">else</span> {</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true"></a>        <span class="cf">return</span> p<span class="op">.</span><span class="at">firstNm</span> <span class="op">+</span> <span class="st">&quot; &quot;</span> <span class="op">+</span> p<span class="op">.</span><span class="at">lastNm</span> <span class="co">//compiles</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true"></a>    }</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true"></a>}</span></code></pre></div>
<p>This is just my personal preference, I also use this approach when typing optional <code>?</code> object properties. E.g.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>type Person2 <span class="op">=</span> {<span class="dt">firstNm</span><span class="op">:</span> string<span class="op">;</span> middleNm<span class="op">?:</span> string <span class="op">|</span> Undefined<span class="op">;</span> <span class="dt">lastNm</span><span class="op">:</span> string}</span></code></pre></div>
<p>The extra safety features are what surprised and excited me about TS. They reminded me of a functional programming language.</p>
<h2 id="complexity-of-ts-types">Complexity of TS types</h2>
<p>Throughout the series, we encountered a few examples where the TS type checker did not work as expected, we will encounter more of TS quirkiness in this section. This note suggests a reason for this: type complexity.</p>
<p>My original plan was to write about TS needing to implement a separate ad-hoc semantics for various JS operators. I was not able to present anything very insightful and I have abandoned that idea, e.g. these <a href="2021-12-12-ts-types-part1.html#type-holes" target="_blank">type hole</a> expressions do not even compile:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="co">//Compiliation errors: Object is of type 'unknown'</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="fu">_</span>() + <span class="fu">_</span>()</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a><span class="fu">_</span>() * <span class="fu">_</span>()</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a><span class="fu">_</span>() / <span class="fu">_</span>()</span></code></pre></div>
<p>Taking the quote from the top of this post to heart, I concluded that TS is about providing support for OO and other idiomatic uses of JS. I decided to narrow the focus of this note to subtyping and the <code>===</code> operator semantics.</p>
<h3 id="semantics-rejected-overlap"><code>===</code> semantics, rejected overlap</h3>
<p>I have picked <code>===</code> because we discussed it already in my previous note about the <a href="2021-12-24-ts-types-part2.html#note-about-the-unknown-type" target="_blank"><code>unknown</code> type</a>. Selecting <code>==</code> would produce a very similar presentation.</p>
<p>Here is an example of safety around the <code>===</code> operator:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="co">//This condition will always return 'false' since the types '&quot;world!&quot;' and '&quot;Dolly!&quot;' have no overlap.ts(2367)</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="st">&quot;world!&quot;</span> === <span class="st">&quot;Dolly!&quot;</span> <span class="co">//does not compile</span></span></code></pre></div>
<p>Let’s try to figure out the semantic rules around <code>===</code>. What does “not having an overlap” mean?<br />
I have not seen a formal (or even a somewhat precise) definition of the semantic rules for the <code>===</code>.<br />
(Please comment in git discussions if you know about any place that defines these.)<br />
The informal definition (from typescriptlang documentation) points to a “common type that both <code>x</code> and <code>y</code> could take on” but this statement clearly has some loose ends.</p>
<p>The first part of the error message “This condition will always return ‘false’” suggests a way to start:</p>
<p><strong>(EQ-SAFETY attempt 1):</strong> <em>TypeScript prevents using <code>===</code> if it can prove, by looking at the types, that the result of <code>===</code> would always be <code>false</code>.</em></p>
<p>This is a very high level and does not explain how TS does it. But is this even true?</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>function <span class="fu">testEqSemantics</span>(a: {bye: string}, b: {hello: string): <span class="dt">boolean</span> {</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>   <span class="co">//This condition will always return 'false' since the types '{ bye: string; }' and '{ hello: string; }' have no overlap.</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>   <span class="kw">return</span> a === b <span class="co">//does not compile</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>}</span></code></pre></div>
<p>Let me temporarily comment the not compiling code:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="kw">function</span> <span class="fu">testEqSemantics</span>(a<span class="op">:</span> {<span class="dt">bye</span><span class="op">:</span> string}<span class="op">,</span> b<span class="op">:</span> {<span class="dt">hello</span><span class="op">:</span> string})<span class="op">:</span> boolean {</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>   <span class="co">//This condition will always return 'false' since the types '{ bye: string; }' and '{ hello: string; }' have no overlap.</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>   <span class="co">//return a === b</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>   <span class="cf">return</span> <span class="kw">true</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>}</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a><span class="kw">const</span> helloBye <span class="op">=</span> {<span class="dt">bye</span><span class="op">:</span><span class="st">&quot;world!&quot;</span><span class="op">,</span> <span class="dt">hello</span><span class="op">:</span><span class="st">&quot;world!&quot;</span>}</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a><span class="fu">testEqSemantics</span>(helloBye<span class="op">,</span> helloBye)  <span class="co">//compiles, here is the overlap!</span></span></code></pre></div>
<p>TS has effectively prevented me from using <code>===</code> even though there are legitimate cases where the <code>===</code> would have returned <code>true</code>! This seems like a major blooper.</p>
<p><strong><em>We have falsified the error message from TS.</em></strong></p>
<p>OO is complex and type design issues are not uncommon among OO languages, this could be one of them.<br />
On the other hand, preventing <code>{bye: "world!"} === {hello: "world!"}</code> from compiling seems useful from a pragmatic point of view. It is possible that this behavior is intentional.</p>
<p>I see 2 possible conclusions</p>
<ol type="1">
<li>This is a bug caused by a complexity of TS’s semantic rules</li>
<li>This is a feature indicating that the rules are indeed complex</li>
</ol>
<p>This appears to be one of the “Working as Intended” or at least known issues (see <a href="#fn4">footnote 4</a>).</p>
<h3 id="semantics-whats-an-overlap"><code>===</code> semantics, what’s an overlap?</h3>
<p>Let’s focus on this part of the error message: “types … and … have no overlap”.</p>
<p><strong>(EQ-SAFETY attempt 2):</strong> <em><code>x === y</code> compiles if <code>x: X</code> and <code>y: Y</code> and the compiler successfully computes some special non-<code>never</code> <code>Overlap</code> type that widens to both <code>X</code> and <code>Y</code></em></p>
<p><code>X</code> is the computed type for <code>x</code>, <code>Y</code> is the computed type for <code>y</code>, how do we compute <code>Overlap</code> type for both? I think we can assume that <em>widens</em> simply means <code>extends</code>.<br />
The 64K dollar question is how is the <code>Overlap</code> computed? It is clearly not the same as intersection (the type operator <code>&amp;</code>), we have falsified that hypothesis in the previous section. Let’s try to look at some patterns:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="kw">const</span> helloDolly<span class="op">:</span> {<span class="dt">hello</span><span class="op">:</span> string} <span class="op">=</span> {<span class="dt">hello</span><span class="op">:</span> <span class="st">&quot;Dolly!&quot;</span>}</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a><span class="kw">const</span> datedHello<span class="op">:</span> {<span class="dt">hello</span><span class="op">:</span> string<span class="op">,</span> <span class="dt">since</span><span class="op">:</span> number} <span class="op">=</span> {<span class="dt">hello</span><span class="op">:</span> <span class="st">&quot;world!&quot;</span><span class="op">,</span> <span class="dt">since</span><span class="op">:</span><span class="dv">2022</span>}</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a><span class="kw">const</span> one <span class="op">=</span> <span class="dv">1</span> <span class="co">//const one: 1</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a><span class="kw">const</span> two <span class="op">=</span> <span class="dv">2</span> <span class="co">//const two: 2</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a><span class="kw">const</span> onenum<span class="op">:</span> number  <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a><span class="kw">const</span> twonum<span class="op">:</span> number  <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a><span class="kw">const</span> world<span class="op">:</span> string <span class="op">=</span> <span class="st">&quot;world&quot;</span></span></code></pre></div>
<div class="sourceCode" id="cb12"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="co">//fails, different literal types do not overlap</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a><span class="st">&quot;Dolly!&quot;</span> ===  <span class="st">&quot;world!&quot;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a><span class="co">//fails, different literal types do not overlap</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>one === two</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a><span class="co">//fails, string and number do not overlap</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a>one === world</span></code></pre></div>
<div class="sourceCode" id="cb13"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="co">//compilies, note both have the same type</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>onenum <span class="op">===</span> twonum</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a><span class="co">//compiles, note 'typeof datedHello' extends 'typeof helloDolly' </span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>helloDolly <span class="op">===</span> datedHello</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a><span class="co">//compiles, the overlap seems to be the 'Person' type</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a><span class="kw">function</span> <span class="fu">tst</span> (x<span class="op">:</span> number <span class="op">|</span> Person<span class="op">,</span> y<span class="op">:</span> string <span class="op">|</span> Person) {</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a>    <span class="cf">return</span> x <span class="op">===</span> y</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a>}</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true"></a><span class="co">//compiles, the overlap seems to be `{hello: string, since: number}` </span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true"></a><span class="kw">function</span> <span class="fu">testEqSemantics2</span>(a<span class="op">:</span> {<span class="dt">hello</span><span class="op">:</span> string} <span class="op">|</span> <span class="dv">1</span><span class="op">,</span> b<span class="op">:</span> <span class="st">&quot;boo&quot;</span> <span class="op">|</span> {<span class="dt">hello</span><span class="op">:</span> string<span class="op">,</span> <span class="dt">since</span><span class="op">:</span> number})<span class="op">:</span> boolean {</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true"></a>    <span class="cf">return</span> a <span class="op">===</span> b</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true"></a>}</span></code></pre></div>
<p>A possible rule for calculating <code>Overlap</code> could be (this is just a rough, high level heuristics, <em>please comment if you know a better definition</em>):</p>
<ul>
<li>for intersection types <code>X</code> and <code>Y</code>, if <code>X extends Y</code> take <code>X</code> else if <code>Y extends X</code> take <code>Y</code> otherwise reject</li>
<li>for union types <code>X = X1 | X2 | ...</code> and <code>Y = Y1 | Y2 | ...</code> recursively check if any <code>Xi</code> and <code>Yj</code> overlaps (this heuristics ignores performance cost)</li>
<li>for complex combinations of union and intersection types? I DUNNO, I have not tested it enough.</li>
</ul>
<p>I have not played with this assumption for a very long time, but so far these rules seem to hold with these exceptions:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="co">//All compile</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a><span class="dv">1</span> <span class="op">===</span> <span class="kw">null</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a><span class="dv">1</span> <span class="op">===</span> <span class="kw">undefined</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a><span class="kw">function</span> <span class="fu">tst2</span> (x<span class="op">:</span> <span class="dv">1</span><span class="op">,</span> y<span class="op">:</span> <span class="kw">null</span>) {</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a>    <span class="cf">return</span> x <span class="op">===</span> y</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true"></a>}</span></code></pre></div>
<p>Does <code>1</code> have an overlap with <code>null</code> and <code>undefined</code>? What does that even mean? With the <em>strictNullChecks</em> compiler flag, <code>null</code> should be well separated from other types.<br />
This particular quirkiness is actually useful, it allows for a program to do conservative null checks even if the type indicates that it is not needed.</p>
<p>I hope you agree. This is complicated.<br />
I will hopefully bring this point even closer to home by the end of this post.</p>
<h3 id="hidden-blooper-side-note">Hidden blooper (side note)</h3>
<p>If you remove type annotations from the above definitions, the <code>helloDolly === datedHello</code> still compiles:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="kw">const</span> helloDolly <span class="op">=</span> {<span class="dt">hello</span><span class="op">:</span> <span class="st">&quot;Dolly!&quot;</span>}</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a><span class="kw">const</span> datedHello <span class="op">=</span> {<span class="dt">hello</span><span class="op">:</span> <span class="st">&quot;world!&quot;</span><span class="op">,</span> <span class="dt">since</span><span class="op">:</span><span class="dv">2022</span>}</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a>helloDolly <span class="op">===</span> datedHello <span class="co">//still compiles</span></span></code></pre></div>
<p>From a pragmatic standpoint this is very strange. <code>"Dolly!" ===  "world!"</code> is statically rejected, but <code>{hello: "Dolly!"} === {hello: "world!", since:"2022"}</code> is not.</p>
<p>This surprising situation is caused by the type inference widening the types. The types inferred in the expression <code>"world!" === "Dolly!"</code> are the literal types <code>"world!": "world!"</code> and <code>"Dolly!": "Dolly!"</code>, while the <code>helloDolly</code> and <code>datedHello</code> infer a <code>string</code> and <code>number</code> for their properties:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="co">//IntelliSense view of helloDolly</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a><span class="kw">const</span> helloDolly<span class="op">:</span> {</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>    <span class="dt">hello</span><span class="op">:</span> string<span class="op">;</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>}</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a><span class="co">//IntelliSense view of datedHello</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a><span class="kw">const</span> datedHello<span class="op">:</span> {</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true"></a>    <span class="dt">hello</span><span class="op">:</span> string<span class="op">;</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true"></a>    <span class="dt">since</span><span class="op">:</span> number<span class="op">;</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true"></a>}</span></code></pre></div>
<p>TS allows to define the above object types using <code>as const</code>, e.g. <code>const helloDolly = {hello: "Dolly!"} as const</code> and <code>const datedHello = {hello: "world!", since:2022} as const</code>. It this is done <code>helloDolly === datedHello</code> will no longer compile but IMO, widening object property types is an arbitrary complexity.</p>
<h3 id="diy-equality">DIY equality</h3>
<p>The question is how far can I get by trying to reproduce safety around the <code>===</code> on my own.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>declare <span class="kw">function</span> eq<span class="op">&lt;</span>T<span class="op">&gt;</span>(t1<span class="op">:</span> T<span class="op">,</span> t2<span class="op">:</span> T)<span class="op">:</span> boolean</span></code></pre></div>
<p>This generic function (it could be implemented by simply using <code>===</code>) forces both arguments to have the same type. That should give me at least some level of extra safety and prevent from comparing apples and oranges.<br />
Let’s see, starting with these type holes:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="co">//type holes shows a string, not bad, I would prefer the literal &quot;foo&quot;.</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a><span class="fu">eq</span>(<span class="st">&quot;foo&quot;</span><span class="op">,</span> <span class="fu">_</span>())</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a><span class="co">//type holes shows unknown, Another unexpected 'uknown' widening issue? </span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a><span class="fu">eq</span>(<span class="fu">_</span>()<span class="op">,</span> <span class="st">&quot;foo&quot;</span>)</span></code></pre></div>
<p>Let’s ignore the second type hole disappointing quirkiness and move on.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="co">//These all compile</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a><span class="fu">eq</span>(<span class="dv">1</span> <span class="im">as</span> <span class="dv">1</span><span class="op">,</span> <span class="kw">null</span>)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a><span class="fu">eq</span>(<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span>)              <span class="co">//</span><span class="al">NOTE</span><span class="co"> we lost the type safety of ===</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a><span class="fu">eq</span>(<span class="dv">1</span> <span class="im">as</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span> <span class="im">as</span> <span class="dv">2</span>)    <span class="co">//</span><span class="al">NOTE</span><span class="co"> we lost the type safety of ===</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a><span class="fu">eq</span>({<span class="dt">bye</span><span class="op">:</span> <span class="st">&quot;world&quot;</span>}<span class="op">,</span> {<span class="dt">hello</span><span class="op">:</span> <span class="st">&quot;world&quot;</span>})  <span class="co">//</span><span class="al">NOTE</span><span class="co"> we lost the (possibly erroneous) type safety preventing {bye: &quot;world&quot;} === {hello: &quot;world&quot;}</span></span></code></pre></div>
<p>How come these compile? These are all different types but TS can unify them into a supertype (next section will discuss it). These are all legitimate statements. Unfortunately, the type safety has been lost. This explains why the semantic narrowing around the <code>===</code> operator is needed. It is needed because structural subtyping can unify types even if types are very different.</p>
<p>However, quirkiness alert, these do not compile:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="co">//Argument of type '&quot;boo&quot;' is not assignable to parameter of type '1'.ts(2345)</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a><span class="fu">eq</span>(<span class="dv">1</span>, <span class="st">&quot;boo&quot;</span>)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a><span class="co">//Argument of type '1' is not assignable to parameter of type '&quot;boo&quot;'.ts(2345)</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a><span class="fu">eq</span>(<span class="st">&quot;boo&quot;</span>, <span class="dv">1</span>)</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a><span class="co">//Argument of type '{ hello: string; }' is not assignable to parameter of type '1'.ts(2345)</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true"></a><span class="fu">eq</span>(<span class="dv">1</span>, {hello: <span class="st">&quot;world&quot;</span>})</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true"></a><span class="co">//Argument of type '{ hello: string; }' is not assignable to parameter of type '&quot;boo&quot;'.ts(2345)</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true"></a><span class="fu">eq</span>(<span class="st">&quot;boo&quot;</span>, {hello: <span class="st">&quot;world&quot;</span>})</span></code></pre></div>
<p><em>This is very unfortunate</em>, you want generic functions to work <em>consistently</em> across types. IMO this is a bug or an arbitrary complexity.<br />
The quirkiness seems to be related to the type inference working inconsistently and failing to widen the types if a string literal type is involved (next section will discussed it).</p>
<p>The narrative has run away from me, but the point should be somewhat clear: Generics provide only limited type safety in TS.<br />
E.g. enhanced safety semantics around <code>===</code> does not transfer to a DIY safety that a library solution could expose.</p>
<h3 id="subtyping">Subtyping</h3>
<p>How come this compiles?</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="fu">eq</span>(<span class="dv">1</span> <span class="im">as</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span> <span class="im">as</span> <span class="dv">2</span>) </span></code></pre></div>
<p>The type checker widens the types of both arguments to <code>1 | 2</code>. This is because of a subtyping rule that says that <code>1 extends (1 | 2)</code> and <code>2 extends (1 | 2)</code>.<br />
Here is a somewhat clever trick to see that:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="im">export</span> declare <span class="kw">function</span> unify<span class="op">&lt;</span>T<span class="op">&gt;</span>(t1<span class="op">:</span> T<span class="op">,</span> t2<span class="op">:</span> T) <span class="op">:</span> T</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a><span class="co">//hovering over unify shows me:</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a><span class="co">//(alias) unify&lt;1 | 2&gt;(t1: 1 | 2, t2: 1 | 2): 1 | 2</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a><span class="fu">unify</span>(<span class="dv">1</span> <span class="im">as</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span> <span class="im">as</span> <span class="dv">2</span>)</span></code></pre></div>
<p>if you do not believe me that <code>1 extends (1 | 2)</code> you can check it for yourself with another trick:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="im">export</span> <span class="kw">function</span> verifyExtends<span class="op">&lt;</span>T2 <span class="kw">extends</span> T1<span class="op">,</span> T1<span class="op">&gt;</span>() {}</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a>verifyExtends<span class="op">&lt;</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span> <span class="op">|</span> <span class="dv">2</span><span class="op">&gt;</span>()</span></code></pre></div>
<p>However, TS appears to be not consistently good about inferring these subtyping rules. TS apparently did not notice that <code>1 extends (1 | "boo")</code> and <code>"boo" extends (1 | "boo")</code>. Hence the blooper</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a>verifyExtends<span class="op">&lt;</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span> <span class="op">|</span> <span class="st">&quot;boo&quot;</span><span class="op">&gt;</span>()</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a>verifyExtends<span class="op">&lt;</span><span class="st">&quot;boo&quot;</span><span class="op">,</span> <span class="dv">1</span> <span class="op">|</span> <span class="st">&quot;boo&quot;</span><span class="op">&gt;</span>()</span></code></pre></div>
<div class="sourceCode" id="cb25"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a><span class="co">//Argument of type '&quot;boo&quot;' is not assignable to parameter of type '1'.ts(2345)</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a><span class="fu">eq</span>(<span class="dv">1</span>, <span class="st">&quot;boo&quot;</span>)</span></code></pre></div>
<p>Let’s try to force TS into compliance by type annotating everything:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a><span class="kw">const</span> booone <span class="op">:</span> <span class="dv">1</span> <span class="op">|</span> <span class="st">&quot;boo&quot;</span> <span class="op">=</span> <span class="st">&quot;boo&quot;</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a><span class="kw">const</span> oneboo <span class="op">:</span> <span class="dv">1</span> <span class="op">|</span> <span class="st">&quot;boo&quot;</span> <span class="op">=</span> <span class="dv">1</span></span></code></pre></div>
<div class="sourceCode" id="cb27"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a><span class="co">//Argument of type '1' is not assignable to parameter of type '&quot;boo&quot;'.ts(2345)</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true"></a><span class="fu">eq</span>(booone, oneboo) </span></code></pre></div>
<div class="sourceCode" id="cb28"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a><span class="co">//finally compiles with type application on 'eq'</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true"></a>eq<span class="op">&lt;</span>(<span class="dv">1</span> <span class="op">|</span> <span class="st">&quot;boo&quot;</span>)<span class="op">&gt;</span>(booone<span class="op">,</span> oneboo)</span></code></pre></div>
<p>We have seen that <code>===</code> narrowing is partially consistent with the intersection (<code>&amp;</code> operator).<br />
Let’s look at <code>&amp;</code> semantics a little closer.</p>
<p>We can try to double check how the <code>&amp;</code> intersection works by doing this:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a><span class="co">//both compile suggesting that Person is equivalent to the intersection  (number | Person) &amp; (string | Person)</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true"></a>verifyExtends<span class="op">&lt;</span>Person<span class="op">,</span> (number <span class="op">|</span> Person) <span class="op">&amp;</span> (string <span class="op">|</span> Person)<span class="op">&gt;</span>()</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true"></a>verifyExtends<span class="op">&lt;</span>(number <span class="op">|</span> Person) <span class="op">&amp;</span> (string <span class="op">|</span> Person)<span class="op">,</span> Person<span class="op">&gt;</span>()</span></code></pre></div>
<p>However this does not compile, and it does look like a bug (see second line of the error message):</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a><span class="co">//Type '(1 | &quot;boo&quot;) &amp; (&quot;boo&quot; | Person)' does not satisfy the constraint '&quot;boo&quot;'.</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true"></a><span class="co">//  Type '1 &amp; Person' is not assignable to type '&quot;boo&quot;'.ts(2344)</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true"></a>verifyExtends&lt;(<span class="dv">1</span> | <span class="st">&quot;boo&quot;</span>) &amp; (<span class="st">&quot;boo&quot;</span> | Person), <span class="st">&quot;boo&quot;</span>&gt;()</span></code></pre></div>
<p><em>Complexity is a super food for bugs.</em></p>
<p>Here is my quick summary: subtyping is complex and it weakens type safety. TS tries to recover the safety by building complex narrowing semantics around a selected set of JS operators. There are many inconsistencies in both the implementation of subtyping and the implementation of narrowing semantics.</p>
<p> <div class="side-note"><strong>Side Note about Arity</strong>: In TypeScript, functions are also subject to subtyping rules.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true"></a>verifyExtends<span class="op">&lt;</span>() <span class="kw">=&gt;</span> number<span class="op">,</span> (_<span class="op">:</span>string) <span class="kw">=&gt;</span> number<span class="op">&gt;</span>()</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true"></a>verifyExtends<span class="op">&lt;</span>(_<span class="op">:</span>string) <span class="kw">=&gt;</span> number<span class="op">,</span> (_1<span class="op">:</span>string<span class="op">,</span>_2<span class="op">:</span>boolean) <span class="kw">=&gt;</span> number<span class="op">&gt;</span>()<span class="op">&gt;</span></span></code></pre></div>
<p>see also <a href="https://github.com/Microsoft/TypeScript/wiki/FAQ#why-are-functions-with-fewer-parameters-assignable-to-functions-that-take-more-parameters" target="_blank">functions with fewer parameters are assignable to functions that take more parameters</a>. This is convenient, it can safe a few characters when writing programs.<br />
It is also, IMO, dangerous and complex. We have seen this leading to surprising behavior in <a href="2021-12-12-ts-types-part1.html#compilation-bloopers" target="_blank">Part 1, Compilation bloopers</a> section.  </div></p>
<h3 id="comparative-complexity-rant">Comparative complexity rant</h3>
<p>A “type enthusiast” will associate types with correctness, even formal verification. To me, the words “messy” and “type” are self contradictory. TS “types” support some interesting features but are a mess.</p>
<p>I want to contrast the above <code>===</code> and <code>eq</code> examples against a programming language that has been designed around types from the beginning. An example could be an FP language like Elm, PureScript, or Haskell (I am not that familiar with ReasonML or OCaml)<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.<br />
These languages have much simpler types. The safety around equality does not require any special narrowing semantics. You get it for free in any DIY function that has 2 arguments sharing the same generic type (only they call it polymorphic not generic).</p>
<p>One underlying reason for this is the lack of complex subtyping and OO features. <code>eq(x,y)</code> will not compile if <code>x</code> and <code>y</code> have different types. There is no way to unify <code>x</code> and <code>y</code> to some supertype because there are no subtypes or supertypes.<br />
But, you may say, JS object polymorphism is very useful. All the 3 languages listed above provide support for polymorphic record types<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>, only they use much simpler techniques than subtyping to achieve it.<br />
These languages also come with well thought out semantic rules that are often formalized and come with soundness proofs.<br />
The types in these languages are much simpler (not necessarily easier but simpler).</p>
<p>Type complexity translates to a confused type checker and to a confused developer.<br />
<em>Programming in a language in which I do not fully understand the types equates to me writing programs I do not fully understand.</em></p>
<p>I expect that to become a seasoned TS developer, one needs to remember a big dictionary of idiosyncratic compiler behaviors. <a href="https://github.com/Microsoft/TypeScript/wiki/FAQ#common-bugs-that-arent-bugs" target="_blank">Common Bugs that aren’t bugs</a> is, I think, just a warm up reading to achieve such mastery.<br />
Were you surprised about the gotchas we have uncovered in <a href="2021-12-12-ts-types-part1.html" target="_blank">Part 1</a>? Is the above <a href="#semantics-rejected-overlap">overlap issue</a> a well known problem<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>? Call me weird, but I would rather be learning PLT or Type Theory than these gotchas.</p>
<p>It is worth noting that TypeScript has over a million users. FP languages have tens of thousands of users (if combined). TypeScript has more resources to improve. What makes for fewer bugs, lots of dollars or clean types?<br />
I do not think there is a clear answer to this question. However, resources can’t solve all the problems. Programming languages are almost paranoid about backward compatibility and backward compatibility does not like changing things, even if the change is fixing bugs.<br />
So I am afraid, a simple language like Elm will always be cleaner and more robust.</p>
<p>Forgetting about the popularity context, I view it as a trade-off: suffer because of the type complexity and reduced type safety but see a readable JavaScript and trivially integrate with the rest of JS ecosystem <em>vs</em> introduce a language that has nicer types, greater type safety, predictable compiler, but lose generated JS code clarity and suffer when integrating JS libraries.<br />
This trade-off is IMO not trivial and very project dependent. Clean types vs clean JS, I typically select the clean types. The ecosystem compatibility issue is a little harder to ignore and the main reason I am writing code in TS. Projects with a high correctness requirement, IMO, should select an FP language, the optimal choice for other projects is less clear.</p>
<h3 id="variance-problems">Variance problems</h3>
<p>I will finish with some examples that may feel even more surprising.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true"></a><span class="kw">const</span> bye <span class="op">=</span> {<span class="dt">bye</span><span class="op">:</span> <span class="st">&quot;world&quot;</span>}</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true"></a><span class="kw">const</span> hello <span class="op">=</span> {<span class="dt">hello</span><span class="op">:</span> <span class="st">&quot;world&quot;</span>}</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true"></a></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true"></a>declare <span class="kw">function</span> eqArrays<span class="op">&lt;</span>T<span class="op">&gt;</span>(t1<span class="op">:</span> T[]<span class="op">,</span> t2<span class="op">:</span> T[])<span class="op">:</span> boolean</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true"></a></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true"></a><span class="fu">eqArrays</span>([{<span class="dt">bye</span><span class="op">:</span> <span class="st">&quot;world&quot;</span>}]<span class="op">,</span> [{<span class="dt">hello</span><span class="op">:</span> <span class="st">&quot;world&quot;</span>}]) <span class="co">//compiles</span></span></code></pre></div>
<div class="sourceCode" id="cb33"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true"></a><span class="co">//Compilation error</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true"></a><span class="co">//Property 'bye' is missing in type '{ hello: string; }' but required in type '{ bye: string; }'.ts(2741)</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true"></a><span class="fu">eqArrays</span>([bye], [hello])</span></code></pre></div>
<p>Here is another example:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a><span class="kw">interface</span> Payload<span class="op">&lt;</span>T<span class="op">&gt;</span> {<span class="dt">payload</span><span class="op">:</span> T}</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true"></a></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true"></a><span class="co">// ... we would see the same behavior for:</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true"></a><span class="co">//type Payload1&lt;T&gt; = {payload: T} </span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true"></a></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true"></a>declare <span class="kw">function</span> eqPayloads<span class="op">&lt;</span>T<span class="op">&gt;</span>(t1<span class="op">:</span> Payload<span class="op">&lt;</span>T<span class="op">&gt;,</span> t2<span class="op">:</span> Payload<span class="op">&lt;</span>T<span class="op">&gt;</span>)<span class="op">:</span> boolean</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true"></a></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true"></a><span class="fu">eqPayloads</span>({<span class="dt">payload</span><span class="op">:</span> {<span class="dt">bye</span><span class="op">:</span> <span class="st">&quot;world&quot;</span>}}<span class="op">,</span> {<span class="dt">payload</span><span class="op">:</span> {<span class="dt">hello</span><span class="op">:</span> <span class="st">&quot;world&quot;</span>}})  <span class="co">//compilies</span></span></code></pre></div>
<div class="sourceCode" id="cb35"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true"></a><span class="co">// Compilation error:</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true"></a><span class="co">// Property 'bye' is missing in type '{ hello: string; }' but required in type '{ bye: string; }'.ts(2741)</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true"></a><span class="fu">eqPayloads</span>({payload: bye}, {payload: hello})</span></code></pre></div>
<p>My first instinct was to assume that this weird behavior is caused by TS treating <code>T[]</code> and <code>Payload&lt;T&gt;</code> conservatively as invariant. Unfortunately, this is not the case. The above quirkiness looks to be just another type inference issue and there is a deeper safety problem.</p>
<p>TS implements variance incorrectly and makes both <code>T[]</code> and <code>Payload&lt;T&gt;</code> covariant (e.g. TS assumes that <code>P extends T</code> implies <code>Payload&lt;P&gt; extends Payload&lt;T&gt;</code>). Here is a well known Java language bug reimplemented in TS:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true"></a><span class="co">//how to put a string into a list of numbers</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true"></a><span class="kw">const</span> intlist<span class="op">:</span> number[] <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>]</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true"></a><span class="kw">const</span> list<span class="op">:</span> unknown[] <span class="op">=</span> intlist</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true"></a>list<span class="op">.</span><span class="fu">push</span>(<span class="st">&quot;not a number&quot;</span>) <span class="co">//compiles</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true"></a></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true"></a><span class="co">//array is incorrectly covariant</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true"></a>verifyExtends<span class="op">&lt;</span><span class="kw">typeof</span> datedHello[]<span class="op">,</span> <span class="kw">typeof</span> helloDolly[]<span class="op">&gt;</span>() <span class="co">//datedHello extends helloDolly type</span></span></code></pre></div>
<p>I see the same incorrect subtyping on the <code>Payload</code> interface:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true"></a><span class="co">//interface Payload is incorrectly covariant</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true"></a>verifyExtends<span class="op">&lt;</span>Payload<span class="op">&lt;</span><span class="kw">typeof</span> datedHello<span class="op">&gt;,</span> Payload<span class="op">&lt;</span><span class="kw">typeof</span> helloDolly<span class="op">&gt;&gt;</span>()</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true"></a>verifyExtends<span class="op">&lt;</span>Payload<span class="op">&lt;</span><span class="kw">typeof</span> datedHello<span class="op">&gt;,</span> Payload<span class="op">&lt;</span>object<span class="op">&gt;&gt;</span>()</span></code></pre></div>
<p>Implementations of <code>interface Payload&lt;T&gt;</code> do not need to behave in a covariant way.<br />
An example in the linked github repo exploits <code>interface Payload&lt;T&gt;</code> covariance and ends up passing a <code>number</code> to a function that accepts <code>string</code> input.</p>
<p>Invariance would have been a better (a more conservative) choice for both <code>interface Payload&lt;T&gt;</code> and the array.<br />
A careful reader may notice that the structurally typed <code>type Payload1&lt;T&gt; = {payload: T}</code> should also be invariant since the <code>payload</code> property is mutable (getters are covariant, setters are contravariant). TS incorrectly makes it covariant.</p>
<p>I will sound like a broken record now, subtyping is clearly very complex.</p>
<p>I did more digging into it after writing this note. It appears that the intention was to keep TS conceptually easy (<a href="https://github.com/microsoft/TypeScript/issues/1394" target="_blank">issue #1394</a>).<br />
The result may be easy but is definitely not simple.</p>
<p><em>Incorrect is never simple.</em></p>
<p> <div class="side-note"><strong>Observation (Rant Alert)</strong>: There is a tendency to focus on common cases and ignore corner cases. This tendency has a broad scope, broader than TS. What has (typically) a lower cost: resolving a problem that every user observes when opening the app or resolving a problem that affects 1% of users once a month? Are less frequently observed defects assigned a lower priority? Not really.<br />
Common approach to software and language design and the economics of software maintenance are an ill matched couple.  </div></p>
<h3 id="summary">Summary</h3>
<p>This was a very hard note to write. I rewrote it several times. How do I write about complexity and make it simple to read?<br />
Seems like a catch-22 problem.</p>
<blockquote>
<p>“One does not simply explain TS types”</p>
</blockquote>
<p><em>Boromir about TypeScript</em></p>
<p>Again, my main claims are:</p>
<ul>
<li>subtyping adds significant complexity and lowers type safety</li>
<li>ad-hoc semantic narrowing around JS operators partially recovers safety, but is complex by itself and scope limited</li>
</ul>
<p>Languages with simpler and more reliable type systems are not a superset of JS syntax and are idiomatically far from JS<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>.</p>
<p>We have observed some compilation issues and irregularities. To summarize these:</p>
<ul>
<li>issues inferring literal types widened to a union (<a href="#subtyping"><code>eq(1, "boo")</code></a>)</li>
<li>issues preventing intersecting unions involving literal types (<a href="#subtyping"><code>(1 | "boo") &amp; ("boo" | Person)</code></a>)</li>
<li>unexpected widening of literal object property types (<a href="#hidden-blooper-side-note">hidden blooper</a>)</li>
<li>inconsistent widening of function arguments (top of <a href="#variance-problems">variance problems</a>)</li>
<li>incorrect handling of variance (<a href="#variance-problems">variance problems</a>)</li>
<li><code>===</code> rejects the <code>&amp;</code> overlap of intersection types, while claiming the opposite in the error message (<a href="#semantics-rejected-overlap">rejected overlap</a>)</li>
</ul>
<p>I cannot identify TypeScript documentation or tickets relevant to these bullets. The subset I have checked against <a href="https://github.com/microsoft/TypeScript/issues" target="_blank">TS issue board</a> is either in the known issues and / or “Working as Intended” category. My question about known issues is: known by whom?</p>
<p>Introduced tools</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true"></a>declare <span class="kw">function</span> unify<span class="op">&lt;</span>T<span class="op">&gt;</span>(t1<span class="op">:</span> T<span class="op">,</span> t2<span class="op">:</span> T) <span class="op">:</span> T</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true"></a><span class="kw">function</span> verifyExtends<span class="op">&lt;</span>T2 <span class="kw">extends</span> T1<span class="op">,</span> T1<span class="op">&gt;</span>() {}</span></code></pre></div>
<p>can be used to ask TS subtyping questions.</p>
<h2 id="next-chapter">Next Chapter</h2>
<p>This post has been about the “messy” in TS. The next installment will focus on programming with type variables and will present TS in a better light. I decided to split advanced topics into 2 smaller posts. I plan to discuss phantom types, type variable scoping, a pattern emulating existential types, and rank 2 types. I consider these to be quite useful typing approaches. I will also show a trick that prevents <code>unknown</code> and supertype widening.</p>
<p>Here is the link: <a href="2022-01-09-ts-types-part4.html" target="_blank">Part 4</a>.</p>
<p>Happy New Year to all of my readers. Thank you for reading.</p>
<h2 id="summary-of-final-edits">Summary of final edits</h2>
<ul>
<li>Added information about <code>as const</code> in <a href="#hidden-blooper-side-note">Hidden blooper note</a></li>
<li>Added note about tickets relevant to the <a href="#semantics-rejected-overlap">overlap issue</a> (see footnote <a href="#fn4">4</a>)</li>
<li>Added side note about arity in <a href="#subtyping">Subtyping</a>.</li>
</ul>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p><a href="#semantics-rejected-overlap">rejected overlap</a> section explains why I call it a guess.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>All can be used for frontend development and can be compiled to JS.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>Haskell is still improving on this aspect. IMO, the need for polymorphic access to record fields is overrated. I would trade it for a capable compiler any time.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>See <a href="https://github.com/microsoft/TypeScript/issues/27910" target="_blank">#27910</a> I created <a href="https://github.com/microsoft/TypeScript/issues/48628" target="_blank">#48628</a> which was originally marked as “Working as Intended” and then moved to “Duplicate” status.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>I have not used <em>flow</em> recently, and I cannot compare TS to it. However <em>flow</em> has subtyping which I do not consider simple. Indeed, some level of subtyping support is needed to support commonly used JS idioms.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

    </section>
</article>
]]></summary>
</entry>
<entry>
    <title>Type Enthusiast's Notes about TypeScript. Part 2. Typing Honestly</title>
    <link href="https://rpeszek.github.io//posts/2021-12-24-ts-types-part2.html" />
    <id>https://rpeszek.github.io//posts/2021-12-24-ts-types-part2.html</id>
    <published>2021-12-24T00:00:00Z</published>
    <updated>2021-12-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
    <section class="header">
        Posted on December 24, 2021
        
            by Robert Peszek
        
        
        
        <div class="changelog"> <div>Revision History: <ul> <li> (2022.04.29 - Present) Minor edits </li> </ul> </div></div>
        
        
        <div class="info">Tags: <a title="All pages tagged 'TypeScript-Notes'." href="../tags/TypeScript-Notes.html">TypeScript-Notes</a></div>
        
    </section>
    <section>

    </section>
    <section>
        <div class="toc"><div class="header">Table of Contents</div>
<ul>
<li><a href="#nutshell">Nutshell</a></li>
<li><a href="#can-i-trust-the-types">Can I trust the types?</a></li>
<li><a href="#note-about-the-any-type">Note about the <code>any</code> type</a></li>
<li><a href="#casting-casting-in-a-bad-light">Casting <em>casting</em> in a bad light</a>
<ul>
<li><a href="#improving-office.js-with-type-predicates">Improving <em>office.js</em> with type predicates</a></li>
</ul></li>
<li><a href="#note-about-the-unknown-type">Note about the <code>unknown</code> type</a></li>
<li><a href="#honest-typing-conventions">Honest typing conventions</a>
<ul>
<li><a href="#referential-transparency">Referential Transparency</a></li>
<li><a href="#types-as-documentation">Types as documentation</a></li>
</ul></li>
<li><a href="#next-chapter">Next Chapter</a></li>
</ul>
</div>
<p><em>Please Leave Feedback in: <a href="https://github.com/rpeszek/rpeszek.github.io/discussions/1" target="_blank">git discussions</a></em></p>
<p>Previous post: <a href="2021-12-12-ts-types-part1.html" target="_blank">Part 1. Typing in Anger</a>.</p>
<p><strong>DRAFT version</strong> <em>(I am sorry about any misprints. It seems I have goblins in my laptop that toy with me, remove or change words. When this note disappears, you will know that I gave up.)</em></p>
<p><strong>Disclaimers:</strong> (imagine this is a very small font, read it very fast in a half whisper)<br />
<em>I assume strict compiler flags are on, something you get by default with scaffolding, e.g. using <code>create-react-app my-project --template typescript</code> is close enough.<br />
The code examples have been tested with TypeScript v4.4.4 and v4.5.2.<br />
office.js examples are based on https://appsforoffice.microsoft.com/lib/1.1/hosted/office.js and <span class="citation" data-cites="types/office-js">@types/office-js</span><span class="citation" data-cites="1.0.221">@1.0.221</span> (these match the current scaffold for office.js/React).<br />
This post is a pandoc output of a markdown document and code examples are not interactive.<br />
Most of the code examples are published in <a href="https://github.com/rpeszek/ts-experiments/tree/master/ts-notes" target="_blank">ts-notes</a> folder in this github repo: <a href="https://github.com/rpeszek/ts-experiments" target="_blank">ts-experiments</a>.</em></p>
<p><strong>Motivating Quote for the series:</strong></p>
<blockquote>
<p>“TypeScript began its life as an attempt to bring traditional object-oriented types to JavaScript so that the programmers at Microsoft could bring traditional object-oriented programs to the web. As it has developed, TypeScript’s type system has evolved to model code written by native JavaScripters. The resulting system is <em>powerful, interesting and messy.</em>”</p>
</blockquote>
<p><em>From typescriptlang <a href="https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html" target="_blank">TypeScript for Functional Programmers</a></em></p>
<h2 id="nutshell">Nutshell</h2>
<p>This is the second post in the series devoted to types in TypeScript. In this series, I explore type-centric approaches to writing code and often push TS to its limits in doing so. I am writing these posts for like minded developers who are interested in types and either use or consider using TypeScript.</p>
<p>This post will cover TS’s type predicates, the notorious <code>any</code>, and its safer cousin the <code>unknown</code>. These are well known and heavily blogged topics. My goal is provide a little different perspective with a more type-centric view point.<br />
This series uses <em>office.js</em> as a source of code examples. This post examines the correctness of <em>office.js</em> types and fixes them using type predicates.<br />
My main code example is something I am excited about. It demonstrates a case where TS made me completely rethink a previously written JS code.<br />
I will discuss some safety concerns about <code>unknown</code> (no, this is not a typo, I mean the <code>unknown</code> type) and will set the stage for my future note about complexity of TS types.<br />
I will finish in the realm of coding conventions discussing transparent, self documenting type definitions.</p>
<h2 id="can-i-trust-the-types">Can I trust the types?</h2>
<p>I am going to discuss the obvious gotcha in a gradually typed language like TS: runtime values do not satisfy statically defined types.<br />
Despite it being an obvious concern, the issue is something a developer who spends most time in a statically typed language (e.g. me) will not have on his / her mind when working in TS.<br />
The following seem to be the prevalent reasons for why values do not match types: overconfident TS code (e.g. type casting, <code>any</code> type), issues with converted JavaScript (declaration files out of sync or containing otherwise incorrect definitions). I am going to show a real life (or close to real life) example of each.</p>
<p>The series started with an example defining the <code>Person</code> type, to avoid jumping back and forth I will repeat it here</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>type Person <span class="op">=</span> {<span class="dt">firstNm</span><span class="op">:</span> string<span class="op">,</span> <span class="dt">lastNm</span><span class="op">:</span> string} </span></code></pre></div>
<p>This will be a good conversation starter:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="co">//Questionable JSON parsing example</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="kw">const</span> p<span class="op">:</span> Person <span class="op">=</span> <span class="bu">JSON</span><span class="op">.</span><span class="fu">parse</span>(<span class="st">'&quot;John Smith&quot;'</span>)</span></code></pre></div>
<p>Your experience with consistency of JSON data may be different from mine. I rarely see JSON issues in a frontend - backend conversation. On the other hand, my experience with using 3rd party REST APIs is not exactly stellar. JSON data problems do happen.</p>
<p>The above code illustrates what I used to call ‘fail late’ and now I call ‘a type I cannot trust’ case. It is a nasty situation where runtime errors are nowhere near the actual problem. Looking at the example, <code>JSON.parse</code> function is declared to return the TS’s notorious <code>any</code> type. Using <code>any</code> bypasses type checking and the code assigns the result to <code>Person</code>. The actual run-time value of <code>p</code> will be a <code>string</code>, while the type checker is now convinced it is <code>p:Person</code>.</p>
<p>Now, look at the top rated answer in this stackoverflow: <a href="https://stackoverflow.com/questions/38688822/how-to-parse-json-string-in-typescript" target="_blank">how-to-parse-json-string-in-typescript</a>. It appears that the above code matches the top rated answer. Yes, safer approaches are available (look at less popular answers, we will discuss a much safer way as well).<br />
I am not claiming this to be a prevalent problem in TS code, but it is an interesting issue caused by the coexistence of the typed and the untyped.</p>
<p>Now, since I already may have angered a large part of the TS community (did I? I hope not.), let’s beat a little on <strong><em>office.js</em></strong>.</p>
<p><em>office.js</em> is a source of code examples for my series. Looking into <em>office.js</em> release history suggests that a bond between <em>office.js</em> and TypeScript. That bond developed very early. It looks like these projects grew up together. <em>office.js</em> might have even been one of these Microsoft projects that spearheaded the development of TS.</p>
<p><strong>Short Recap</strong> We are using <em>office.js</em> to interact with Outlook emails. <em>office.js</em> provides us with <code>item: Office.MessageRead</code> allowing us to retrieve data from an email opened for viewing in Outlook. <strong>(Recap End)</strong></p>
<p>I imagine it is not that uncommon for a TS library to have a non-nullable property that is undefined at runtime.<br />
The IntelliSense tells me that <code>item: Office.MessageRead</code> contains an overloaded <code>item.body.getTypeAsync</code> method. I was hoping to use it to retrieve the type (plain text vs html) of the email body.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>(method) Office<span class="op">.</span><span class="at">Body</span><span class="op">.</span><span class="fu">getTypeAsync</span>(options<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncContextOptions</span><span class="op">,</span> callback<span class="op">?:</span> ((asyncResult<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncResult</span><span class="op">&lt;</span>Office<span class="op">.</span><span class="at">CoercionType</span><span class="op">&gt;</span>) <span class="kw">=&gt;</span> <span class="kw">void</span>) <span class="op">|</span> <span class="kw">undefined</span>)<span class="op">:</span> <span class="kw">void</span> (<span class="op">+</span><span class="dv">1</span> overload)</span></code></pre></div>
<p><code>getTypeAsync</code> is undefined at runtime. It looks to me like the TS declaration files are not in sync with JavaScript. My hypothesis seems to be confirmed by the <a href="https://docs.microsoft.com/en-us/javascript/api/outlook/office.body?view=outlook-js-preview#getTypeAsync_callback_" target="_blank"><code>item.body.getTypeAsync</code></a> documentation suggesting that this method is available when email is open in compose mode (not when using <code>Office.MessageRead</code>). (I am using office online and the latest <em>office.js</em> as of the time of this writing.)<br />
<em>Please message me in git discussions if you think I am misrepresenting it.</em></p>
<p><em>It seems like <em>office.js</em> types are a little off.</em></p>
<p>We should look at the type definition of the <em>office.js</em> <a href="https://docs.microsoft.com/en-us/javascript/api/outlook/office.item?view=outlook-js-preview" target="_blank"><code>Office.context.mailbox.item</code></a> a little closer.<br />
This property is overloaded to be one of the following types (let me call them <em>facets</em>):</p>
<blockquote>
<p><code>Office.AppointmentCompose</code> (composing calendar entry)<br />
<code>Office.AppointmentRead</code> (reading calendar entry)<br />
<code>Office.MessageCompose</code> (composing email)<br />
<code>Office.MessageRead</code> (reading email)</p>
</blockquote>
<p>These <em>facet</em> types are all different. For example, to get email subject you use <code>item.subject:string</code> if you are working with <code>Office.MessageRead</code> or <code>item.subject:Office.Subject</code> if you are working with <code>Office.MessageCompose</code>.<br />
<code>Office.Subject</code> contains <code>getAsync</code>, <code>setAsync</code> methods and is absolutely not a <code>string</code>.</p>
<p>The type of <code>item</code> provided by <em>office.js</em> is not, as I would expect:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="co">//Type I expected</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>AppointmentCompose <span class="op">|</span> AppointmentRead <span class="op">|</span> MessageCompose <span class="op">|</span> MessageRead</span></code></pre></div>
<p>Rather it is closer (I have not listed all the <code>&amp;</code>-s) to:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="co">//Actual Type with some &amp; parts removed </span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>AppointmentCompose <span class="op">&amp;</span> AppointmentRead <span class="op">&amp;</span> MessageCompose <span class="op">&amp;</span> MessageRead</span></code></pre></div>
<p>Basically, the type <em>office.js</em> chose for <code>item</code> mashes all the available properties, methods, overloads into one type. This is simply an incorrect type for the <code>item</code> property. Runtime values do not satisfy the <em>intersection</em> type, they satisfy the <em>union</em> type. Type checked programs will fail at runtime. <em>office.js</em> type declarations are incorrect.</p>
<p><em>office.js types are off for sure.</em></p>
<p>In a weird way, this explains why the undefined <code>item.body.getTypeAsync</code> has not been noticed. Without a corrective reassignment to, say, <code>Office.MessageRead</code> many other methods are <code>undefined</code> at runtime and it is harder to single this particular one out.</p>
<p>Gradual typing over the wild-west JS has to come with maintenance challenges.<br />
Nonetheless this is surprising. What are the types good for if they’re not accurate?</p>
<blockquote>
<p>“You take the blue pill — the story ends, you wake up in your bed and believe whatever you want to believe.<br />
You take the red pill — you stay in Wonderland, and I show you how deep the rabbit hole goes”</p>
</blockquote>
<p><em>Morpheus about not believing types in a gradually typed language</em><br />
<em>… nightmares of JavaScript running on my walls and ceilings make me wake up screaming</em></p>
<h2 id="note-about-the-any-type">Note about the <code>any</code> type</h2>
<p>My first example in this post used the infamous <code>any</code> type. Let’s have a closer look.</p>
<p><code>any</code> type is crazy. It behaves like the <em>top</em> (you can assign any other type to it). It also behaves like the <em>bottom</em> (it can be assigned to any other type, maybe except of <em>never</em>). Ideally, the bottom type is empty, this one clearly is not.</p>
<p><em>As a result, any value can have any type.</em></p>
<p>We should have some fun with this.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="co">//express yourself with _any_ (notice no casting, only assignments)</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="kw">const</span> sad<span class="op">:</span> any <span class="op">=</span> <span class="st">&quot;emptiness and sadness&quot;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a><span class="kw">const</span> sadVoid<span class="op">:</span> <span class="kw">void</span> <span class="op">=</span> sad</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a><span class="kw">const</span> myCallback <span class="op">=</span> (n<span class="op">:</span> number)<span class="op">:</span> <span class="kw">void</span> <span class="kw">=&gt;</span> {</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>    <span class="cf">return</span> sadVoid<span class="op">;</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>}</span></code></pre></div>
<p>You can have your own favorite <code>null</code> that is not <code>null</code> value, you can <em>define</em> your own <code>undefined</code>. Sky and your creativity are the limits. I will spoil this party and say that I do not recommend doing it. Oh, maybe just a little. Well OK, one more:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">const</span> sassy<span class="op">:</span> any <span class="op">=</span> {<span class="dt">netWorth</span><span class="op">:</span> <span class="st">&quot;billion dollars&quot;</span><span class="op">,</span> <span class="dt">popularityLevel</span><span class="op">:</span> <span class="st">&quot;celebrity&quot;</span>}</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="kw">const</span> sassyNull<span class="op">:</span> <span class="kw">null</span> <span class="op">=</span> sassy</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a><span class="kw">const</span> p<span class="op">:</span> Person <span class="op">|</span> <span class="kw">null</span> <span class="op">=</span> sassyNull</span></code></pre></div>
<p>A bottom that is not empty will cause the language to be unsound. Allowing all values in a bottom type, I would call it insane.<br />
However, using an <em>any</em> type similar to TS’s seems to be a common practice in gradually typed languages (e.g. Python does it too).<br />
Using <code>any</code> is like saying “hey, TS, please suspend type checking, I know what I am doing”. This is the antithesis of type safety, but what else can TS do and maintain JS compatibility?</p>
<p>Actually, TS has a very clever solution for this, it is described in the following sections.<br />
I view <code>any</code> as a form of type coercion or casting.</p>
<h2 id="casting-casting-in-a-bad-light">Casting <em>casting</em> in a bad light</h2>
<p>I will use the term casting and type coercion interchangeably. TypeScript documentation also uses the term <em>type assertion</em>. I view the <code>any</code> type to be in the same boat as well (an implicit type coercion).<br />
TS uses the <code>t as T</code> or <code>&lt;T&gt; t</code> syntax to cast expression <code>t</code> into type <code>T</code>, e.g. <code>iAmSureIsString as string</code>.<br />
(IMO, the second notation, <code>&lt;T&gt; t</code>, is somewhat unfortunate as it is very similar to type application and generic function declaration e.g. <code>const f = &lt;T&gt;():T</code> declares, <code>&lt;T&gt;f()</code> casts, <code>f&lt;T&gt;()</code> applies. I recommend the <code>v as T</code> syntax to make casting more explicit and searchable in your code.)</p>
<p> <div class="side-note"><strong>Type enthusiast’s note on casting at large:</strong><br />
Typically (and rightly) casting is considered to be a last resort, <em>only cast if you must</em>.</p>
<p>With more involved types it is often harder to write code that type checks. That increases the appeal of casting or finding some other alternatives for nudging the type checker into agreeing.<br />
Some languages offer the ability to write a program to persuade the type checker about type equality (write actual <em>proof of type equality</em>). This is an advanced feature and is available in only a few languages (e.g. Coq, Idris, Haskell). Writing such programs is often challenging or even impossible. (I consider writing such proofs to be one of the highest level “type games” that a developer can play. It is both a challenge and fun. A great intro is <a href="https://www.manning.com/books/type-driven-development-with-idris" target="_blank">TDD with Idris</a>)</p>
<p>There is an alternative to type coercion that allows programs to type check but will throw an exception when executed.<br />
This can be useful for interacting with the type checker when writing code. We have seen a TS version of this already, function <a href="2021-12-12-ts-types-part1.html#type-holes" target="_blank"><code>_&lt;T&gt;(): T</code></a>, defined in my previous post and stolen from <a href="https://dev.to/gcanti/type-holes-in-typescript-2lck" target="_blank">Type holes in TS</a>. Such programming practice is foreign to most languages but becomes very convenient when working with more involved types. We are using it in this series.  </div></p>
<p>Let’s beat on <em>office.js</em> some more. <a href="https://docs.microsoft.com/en-us/javascript/api/outlook/office.item" target="_blank">Here</a> is a piece <em>office.js</em> documentation about (you guessed it, this post is so very predictable) the <a href="https://docs.microsoft.com/en-us/javascript/api/outlook/office.item" target="_blank"><code>Office.context.mailbox.item</code></a>:</p>
<blockquote>
<p><em>If you want to see IntelliSense for only a specific type or mode, <strong>cast</strong> this item to one of the following:</em><br />
<em><code>AppointmentCompose</code></em><br />
<em><code>AppointmentRead</code> …</em></p>
</blockquote>
<p>TS offers a neat alternative to casting. I will explain it by <em>not</em> following the <em>office.js</em> documentation ;)</p>
<p>As I indicated already, I can interact with outlook email using <code>Office.context.mailbox.item</code>. However, <code>item</code> property is overloaded into several types discussed in the previous section (I called them <em>facets</em>):</p>
<p>The legacy code I am currently re-implementing at work is retrieving the email subject using <code>item.subject</code> and checking what kind of <code>item.subject</code> it is (a string, has asyc methods, etc) and using it accordingly. It does a similar <em>“check before you use”</em> game to retrieve <code>to</code>, <code>from</code>, <code>cc</code> and other email information.<br />
Such an approach is typical, almost idiomatic to JS. It is also hard to maintain as making changes directed at one facet can easily break the other facets. And you can test your heart out on all emails you can think about and your app will still crash and burn if used with an office calendar appointment.</p>
<p>So what is the new TS-idiomatic way to do it?  TS has the <code>is</code> types.</p>
<h3 id="improving-office.js-with-type-predicates">Improving <em>office.js</em> with type predicates</h3>
<div class="sourceCode" id="cb8"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="im">export</span> <span class="kw">const</span> isMessageRead <span class="op">=</span> (item<span class="op">:</span> any)<span class="op">:</span> item is Office<span class="op">.</span><span class="at">MessageRead</span> <span class="kw">=&gt;</span> {</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>    <span class="cf">return</span> (item<span class="op">.</span><span class="at">itemType</span> <span class="op">===</span> Office<span class="op">.</span><span class="at">MailboxEnums</span><span class="op">.</span><span class="at">ItemType</span><span class="op">.</span><span class="at">Message</span>) <span class="op">&amp;&amp;</span> item<span class="op">.</span><span class="at">getAttachmentsAsync</span> <span class="op">===</span> <span class="kw">undefined</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>} </span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>  </span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a><span class="im">export</span> <span class="kw">const</span> isMessageCompose <span class="op">=</span> (item<span class="op">:</span> any)<span class="op">:</span> item is Office<span class="op">.</span><span class="at">MessageCompose</span> <span class="kw">=&gt;</span> {</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>    <span class="cf">return</span> (item<span class="op">.</span><span class="at">itemType</span> <span class="op">===</span> Office<span class="op">.</span><span class="at">MailboxEnums</span><span class="op">.</span><span class="at">ItemType</span><span class="op">.</span><span class="at">Message</span>) <span class="op">&amp;&amp;</span> item<span class="op">.</span><span class="at">getAttachmentsAsync</span> <span class="op">!==</span> <span class="kw">undefined</span> </span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a>} </span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a>declare <span class="kw">function</span> <span class="fu">doSomethingWithViewedEmail</span>(item<span class="op">:</span> Office<span class="op">.</span><span class="at">MessageRead</span>)<span class="op">:</span> <span class="kw">void</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a>declare <span class="kw">function</span> <span class="fu">doSomethingWithComposedEmail</span>(item<span class="op">:</span> Office<span class="op">.</span><span class="at">MessageCompose</span>)<span class="op">:</span> <span class="kw">void</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a>declare <span class="kw">function</span> <span class="fu">onlyEmailEntriesAreSupported</span>()<span class="op">:</span> <span class="kw">void</span></span></code></pre></div>
<p>(OK, checking <code>getAttachmentsAsync</code> is ugly, office.js could provide some nicer and more stable way to identify the exact <code>item</code> type. This is still not bad. Let’s move on.)</p>
<p><code>doSomethingWithViewedEmail</code> and <code>doSomethingWithComposedEmail</code> can now be coded with confidence (if I trust <em>office.js</em> types) following the corresponding <code>MessageRead</code> or <code>MessageCompose</code> types. IntelliSense makes writing these a breeze and the code is very clean. E.g., <code>subject</code> is just a <code>string</code> in <code>MessageRead</code>.</p>
<p>I can use these without any casting:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="co">//'unknown' replaces incorrect office.js type (see previous section). </span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a><span class="kw">const</span> item<span class="op">:</span> unknown <span class="op">=</span> Office<span class="op">.</span><span class="at">context</span><span class="op">?.</span><span class="at">mailbox</span><span class="op">?.</span><span class="at">item</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a><span class="cf">if</span>(<span class="fu">isMessageRead</span>(item)) {</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>  <span class="co">//doSomethingWithComposedEmail(item) //this will not type check!</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>  <span class="fu">doSomethingWithViewedEmail</span>(item)    </span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>} <span class="cf">else</span> <span class="cf">if</span> (<span class="fu">isMessageCompose</span>(item)) {</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>  <span class="co">//doSomethingWithViewedEmail(item) //this will not type check!</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a>  <span class="fu">doSomethingWithComposedEmail</span>(item)  </span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a>} <span class="cf">else</span> {   </span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true"></a>  <span class="fu">calendarEntriesAreNotSupported</span>()</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true"></a>}</span></code></pre></div>
<p>This is a really nice, bravo TypeScript! Simple to use, yet very useful.</p>
<p>It is also IMO a very interesting case of TS making a bigger impact on how we actually code. <em>“Check before you use”</em> game becomes type assisted and happens on a coarser scale of <code>item</code> types instead of single (e.g. the email <em>subject</em>, <em>from</em>, <em>cc</em>, etc.) properties.<br />
This adds a lot of clarity to the code. TS types not just check my code, types change how I code!</p>
<p><code>t is T</code> type is one of the TypeScript <a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html" target="_blank">narrowing</a> tools. The documentation refers to it as a <em>type predicate</em> or a <em>type guard</em> (a more general term).<br />
IMO, the idea of a middle ground between type checked safety and unsafe type coercion is brilliant.<br />
It is something that sits a half way between a cast and a type equality proof.<br />
This will probably influence other languages (e.g. here is <a href="https://www.python.org/dev/peps/pep-0647/" target="_blank">enhancement proposal for Python</a>).</p>
<p>The syntax <code>t is T</code> is interesting, it clearly borrows from dependently typed languages. The value <code>t</code> appears next to the type <code>T</code> and comes from the earlier part of the declaration. This also somewhat justifies the existence of otherwise cumbersome parameter names in type definitions (something I complained about in my <a href="2021-12-12-ts-types-part1.html#office.js.-using-ts-in-anger" target="_blank">previous post</a>).</p>
<p>I hope the TS community develops a healthy aversion to casting. Why would you use a type checker if you keep subverting it? I also hope that exporting functions returning type predicates will become a standard practice for APIs.</p>
<p> <div class="side-note"><strong>Use of <code>any</code> in type predicates</strong><br />
Arguably, a safer approach was to define <code>isMessageRead</code> and <code>isMessageCompose</code> using a parameter type that is more restrictive than <code>any</code>.<br />
My goal was to keep this example very simple and avoid introducing a <code>CorrectedOfficeItem</code> type to fix <em>office.js</em> typing. In real code, I would opt in for introducing the corrected type. Linked github repo defines and uses <code>CorrectedOfficeItem</code>.<br />
However, using <code>any</code> in type predicate implementations appears to be a common practice. Implementing a type predicate typically requires checking for existence of object properties and <code>any</code> provides access to these.<br />
My suggestion is to avoid type guards in certain places, e.g. in generics. We want generics to be generic.  </div></p>
<h2 id="note-about-the-unknown-type">Note about the <code>unknown</code> type</h2>
<p>This post started with a use of the unsafe <code>JSON.parse</code>. I am quite sure that if TypeScript could travel back in time <code>JSON.parse</code> would return <code>unknown</code> instead of <code>any</code>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="im">export</span> <span class="kw">const</span> safeParseJSON <span class="op">:</span> (_<span class="op">:</span> string) <span class="kw">=&gt;</span> unknown <span class="op">=</span> <span class="bu">JSON</span><span class="op">.</span><span class="fu">parse</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a><span class="kw">const</span> isPerson <span class="op">=</span> (p<span class="op">:</span> any)<span class="op">:</span> p is Person <span class="kw">=&gt;</span> </span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>        <span class="kw">typeof</span> p<span class="op">.</span><span class="at">firstNm</span> <span class="op">===</span> <span class="st">'string'</span> <span class="op">&amp;&amp;</span> <span class="kw">typeof</span> p<span class="op">.</span><span class="at">lastNm</span> <span class="op">===</span> <span class="st">'string'</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a><span class="kw">const</span> possiblyPerson <span class="op">=</span> <span class="fu">safeParseJSON</span>(<span class="st">'&quot;John Smith&quot;'</span>) </span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a><span class="cf">if</span> (<span class="fu">isPerson</span>(possiblyPerson)) {</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a>    <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(possiblyPerson<span class="op">.</span><span class="at">firstNm</span>)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true"></a>} <span class="cf">else</span> {</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true"></a>    <span class="co">// console.log(possiblyPerson.firstNm) //does not compile</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true"></a>}</span></code></pre></div>
<p><code>unknown</code> is a newer and a safer alternative to <code>any</code>.</p>
<p><code>unknown</code> type is (only) the top type (you can assign anything to it but you cannot assign it to anything else, maybe except for <code>any</code>). This is a much better safety than being both the <em>top</em> and the <em>bottom</em>. Compared to <code>any</code> it is more cumbersome to use but significantly safer.</p>
<p>Let’s criticize the <code>unknown</code> a bit. A rough view (IMO) of what type safety is: an ability to <em>separate apples from oranges</em>. If you can assign both an apple to <code>unknown</code> and an orange to <code>unknown</code> then they are no longer separated.<br />
What makes this worse in TS, is its occasional tendency to widen return types to <code>unknown</code>. TS tends to do that if it cannot find a more precise return type, when it tries to apply subtying rules to things like functions, or when it gets confused. We saw two examples of this in the last post:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="co">//compilation bug allows this incorrect code to compile with</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a><span class="co">// emailBody4: unknown</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a><span class="co">//this code will accutally work at runtime because 'crazyConfig' ends up not being used </span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a><span class="kw">const</span> crazyConfig <span class="op">:</span> (_<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncResult</span><span class="op">&lt;</span>string<span class="op">&gt;</span>) <span class="kw">=&gt;</span> <span class="kw">void</span> <span class="op">=</span> x <span class="kw">=&gt;</span> <span class="st">&quot;&quot;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a><span class="kw">const</span> emailBody4 <span class="op">=</span> <span class="cf">await</span> <span class="fu">officePromise</span> (<span class="fu">curry3</span>(item<span class="op">.</span><span class="at">body</span><span class="op">.</span><span class="at">getAsync</span>)(Office<span class="op">.</span><span class="at">CoercionType</span><span class="op">.</span><span class="at">Html</span>)(crazyConfig)) </span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a><span class="co">//test: (a: unknown) =&gt; (b: unknown) =&gt; unknown</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a><span class="kw">const</span> test <span class="op">=</span> <span class="fu">curry</span>({} <span class="im">as</span> any)</span></code></pre></div>
<p>Also, notice <code>unknown</code> in some of the <a href="2021-12-12-ts-types-part1.html#compilation-bloopers" target="_blank">blooper</a> examples from the previous post:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="co">//these should not compile but they do. Names are consitent with previous post and the linked github repo</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a><span class="co">//const nonsense2: &lt;T1, T2, R&gt;(a: (ax: T1, bx: T2) =&gt; R) =&gt; (b: unknown) =&gt; (a: T1) =&gt; (b: T2) =&gt; R</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a><span class="kw">const</span> nonsense2 <span class="op">=</span> <span class="fu">curry</span>(curry) </span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a><span class="co">//const nonsense3: &lt;T1, T2, T3, R&gt;(a: (ax: T1, bx: T2, cx: T3) =&gt; R) =&gt; (b: unknown) =&gt; (a: T1) =&gt; (b: T2) =&gt; (c: T3) =&gt; R</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a><span class="kw">const</span> nonsense3 <span class="op">=</span> <span class="fu">curry</span>(curry3)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a><span class="co">//const nonsense4: &lt;T1, T2, R&gt;(a: (ax: T1, bx: T2) =&gt; R) =&gt; (b: unknown) =&gt; (b: unknown) =&gt; (a: T1) =&gt; (b: T2) =&gt; R</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a><span class="kw">const</span> nonsense4 <span class="op">=</span> <span class="fu">curry</span>(<span class="fu">curry</span>(curry))</span></code></pre></div>
<p>and we will encounter more examples of <em>unknown widening</em> in future notes. I would be happier if many of these examples resulted in a compilation error. Current status quo reduces safety of TS code.</p>
<p>Let’s look at how <code>unknown</code> makes things like <code>===</code> more complex. I really love the fact that this code (a contrived example but generalizes easily to real situations) does not compile:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="co">//Compilation error:</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a><span class="co">//This condition will always return 'false' since the types 'string' and 'number' have no overlap.</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a><span class="st">&quot;some email body&quot;</span> === <span class="dv">1</span> </span></code></pre></div>
<p>However, this does compile:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a>(<span class="st">&quot;some email body&quot;</span> <span class="im">as</span> unknown) <span class="op">===</span> <span class="dv">1</span></span></code></pre></div>
<p>and so does this:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a>emailBody4 <span class="op">===</span> <span class="dv">1</span></span></code></pre></div>
<p>Let’s bring in the type hole <a href="2021-12-12-ts-types-part1.html#type-holes" target="_blank"><code>_&lt;T&gt;(): T</code></a> from the last post. The type hole is a convenient way to ask the compiler type questions.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="co">//hovering over res and _ allows me to see the typing of '===`</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a><span class="kw">const</span> res <span class="op">=</span> <span class="fu">_</span>() <span class="op">===</span> <span class="fu">_</span>()</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>(<span class="dv">1</span> <span class="im">as</span> <span class="dv">1</span>) <span class="op">===</span> <span class="fu">_</span>()</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a><span class="fu">_</span>() <span class="op">===</span> (<span class="dv">1</span> <span class="im">as</span> <span class="dv">1</span>)</span></code></pre></div>
<p>So the “imaginary” type signature of <code>===</code> is:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>declare <span class="kw">function</span> <span class="fu">eqeqeq</span>(a<span class="op">:</span> unknown<span class="op">,</span> b<span class="op">:</span> unknown)<span class="op">:</span> boolean</span></code></pre></div>
<p>Except</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="fu">eqeqeq</span>(<span class="st">&quot;some text&quot;</span><span class="op">,</span> <span class="dv">1</span>) <span class="co">//compiles</span></span></code></pre></div>
<div class="sourceCode" id="cb19"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="st">&quot;some text&quot;</span> <span class="op">===</span> <span class="dv">1</span> <span class="co">//does not compile</span></span></code></pre></div>
<p>In fact, <code>===</code> <em>does not have a type</em>. It is a built-in JS operator. TS applies semantic narrowing rules to the code that uses it.<br />
This complex approach is needed to provide type safety while maintaining compatibility with JS.<br />
TS’s semantic rules prevent certain types like <code>someText === someNumber</code> from compiling, except, this safety is somewhat fragile and breaks when <code>someText</code> or <code>someNumber</code> are accidentally widened to <code>unknown</code> by the type inference. TS uses a similar approach for other built-in JS operators. (We will discuss the crazy <code>===</code> semantics in a deeper detail in the next post.)</p>
<p><strong>General safety concerns about the top:</strong> Developers, like me, who had spent decades working in languages like Java and then switched to a typed FP language see immediate safety benefits just because there isn’t any top type. The concern about <code>unknown</code> is that it is used with many JS functions and operators. Such use is not type safe, similarly to how Java’s <code>Object</code> methods are not type safe.<br />
From the type safety point of view, these JS functions and operators are not implemented well either. Consider for example <code>JSON.stringify</code> which accepts <code>any</code>. Does this expression (it returns <code>undefined</code>) make much sense to you: <code>JSON.stringify(() =&gt; {})</code>?<br />
Generic functions lose safety too, generics are not <em>generic</em> if a generically typed function parameter can use a <em>specific</em> JS function (like the <code>JSON.stringify</code> function).</p>
<p>Something like <code>unknown</code> is probably the only way for TS to achieve JS compatibility, nonetheless <code>unknown</code> is not ideal.</p>
<p>I will come back to this discussion again, I plan to discuss the complexity of TS types. I will also return to the <code>unknown</code> type itself in the future in a more theoretical setting.</p>
<h2 id="honest-typing-conventions">Honest typing conventions</h2>
<p>These notes will be a little ranty (you’ll probably ask: “Did you read your other notes?”). Any coding convention is effectively a hand waving rant. That is why we use types, so we can rant less!</p>
<p>One of my former colleagues liked to use the phrase “gentlemen’s agreement”. It means an agreement between developers to self impose certain limitations on the code they write. These limitations are not enforced by the compiler, only by developers who agree to abide by the set rules. Coding guidelines, design patterns, you know what I am talking about.</p>
<p>There is a term in Programming Language Theory called <em>parametricity</em>. Roughly speaking, a language that supports <em>parametricity</em> can assure that a generic function cannot discover what is the type behind a type variable. Remove the top and the bottom from the language too. You are left with very precise types. As an example,</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a>declare <span class="kw">function</span> someName<span class="op">&lt;</span>T<span class="op">&gt;</span>(t<span class="op">:</span>T)<span class="op">:</span> T</span></code></pre></div>
<p>could be only implemented as an identity. Incidentally, there are a few languages that support strict parametricity and a few that come very close, for mainstream languages, <em>parametricity</em> is an gentlemen’s agreement.</p>
<p>Can you write a whole single page app in TS and give it that signature? I bet you can.<br />
We would probably not call it a type-lie. Calling it not descriptive would probably be more accurate. Or, maybe just not the best design?<br />
If some type definitions are better than others, which of them are better? Apps are written so the decisions are being made, but based on what?</p>
<p>I will give you my very type centric view of programming:</p>
<ol type="1">
<li>Well written program means well typed. Well typed means the types express what is happening.<br />
</li>
<li>Types are more fundamental than a programming language.</li>
<li>Coding conventions supplement the language in implementing typing concepts.</li>
<li>TS (or any programming language) programming needs a balancing act. My approach for writing TS is to balance principled and safe with approachable and informative. That balance is subjective and project specific, my balance point may differ from yours.</li>
</ol>
<p><strong>Expanding on 2:</strong><br />
TS type checks my code, I type check TS (last post). A library (e.g. <em>office.js</em>) provides types, I type check these types and fix some of them (this post). Developer interventions are needed. Understanding of types does not change with a programming language environment. The cumbersomeness of their use does. TS is, comparatively speaking, not that bad.</p>
<p><strong>Expanding on 3:</strong><br />
In TS, almost any program can have almost any type. I can implement</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="kw">function</span> <span class="fu">program</span>()<span class="op">:</span> <span class="kw">void</span> {<span class="op">...</span>}</span></code></pre></div>
<p>and do almost anything I want in that code.<br />
It would not be very clear if most of my types looked like this. There needs to be some coding convention that discourages such code.<br />
Enforcing some level of parametricity when implementing generics is another example of a coding convention.</p>
<p><em>The goal is to move from designing programs to designing types.</em><br />
<em>This post suggests that types are used to define coding conventions.</em></p>
<p>So, besides guarding parametricity, what else can we do? Here are some bootstrapping ideas:</p>
<h3 id="referential-transparency">Referential Transparency</h3>
<p>Referential Transparency is an FP topic but is also very relevant to types and crucially important to the discussion of “type honesty”.</p>
<p>A function is referentially transparent if it does the same thing every time it is called. Referential transparency comes with clear type signatures. The output needs to be a function of the inputs and of nothing else. You can do things like curry or partially apply, but you cannot say, retrieve the current time and act on it (that time parameter would need to be provided as input).<br />
For <code>program:() =&gt; void</code> to be referentially transparent would mean that the implementation does not do anything, just returns.<br />
IMO well written programs identify and separate the referentially transparent parts.</p>
<p>In TS, referential transparency is a coding convention. I will use <em>React.js</em> example to demonstrate this. Readers not familiar with React should think about creating a function from some model (<code>Person</code> in this example) to an actual part of the HTML DOM. Here is my example of a vanilla React component type (I like React to be vanilla as much as possible)</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="kw">const</span> PersonCard<span class="op">:</span> ({ model<span class="op">,</span> onChange }<span class="op">:</span> {</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a>    <span class="dt">model</span><span class="op">:</span> Person<span class="op">;</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a>    <span class="dt">onChange</span><span class="op">:</span> (<span class="dt">_</span><span class="op">:</span> Person) <span class="kw">=&gt;</span> <span class="kw">void</span><span class="op">;</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a>}) <span class="kw">=&gt;</span> JSX<span class="op">.</span><span class="at">Element</span></span></code></pre></div>
<p>Hopefully, the implementation does not use any hooks, it only uses the parameters (I call them setters<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> and getters) to create bits of HTML with event handlers. This would be an example of a referentially transparent React type. It also would be an example of a very explicit type that is very “honest”.</p>
<p> <div class="side-note"><strong>FP side notes:</strong> Such approach is not novel at all (e.g. Elm uses a similar approach, only not as a coding style but as its architecture).<br />
 </div></p>
<p>Many developers will very much disagree with me on this. E.g. many will prefer to encapsulate state handling inside components. I do not intend to argue which approach is better. I will just point out that encapsulation is secretive in the type definition and I am looking for transparency here. Many parts of React code will require some use of hooks, my approach is to do that only when I have to and to keep the hooks outside of my main components. It is not about not using hooks, it is about not having them all over the code base. The goal is to make things very type-explicit. It is an IMO.</p>
<p>Such type is also self documenting.</p>
<p><strong>Expanding on my point 4:</strong> IMO, the best communication tools for developers and the best documenting tools for the code, in that order, are: <em>types and tests</em>. I will only focus on the first.</p>
<h3 id="types-as-documentation">Types as documentation</h3>
<p>When I write TS, I want my types to be very informative. For example, compare these two slightly modified versions of the above React component:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="kw">const</span> PersonCard<span class="op">:</span> React<span class="op">.</span><span class="at">FC</span><span class="op">&lt;</span>{</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a>    <span class="dt">model</span><span class="op">:</span> Person<span class="op">;</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a>    <span class="dt">onChange</span><span class="op">:</span> (<span class="dt">_</span><span class="op">:</span> Person) <span class="kw">=&gt;</span> <span class="kw">void</span><span class="op">;</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a>}<span class="op">&gt;</span></span></code></pre></div>
<p>vs:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="kw">const</span> PersonCard<span class="op">:</span> React<span class="op">.</span><span class="at">FC</span><span class="op">&lt;</span>Props<span class="op">&gt;</span> <span class="co">//Commonly used 'Props' type alias defined next to 'PersonCard'</span></span></code></pre></div>
<p>I like the first one better.<br />
And, I am not suggesting the names for the setters and getters here. I would be equally happy with this:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a><span class="kw">const</span> PersonCard<span class="op">:</span> React<span class="op">.</span><span class="at">FC</span><span class="op">&lt;</span>{</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a>    <span class="dt">get</span><span class="op">:</span> Person<span class="op">;</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a>    <span class="dt">set</span><span class="op">:</span> (<span class="dt">_</span><span class="op">:</span> Person) <span class="kw">=&gt;</span> <span class="kw">void</span><span class="op">;</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true"></a>}<span class="op">&gt;</span></span></code></pre></div>
<p>There is no safety benefit in doing this. Communication, documentation and accessibility are the only goals.<br />
I like to think about a modernized definition of the KISS principle: “Simple” is a lot of very transparent types.</p>
<h2 id="next-chapter">Next Chapter</h2>
<p>There are parts of TS that I absolutely adore and I will talk about them. The complexity of TS types is another big topic to discuss. Complexity causes compilation issues (we will encounter some new bloopers) and makes the language hard to use.</p>
<p>Here is the link: <a href="2022-01-03-ts-types-part3.html" target="_blank">Part 3</a>.</p>
<p>I am working on these notes during the 2021 holiday season. <em>Merry Christmas, Happy New Year!</em> Stay happy and healthy!</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>What I am achieving here is not the full referential transparency. Setters are not referentially transparent, referentially transparent function that returns <code>void</code> cannot do anything. However, This construction is still very explicit.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

    </section>
</article>
]]></summary>
</entry>
<entry>
    <title>Type Enthusiast's Notes about TypeScript. Part 1. Typing in Anger</title>
    <link href="https://rpeszek.github.io//posts/2021-12-12-ts-types-part1.html" />
    <id>https://rpeszek.github.io//posts/2021-12-12-ts-types-part1.html</id>
    <published>2021-12-12T00:00:00Z</published>
    <updated>2021-12-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
    <section class="header">
        Posted on December 12, 2021
        
            by Robert Peszek
        
        
        
        <div class="changelog"> <div>Revision History: <ul> <li> (2021.12.24) modified historical note about office.js. Linked Part 2. Planned future content adjustment.</li> <li> (2021.12.26) <a href="#fn1">footnote [1]</a> <li> (2022.01.03 - Present) Changes are documented in <a href="#summary-of-final-edits">Summary of final edits</a>. </ul> </div></div>
        
        
        <div class="info">Tags: <a title="All pages tagged 'TypeScript-Notes'." href="../tags/TypeScript-Notes.html">TypeScript-Notes</a></div>
        
    </section>
    <section>

    </section>
    <section>
        <div class="toc"><div class="header">Table of Contents</div>
<ul>
<li><a href="#introduction-to-the-series">Introduction to the series</a></li>
<li><a href="#typescript-is-great">TypeScript is great!</a></li>
<li><a href="#office.js.-using-ts-in-anger"><em>office.js</em>. Using TS in anger</a>
<ul>
<li><a href="#happy-path">Happy path</a></li>
<li><a href="#bumps-on-the-path">Bumps on the path</a></li>
<li><a href="#bump-leveling-tools">Bump leveling tools</a></li>
<li><a href="#compilation-bloopers">Compilation bloopers</a></li>
<li><a href="#its-all-worth-it">It’s all worth it</a></li>
</ul></li>
<li><a href="#relevant-typescript-language-tickets">Relevant TypeScript Language tickets</a></li>
<li><a href="#next-chapter">Next Chapter</a></li>
<li><a href="#summary-of-final-edits">Summary of final edits</a></li>
</ul>
</div>
<p><em>Please Leave Feedback in: <a href="https://github.com/rpeszek/rpeszek.github.io/discussions/1" target="_blank">git discussions</a></em></p>
<p><strong>DRAFT version</strong> <em>(I am sorry about any misprints. It seems I have goblins in my laptop that toy with me, remove or change words. When this note disappears, you will know that I gave up.)</em></p>
<p><strong>Disclaimers:</strong> (imagine this is a very small font, read it very fast in a half-whisper)<br />
<em>I assume strict compiler flags are on, something you get by default with scaffolding, e.g. using <code>create-react-app my-project --template typescript</code> is close enough.<br />
The code examples have been tested with TypeScript v4.4.4, v4.5.2, and v4.6.3.<br />
office.js examples are based on <a href="https://appsforoffice.microsoft.com/lib/1.1/hosted/office.js" target="_blank">https://appsforoffice.microsoft.com/lib/1.1/hosted/office.js</a> and <span class="citation" data-cites="types/office-js">@types/office-js</span><span class="citation" data-cites="1.0.221">@1.0.221</span> (these match the current scaffold for office.js/React).<br />
This post is a pandoc conversion of markdown document and code examples are not interactive.<br />
Most of the code examples are published in <a href="https://github.com/rpeszek/ts-experiments/tree/master/ts-notes" target="_blank">ts-notes</a> folder in this github repo: <a href="https://github.com/rpeszek/ts-experiments" target="_blank">ts-experiments</a>.</em></p>
<h2 id="introduction-to-the-series">Introduction to the series</h2>
<blockquote>
<p>“TypeScript began its life as an attempt to bring traditional object-oriented types to JavaScript so that the programmers at Microsoft could bring traditional object-oriented programs to the web. As it has developed, TypeScript’s type system has evolved to model code written by native JavaScripters. The resulting system is <em>powerful, interesting and messy.</em>”</p>
</blockquote>
<p><em>From typescriptlang <a href="https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html" target="_blank">TypeScript for Functional Programmers</a></em></p>
<p>I wanted to write a short post about my experience with TS types, I ended up with a draft the size of a short book. I decided to split it into digestible installments and publish it as a series of shorter posts. The series will be about the <em>powerful, interesting and messy</em> types in TS. This post is the first in that series.</p>
<p>Here is my plan:</p>
<ul>
<li>Part 1 (this post). Is a warm-up. Part 1 has been motivated by a project at my work that uses TS. I will show code examples that are hard to compile. I will discuss strategies and methods for resolving compilation issues. I will present code examples that compile but really, really should not, and code examples that should compile but surprisingly don’t. I will also summarize my overall experience of working with TS.<br />
This series needed a JS library with TS bindings to draw examples from, I decided to use <em>office.js</em> and Part 1 introduces it.</li>
<li><a href="2021-12-24-ts-types-part2.html" target="_blank">Part 2</a>. Will be about keeping types honest. Are runtime values consistent with the types? We hope they always are but, especially in a gradually typed language like TS, types will sometimes lie. We will see concrete examples of type dishonesty from <em>office.js</em>. Part 2 will cover the notorious <code>any</code> and its safer cousin <code>unknown</code>, the type coercion (casting), and TS’s type guards. I will also discuss (or rather rant about) coding conventions for transparent, self documenting types.</li>
<li><a href="2022-01-03-ts-types-part3.html" target="_blank">Part 3</a>. Will cover some of the TS type safety features that I absolutely love. Throughout the series, we will encounter several examples where TS compiler does not work as expected. This part will discuss questionable (and arguably incorrect) semantics of subtyping variance and of narrowing. It will argue that what TS is and does it quite complex. Complexity is the likely cause of errors in TS programs and in the language itself.</li>
<li><a href="2022-01-09-ts-types-part4.html" target="_blank">Part 4</a>, <a href="2022-02-13-ts-types-part5.html" target="_blank">Part 5</a>. Will be more theoretical. Notes in Parts 4-5 will discuss topics such as TS’s structural, recursive types, subtyping, phantom types, type variable scoping, higher-rank polymorphism (TS supports a version of it!), and type level programming. I will show a trick to increase type safety that prevents widening to <code>unknown</code> or other supertypes.<br />
</li>
<li><a href="2022-03-13-ts-types-part6.html" target="_blank">Part 6</a>. Will be a wrap-up with some final thoughts.</li>
</ul>
<p><strong>Why am I writing these notes?</strong><br />
To be honest, it is because I am really impressed and excited about some of the type safety features in TS.</p>
<p>Despite being a superset of JavaScript, TS stands out among mainstream languages as one that supports some interesting types.<br />
There exist a tiny but important feedback loop: the more developers play with types the more they will end up being used.<br />
So, to be perfectly honest, the goal of these notes is to simply play with some interesting types and see how the compiler reacts.</p>
<p>IMO, to master something is to understand its limitations.<br />
So, to be brutally honest, the goal of these notes is to explore the TS compiler limitations.</p>
<p><strong>Target audience and prerequisites.</strong> I assume that the reader is interested in types and either uses or considers using TypeScript.<br />
Types tend to be related to FP. There will not be much FP in these notes. However, I will use some basic functional programming concepts, like currying, without explaining them.<br />
TypeScript is a superset of JavaScript with type syntax very similar to any other C-like language. These notes will probably be hard to read without some experience with JavaScript or ability to read C-like types.</p>
<p><strong>About the author.</strong> I am spearheading a rewrite of a legacy frontend component at work, the goal is to rewrite it using the new React.js and TypeScript. In recent years I have been spending all of my time in the backend designing, writing, and maintaining Haskell programs. Haskell code has a lot of types. Thus, I use types a lot. Types allow me to code faster, safer, and with much more confidence.<br />
I wear a hat with types on it when writing TS.<br />
I love Programming Language Theory and have some experience and lots of interest in compiler and language design.<br />
I wear a very thin headband embroidered with PLT symbols under my hat (should be mostly invisible in this series).<br />
All of this gives me a different (compared to most typescripters) perspective and a reason to write these posts. For some readers, parts of these posts will feel strange. Established practices like overloading will be considered a bad thing, writing experimental code (that won’t even run) to answer <em>type questions</em> will be a good thing. Strange is a corollary of different.</p>
<p><strong>What is TypeScript for?</strong> Is it just a JavaScript add-on used to prevent typos and trivial code errors?<br />
Or, will TypeScript more fundamentally change the way the code is written?<br />
Please have these questions in mind when reading these notes.</p>
<p>We will cover a lot of topics.</p>
<blockquote>
<p>“And we never say anything unless it is worth taking a long time to say.”</p>
</blockquote>
<p><em>J.R.R Tolkien and Treebeard about discussing types in TypeScript</em></p>
<h2 id="typescript-is-great">TypeScript is great!</h2>
<p>It literally took me less than one minute of playing with TS to get excited about it.<br />
Just look at the union types (using a somewhat contrived example):</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>type Person <span class="op">=</span> {<span class="dt">firstNm</span><span class="op">:</span> string<span class="op">,</span> <span class="dt">lastNm</span><span class="op">:</span> string} </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>type NullablePerson <span class="op">=</span> Person <span class="op">|</span> <span class="kw">null</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="kw">const</span> getName <span class="op">=</span> (p<span class="op">:</span>NullablePerson)<span class="op">:</span> string <span class="kw">=&gt;</span> {</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>    <span class="co">//const tst1 = p.firstNm //does not compile</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>    <span class="cf">if</span>(p<span class="op">===</span><span class="kw">null</span>){</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>        <span class="co">//const tst2 = p.firstNm //does not compile</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>        <span class="cf">return</span> <span class="st">&quot;John Smith&quot;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>    } <span class="cf">else</span> {</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a>        <span class="cf">return</span> p<span class="op">.</span><span class="at">firstNm</span> <span class="op">+</span> <span class="st">&quot; &quot;</span> <span class="op">+</span> p<span class="op">.</span><span class="at">lastNm</span> <span class="co">//compiles</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a>    }</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a>}</span></code></pre></div>
<p>How cool!</p>
<p>Talking about my “literal” excitement, my next play example implements <code>Either</code> (I am not trying to implement my own Either type, only to play with the language):</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>type Either<span class="op">&lt;</span>A<span class="op">,</span>B<span class="op">&gt;</span> <span class="op">=</span> </span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="op">|</span> {<span class="dt">type</span><span class="op">:</span> <span class="st">&quot;left&quot;</span><span class="op">,</span> <span class="dt">content</span><span class="op">:</span> A}</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="op">|</span> {<span class="dt">type</span><span class="op">:</span> <span class="st">&quot;right&quot;</span><span class="op">,</span> <span class="dt">content</span><span class="op">:</span> B}</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a><span class="kw">const</span> x1<span class="op">:</span> Either<span class="op">&lt;</span>number<span class="op">,</span> string<span class="op">&gt;</span> <span class="op">=</span> {<span class="dt">type</span><span class="op">:</span> <span class="st">&quot;left&quot;</span><span class="op">,</span> <span class="dt">content</span><span class="op">:</span> <span class="dv">1</span>}</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a><span class="kw">const</span> xone<span class="op">:</span> Either<span class="op">&lt;</span>number<span class="op">,</span> string<span class="op">&gt;</span> <span class="op">=</span> {<span class="dt">type</span><span class="op">:</span> <span class="st">&quot;right&quot;</span><span class="op">,</span> <span class="dt">content</span><span class="op">:</span> <span class="st">&quot;one&quot;</span>}</span></code></pre></div>
<div class="sourceCode" id="cb3"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="dt">const</span> wrong: Either&lt;number, string&gt; = {type: <span class="st">&quot;left&quot;</span>, content: <span class="st">&quot;one&quot;</span>} <span class="co">// does not compile</span></span></code></pre></div>
<p>it almost looks like dependent types! TS calls these literal types. (In this example, <code>"left"</code> is a type with a single value <code>"left": "left"</code>.)<br />
TypeScript calls this programming pattern <em>Discriminated Unions</em>.</p>
<p>And, TS is serious about string property names too:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">const</span> y<span class="op">:</span> Either<span class="op">&lt;</span>number<span class="op">,</span> string<span class="op">&gt;</span> <span class="op">=</span> {<span class="st">&quot;type&quot;</span><span class="op">:</span> <span class="st">&quot;left&quot;</span><span class="op">,</span> <span class="st">&quot;content&quot;</span><span class="op">:</span> <span class="dv">1</span>}</span></code></pre></div>
<div class="sourceCode" id="cb5"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="dt">const</span> wrong: Either&lt;number, string&gt; = {<span class="st">&quot;type&quot;</span>: <span class="st">&quot;left&quot;</span>, <span class="st">&quot;content&quot;</span>: <span class="st">&quot;one&quot;</span>} <span class="co">// does not compile</span></span></code></pre></div>
<p>TypeScript <a href="https://www.npmjs.com/package/ts-pattern" target="_blank"><em>ts-pattern</em></a> library uses discriminated unions to implement <em>pattern matching</em>. Exhaustive check is part of it.<br />
Again, really cool. All of these are really exciting developments to me.</p>
<p>Continuing with play examples, here is the full JSON grammar defined in TS.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>type JsonVal <span class="op">=</span> </span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="op">|</span> {<span class="dt">type</span><span class="op">:</span> <span class="st">&quot;object&quot;</span><span class="op">,</span> <span class="dt">val</span><span class="op">:</span> <span class="bu">Map</span><span class="op">&lt;</span>string<span class="op">,</span> JsonVal<span class="op">&gt;</span>}</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a><span class="op">|</span> {<span class="dt">type</span><span class="op">:</span> <span class="st">&quot;array&quot;</span><span class="op">,</span> <span class="dt">val</span><span class="op">:</span> JsonVal[]}</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a><span class="op">|</span> {<span class="dt">type</span><span class="op">:</span> <span class="st">&quot;string&quot;</span><span class="op">,</span> <span class="dt">val</span><span class="op">:</span> string}</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a><span class="op">|</span> {<span class="dt">type</span><span class="op">:</span> <span class="st">&quot;number&quot;</span><span class="op">,</span> <span class="dt">val</span><span class="op">:</span> number}</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a><span class="op">|</span> {<span class="dt">type</span><span class="op">:</span> <span class="st">&quot;bool&quot;</span><span class="op">,</span> <span class="dt">val</span><span class="op">:</span> boolean}</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a><span class="op">|</span> {<span class="dt">type</span><span class="op">:</span> <span class="st">&quot;null&quot;</span>}</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a><span class="kw">const</span> tstj<span class="op">:</span> JsonVal <span class="op">=</span> {<span class="dt">type</span><span class="op">:</span><span class="st">&quot;array&quot;</span><span class="op">,</span> <span class="dt">val</span><span class="op">:</span>[{<span class="dt">type</span><span class="op">:</span> <span class="st">&quot;null&quot;</span>}<span class="op">,</span> {<span class="dt">type</span><span class="op">:</span> <span class="st">&quot;number&quot;</span><span class="op">,</span> <span class="dt">val</span><span class="op">:</span> <span class="dv">5</span>}]} <span class="co">//compiles</span></span></code></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="dt">const</span> wrong: JsonVal = {type: <span class="st">&quot;number&quot;</span>, val: {type: <span class="st">&quot;string&quot;</span>, val: <span class="st">&quot;5&quot;</span>}} <span class="co">//does not compile, number is not JSON object</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="dt">const</span> wrong2: {type: <span class="st">&quot;object&quot;</span>,  val:[{type: <span class="st">&quot;null&quot;</span>}, {type: <span class="st">&quot;number&quot;</span>, val: <span class="dv">5</span>}]} <span class="co">//does not compile, object is not an array</span></span></code></pre></div>
<p>This could have been expressed with OO classes, but it would not be very easy, would it?<br />
I wrote the <code>JsonVal</code> definition without thinking, I have committed <code>Data.Aeson.Value</code> (Haskell’s commonly used type for JSON values) definition to memory and I just mimicked it. Then I looked at it again … holly … TS supports complex recursive definitions! We will discuss recursive types later in this series.</p>
<p>TypeScript has an ability to do type level programming that goes beyond the demonstrated uses of literal types. All of this is oriented toward creating type safety over various kinds of idiomatic JS code and is limited in scope. It is nonetheless interesting. We will return to this topic in the future as well.</p>
<p>As far as mainstream languages go (I consider <em>Scala</em>, <em>Rust</em>, or <em>Reason</em> a border line just outside the mainstream), TypeScript could be the most interesting choice today IMO.</p>
<p>This was my trailer/preview section. If the code that excited me feels interesting to you, you may enjoy reading these notes. There will be some gory details (not a lot violence). You have to decide if type safety is your genre.<br />
Developers are divided into 2 camps: Those who use types because that is the most effective way to write software and those who do not use types because that is the most effective way to write software. Since you are still reading, I assume you are in camp 1.</p>
<h2 id="office.js.-using-ts-in-anger"><em>office.js</em>. Using TS in anger</h2>
<p>I will use <em>office.js</em> library as a source of examples for this series. It is a Microsoft product (like TypeScript). It comes with TypeScript type definitions (this series uses <span class="citation" data-cites="types/office-js">@types/office-js</span><span class="citation" data-cites="1.0.221">@1.0.221</span>).<br />
Looking into the <em>office.js</em> revision history suggests that the bond between <em>office.js</em> and TypeScript developed very early. It almost looks like these projects grew up together. <em>office.js</em> seems like a good ‘comprehensive’ example for examining the benefits (and frustrations) of using TS in anger.<br />
Despite some hardships, TS makes working with office.js much, much easier!</p>
<p>As the name suggests, <em>office.js</em> provides an API for working with <em>Microsoft Office</em>. It allows implementing custom apps that work inside the office suite of products (Microsoft calls these apps add-ins).<br />
This is not an office.js tutorial but, I hope, the code should be clear to follow even if you never used <em>office.js</em>.</p>
<p>As a working example, we will play with code that extracts data from an email opened in Outlook. To start, I want to extract the email body.<br />
To access data, <em>office.js</em> often uses an old style <code>getAsync</code> methods that I will modernize using a custom conversion to a <code>Promise</code>. Node’s <code>util.promisify</code> will not work well for this task. This is how this could be done in TS:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="co">/* Utility to convert office functions to promises */</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="im">export</span> <span class="kw">const</span> officePromise <span class="op">=</span> <span class="op">&lt;</span>T<span class="op">&gt;</span> (getasync<span class="op">:</span> (fx<span class="op">:</span> (r<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncResult</span><span class="op">&lt;</span>T<span class="op">&gt;</span>) <span class="kw">=&gt;</span> <span class="kw">void</span>) <span class="kw">=&gt;</span> <span class="kw">void</span>)<span class="op">:</span> <span class="bu">Promise</span><span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="kw">=&gt;</span> {</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>    <span class="cf">return</span> <span class="kw">new</span> <span class="bu">Promise</span>((resolve<span class="op">,</span> reject) <span class="kw">=&gt;</span> {</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>      <span class="fu">getasync</span>((<span class="dt">res</span><span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncResult</span><span class="op">&lt;</span>T<span class="op">&gt;</span>) <span class="kw">=&gt;</span> {</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>        <span class="cf">if</span>(res<span class="op">.</span><span class="at">status</span><span class="op">===</span>Office<span class="op">.</span><span class="at">AsyncResultStatus</span><span class="op">.</span><span class="at">Succeeded</span>){</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>          <span class="fu">resolve</span>(res<span class="op">.</span><span class="at">value</span>)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a>      } <span class="cf">else</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a>          <span class="fu">reject</span>(res<span class="op">.</span><span class="at">error</span>)</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a>      })</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a>   })</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a>  }</span></code></pre></div>
<p> <div class="side-note"><strong>Side Note</strong><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>: Here is my first criticism of TS. The ergonomics of function type definitions is IMO really poor. These definitions are hard to read and cumbersome to write. This syntax does not scale well to more involved types and makes reasoning about types harder.<br />
E.g. in the above example parameters <code>fx:</code> and <code>r:</code> cannot be used anywhere (are outside of the lexical scope) and serve only a documentation purpose. This simple example needs 6 parentheses. The use of <code>:</code> and <code>=&gt;</code> is confusing. Function form <code>A</code> to <code>B</code> is (depending where in the declaration) either <code>(a: A) =&gt; B</code> or <code>(a: A): B</code>. I admit it took me a long time to figure out how to write these and it still takes me forever to read some of these types.<br />
Later in this post, I will show some work-arounds that simplify type definitions like this one.<br />
I am adding a big fat <strong>IMO</strong> to this side note, readability is in the eye of … well the reader. But seriously…<br />
 </div></p>
<p>Properly initialized office add-in will have access to <code>Office.context.mailbox.item: Office.MessageRead</code>.<br />
This <code>item</code> object allows access to the email data.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> To retrieve the email body I need to use <code>item.body.getAsync</code>. But wait, the type for that version of <code>getAsync</code> accepts not only a callback function but also a “body type” parameter.</p>
<p>I am going to resist the temptation to overload <code>officePromise</code>. Instead I will move in a direction that is more fundamental.</p>
<p>Assume that we want ‘html’ body format, the code can look something like this:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="co">//retrieving email body, 1st attempt</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a><span class="kw">const</span> bodyType <span class="op">=</span> Office<span class="op">.</span><span class="at">CoercionType</span><span class="op">.</span><span class="at">Html</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a> </span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a><span class="kw">const</span> partiallyAppliedBodyFn <span class="op">=</span> (fn<span class="op">:</span> ((res<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncResult</span><span class="op">&lt;</span>string<span class="op">&gt;</span>) <span class="kw">=&gt;</span> <span class="kw">void</span>)) <span class="kw">=&gt;</span> </span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>     item<span class="op">.</span><span class="at">body</span><span class="op">.</span><span class="fu">getAsync</span>(bodyType<span class="op">,</span> fn) </span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>  </span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a><span class="kw">const</span> body  <span class="op">=</span> <span class="cf">await</span> officePromise<span class="op">&lt;</span>string<span class="op">&gt;</span> (partiallyAppliedBodyFn) <span class="co">// body: string</span></span></code></pre></div>
<p>I had to fully specify the <code>partiallyAppliedBodyFn</code> type for this to work. That looks like a lot of code to just partially apply <code>item.body.getAsync</code>!</p>
<h3 id="happy-path">Happy path</h3>
<p>There are some libraries that offer a <code>curry</code> function conversion, but these are typically JS not TS. So I wrote it myself (again, note the type signature is somewhat hard to read):</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="im">export</span> <span class="kw">const</span> curry <span class="op">=</span> <span class="op">&lt;</span>T1<span class="op">,</span> T2<span class="op">,</span> R<span class="op">&gt;</span> (fn<span class="op">:</span> (ax<span class="op">:</span> T1<span class="op">,</span> bx<span class="op">:</span> T2) <span class="kw">=&gt;</span> R)<span class="op">:</span> (a<span class="op">:</span> T1) <span class="kw">=&gt;</span> (b<span class="op">:</span> T2) <span class="kw">=&gt;</span> R <span class="kw">=&gt;</span> {</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>    <span class="kw">const</span> res <span class="op">=</span> (<span class="dt">a</span><span class="op">:</span> T1) <span class="kw">=&gt;</span> (<span class="dt">b</span><span class="op">:</span> T2) <span class="kw">=&gt;</span> <span class="fu">fn</span>(a<span class="op">,</span> b)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>    <span class="cf">return</span> res</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a> }</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a><span class="kw">const</span> addtst <span class="op">=</span> (a<span class="op">:</span>number<span class="op">,</span> b<span class="op">:</span> number) <span class="kw">=&gt;</span> a <span class="op">+</span> b</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a><span class="kw">const</span> curriedAdd <span class="op">=</span> <span class="fu">curry</span>(addtst) <span class="co">//const curriedAdd: (a: number) =&gt; (b: number) =&gt; number</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a><span class="kw">const</span> tst1 <span class="op">=</span> <span class="fu">curry</span>(addtst)(<span class="dv">1</span>) <span class="co">//const tst1: (b: number) =&gt; number</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a><span class="kw">const</span> tst12 <span class="op">=</span> <span class="fu">curry</span>(addtst)(<span class="dv">1</span>)(<span class="dv">2</span>) <span class="co">//tst12 = 3</span></span></code></pre></div>
<p>And I have a much simpler code that compiles right off the bat:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="co">//Happy path one liner to get email body</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a><span class="co">//body2: string</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a><span class="kw">const</span> body2 <span class="op">=</span> <span class="cf">await</span> <span class="fu">officePromise</span> (<span class="fu">curry</span>(item<span class="op">.</span><span class="at">body</span><span class="op">.</span><span class="at">getAsync</span>)(Office<span class="op">.</span><span class="at">CoercionType</span><span class="op">.</span><span class="at">Html</span>)) </span></code></pre></div>
<p>This worked out quite well and the type checker was able to infer the types!<br />
This ended up being a happy path.</p>
<h3 id="bumps-on-the-path">Bumps on the path</h3>
<p>In practice, the type checker will often need some help. Even more often, the programmer (me) will need help figuring why the code is not compiling.</p>
<p>I will start by presenting code that should compile but it does not.</p>
<p><code>item.body.getAsync</code> offers a 3 parameter overload which accepts additional <code>Office.AsyncContextOptions</code>. Using it is much harder. (I will not delve into what the extra argument is for, I just want to see if my code will compile with 3 parameters)</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="co">//boilerplate 'curry3' implementation is not shown (available in the linked github project), </span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a><span class="co">//it is almost identical to `curry` but accepts a 3 parameter function  </span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a><span class="co">//trying to pass extra parameter to body.getAsync</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a><span class="kw">const</span> emptyConfig<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncContextOptions</span> <span class="op">=</span> {}</span></code></pre></div>
<div class="sourceCode" id="cb13"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="co">//Compilation Error: </span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a><span class="co">//&quot;Argument of type 'AsyncContextOptions' is not assignable to parameter of type '(asyncResult: AsyncResult&lt;string&gt;) =&gt; void'.&quot; </span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a><span class="dt">const</span> body3  = await <span class="fu">officePromise</span> (<span class="fu">curry3</span>(item.<span class="fu">body</span>.<span class="fu">getAsync</span>)(Office.<span class="fu">CoercionType</span>.<span class="fu">Html</span>)(emptyConfig)) </span></code></pre></div>
<p>To understand what is happening, I sometimes need to spend time annotating things, or picking up the exact overload I want. E.g.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="kw">const</span> useThisAsync <span class="op">=</span> (coercionType<span class="op">:</span> Office<span class="op">.</span><span class="at">CoercionType</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>                     <span class="op">,</span> options<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncContextOptions</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>                     <span class="op">,</span> callback<span class="op">:</span> (asyncResult<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncResult</span><span class="op">&lt;</span>string<span class="op">&gt;</span>) <span class="kw">=&gt;</span> <span class="kw">void</span>)<span class="op">:</span> <span class="kw">void</span> <span class="kw">=&gt;</span> {</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a>      item<span class="op">.</span><span class="at">body</span><span class="op">.</span><span class="fu">getAsync</span>(coercionType<span class="op">,</span> options<span class="op">,</span> callback)</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>    }</span></code></pre></div>
<p>This can be tedious, but it typically gets the job done. In this particular case, using <code>curry3(useThisAsync)</code> fixes the <code>body3</code> (or the “3 body”, I just had to pun this) problem. So, the issue with <code>body3</code> code appears to be related to overloading.</p>
<p>Looking closer at the types, I notice that not only <code>item.body.getAsync</code> has two overloads, but the one I want is accepting a union type argument and the callback is optional:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="co">//from office.js documentation</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a><span class="co">//2 parameter overload used in happy path</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a><span class="fu">getAsync</span>(coercionType<span class="op">:</span> Office<span class="op">.</span><span class="at">CoercionType</span> <span class="op">|</span> string</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a>  <span class="op">,</span> callback<span class="op">?:</span> (asyncResult<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncResult</span><span class="op">&lt;</span>string<span class="op">&gt;</span>) <span class="kw">=&gt;</span> <span class="kw">void</span>)<span class="op">:</span> <span class="kw">void</span><span class="op">;</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true"></a><span class="co">//3 parameter overload we are trying to use now</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true"></a><span class="fu">getAsync</span>(coercionType<span class="op">:</span> Office<span class="op">.</span><span class="at">CoercionType</span> <span class="op">|</span> string<span class="op">,</span> </span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true"></a>        options<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncContextOptions</span><span class="op">,</span> </span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true"></a>        callback<span class="op">?:</span> (asyncResult<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncResult</span><span class="op">&lt;</span>string<span class="op">&gt;</span>) <span class="kw">=&gt;</span> <span class="kw">void</span>)<span class="op">:</span> <span class="kw">void</span><span class="op">;</span></span></code></pre></div>
<p>So there are sort of <em>overloads on top of overloads</em> and the type checker could get confused. In fact the case here is much simpler, TS inference tends to pick the last defined overload (see <a href="https://github.com/rpeszek/typescript-issues/blob/master/src/RejectingCorrectCode/RejectingOverloads.ts" target="_blank">this code example</a> and (<a href="https://github.com/microsoft/TypeScript/issues/43187" target="_blank">#43187</a>). The compilation error also suggests that the compiler gets stuck on a wrong (the 2 parameter) version of <code>getAsync</code> despite the use of the 3 parameter <code>curry3</code>. I will also confirm this hypothesis using a <em>type hole</em> (we will learn what that is) in the next section.<br />
I expect the type checker to backtrack and try the next overload, but for some reason it does not want to do that on its own.<br />
I do not blame TS, overloading gives me a headache too.<br />
Overloading is known for being not type inference friendly (incidentally, that is the reason why Haskell does not overload names).</p>
<p>There is something worryingly asymmetric about a 2 parameter overload compiling without additional help and a 3 parameter overload needing a developer intervention. Should I worry<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> that the 2 parameter overload will stop compiling in the future? How stable is this arbitrary complexity?</p>
<p><em>If you are an API owner, my advice is to not overload. IntelliSense works better, type inference works better, developer head hurts less without overloads.</em></p>
<p>One type that is notorious for needing annotations is the TypeScript’s <em>tuple</em>. Typescript overloads array syntax <code>[]</code> to define tuples (some readers may prefer the term heterogeneous lists). This is an example of a tuple: <code>[2,"two"]: [number, string]</code>. The syntax overloading probably does not help TS in inferring the type and the type checker often gives up or infers the array type.</p>
<p>I am concerned that <strong>many developers will give up</strong> trying to write this type of code. My concern is also that developers will resort to unsafe type coercion / type casting. There will be a lot of <code>myvar as IWantIt</code>, or a lot of the <code>any</code> type.</p>
<p> <div class="side-note"><strong>Side note:</strong> I can push this code to a ridiculous limit and <strong>demonstrate the first example of code compiles but I would not expect it to</strong>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="co">//this compiles by using a wrong input parameter type and returns 'body4: unknown'</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a><span class="kw">const</span> crazyConfig <span class="op">:</span> (_<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncResult</span><span class="op">&lt;</span>string<span class="op">&gt;</span>) <span class="kw">=&gt;</span> <span class="kw">void</span> <span class="op">=</span> x <span class="kw">=&gt;</span> <span class="st">&quot;&quot;</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a><span class="kw">const</span> body4 <span class="op">=</span> <span class="cf">await</span> <span class="fu">officePromise</span> (<span class="fu">curry3</span>(item<span class="op">.</span><span class="at">body</span><span class="op">.</span><span class="at">getAsync</span>)(Office<span class="op">.</span><span class="at">CoercionType</span><span class="op">.</span><span class="at">Html</span>)(crazyConfig)) </span></code></pre></div>
<p>Accepting invalid <code>unknown</code> appears to be a common pattern to how TS sometimes works. We will come back to this example later in this post and we will discuss the <code>unknown</code> problem more in future notes.<br />
 </div></p>
<p>Was this enough gore for you? You say it was not? I say you did not see the content of that email!</p>
<h3 id="bump-leveling-tools">Bump leveling tools</h3>
<h4 id="readable-type-definitions">Readable Type Definitions</h4>
<p>Cumbersome type annotations are not a good excuse to give up! There is a way to simplify function type definitions. For example, I can define a helper alias:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="co">//DIY reusable type for Office getAsync callbacks</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a><span class="im">export</span> type OfficeCallack<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">=</span> (_<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncResult</span><span class="op">&lt;</span>T<span class="op">&gt;</span>) <span class="kw">=&gt;</span> <span class="kw">void</span></span></code></pre></div>
<p>Here is how this simplifies the previously defined <code>partiallyAppliedBodyFn</code>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="co">//before:</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a><span class="kw">const</span> partiallyAppliedBodyFn1 <span class="op">=</span> (fn<span class="op">:</span> ((res<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncResult</span><span class="op">&lt;</span>string<span class="op">&gt;</span>) <span class="kw">=&gt;</span> <span class="kw">void</span>)) <span class="kw">=&gt;</span> item<span class="op">.</span><span class="at">body</span><span class="op">.</span><span class="fu">getAsync</span>(Office<span class="op">.</span><span class="at">CoercionType</span><span class="op">.</span><span class="at">Html</span><span class="op">,</span> fn) </span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a><span class="co">//after:</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a><span class="kw">const</span> partiallyAppliedBodyFn2 <span class="op">=</span> (fn<span class="op">:</span> OfficeCallack<span class="op">&lt;</span>string<span class="op">&gt;</span>) <span class="kw">=&gt;</span> item<span class="op">.</span><span class="at">body</span><span class="op">.</span><span class="fu">getAsync</span>(Office<span class="op">.</span><span class="at">CoercionType</span><span class="op">.</span><span class="at">Html</span><span class="op">,</span> fn)</span></code></pre></div>
<p>Notice <strong>no more redundant parameter definitions</strong> in the type signature and a much easier to read syntax.<br />
The next version is <strong>my personal preference</strong> (it nicely separates the type and the implementation)<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="kw">const</span> partiallyAppliedBodyFn3<span class="op">:</span> (_<span class="op">:</span> OfficeCallack<span class="op">&lt;</span>string<span class="op">&gt;</span>) <span class="kw">=&gt;</span> <span class="kw">void</span> <span class="op">=</span> </span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a>  fn <span class="kw">=&gt;</span> item<span class="op">.</span><span class="at">body</span><span class="op">.</span><span class="fu">getAsync</span>(Office<span class="op">.</span><span class="at">CoercionType</span><span class="op">.</span><span class="at">Html</span><span class="op">,</span> fn)</span></code></pre></div>
<h4 id="type-application">Type Application</h4>
<p>Returning to my failed <code>body3</code> example, instead of trying to type annotate with full type signatures, it is sometimes more convenient to apply the types. Here, I have the “generic” (or polymorphic) <code>curry3</code> function that I can apply the types <code>CoercionType</code>, <code>AsyncContextOptions</code>, <code>OfficeCallack&lt;string&gt;</code>, and <code>void</code> to:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="co">//type applied version, it just compiles!</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a><span class="kw">const</span> emptyConfig<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncContextOptions</span> <span class="op">=</span> {}</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a><span class="kw">const</span> body3  <span class="op">=</span> <span class="cf">await</span> officePromise<span class="op">&lt;</span>string<span class="op">&gt;</span> (</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a>  curry3<span class="op">&lt;</span>Office<span class="op">.</span><span class="at">CoercionType</span><span class="op">,</span> Office<span class="op">.</span><span class="at">AsyncContextOptions</span><span class="op">,</span> OfficeCallack<span class="op">&lt;</span>string<span class="op">&gt;,</span> <span class="kw">void</span><span class="op">&gt;</span> <span class="co">//explicity specified type parameters</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a>     (item<span class="op">.</span><span class="at">body</span><span class="op">.</span><span class="at">getAsync</span>)</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true"></a>     (Office<span class="op">.</span><span class="at">CoercionType</span><span class="op">.</span><span class="at">Html</span>)</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true"></a>     (emptyConfig)</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true"></a>  ) </span></code></pre></div>
<p>That is so much easier than specifying the exact <code>useThisAsync</code> overload!</p>
<h4 id="type-holes">Type Holes</h4>
<p>A DIY type hole technique is sometimes useful to help figure out stubborn types (see <a href="https://dev.to/gcanti/type-holes-in-typescript-2lck" target="_blank">Type holes in TS</a>).</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="co">//genric (why not say polymorphic) bottom function will allow me to ask type questions</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a><span class="im">export</span> <span class="kw">const</span> _ <span class="op">=</span> <span class="op">&lt;</span>T<span class="op">&gt;</span>()<span class="op">:</span> T <span class="kw">=&gt;</span> {</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a>    <span class="cf">throw</span> <span class="kw">new</span> <span class="bu">Error</span>(<span class="st">&quot;hole&quot;</span>)<span class="op">;</span> </span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a>}</span></code></pre></div>
<p>A type hole allows me to ask the compiler <em>type questions</em>.<br />
You can learn a lot about how the type checker works using it. E.g. using my <code>Either</code> type as an example:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="kw">const</span> tstnum<span class="op">:</span> Either<span class="op">&lt;</span>number<span class="op">,</span> string<span class="op">&gt;</span> <span class="op">=</span> {<span class="dt">type</span><span class="op">:</span> <span class="st">&quot;left&quot;</span><span class="op">,</span> <span class="dt">content</span><span class="op">:</span> <span class="fu">_</span>()}</span></code></pre></div>
<p>if you hover over <code>_</code> you will see</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a>(alias) _<span class="op">&lt;</span>number<span class="op">&gt;</span>()<span class="op">:</span> number</span></code></pre></div>
<p>Nice! If you hover over <code>_</code> in this expression</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="kw">const</span> str <span class="op">=</span> <span class="st">&quot;Hello &quot;</span> <span class="op">+</span> <span class="fu">_</span>()</span></code></pre></div>
<p>you will see</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a>(alias) _<span class="op">&lt;</span>unknown<span class="op">&gt;</span>()<span class="op">:</span> unknown</span></code></pre></div>
<p>This can provide a lot of insight into types and how TS uses them!</p>
<p>I have not been very lucky in using type holes to figure out why TS is confused. Returning to my failed <code>body3</code> example:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a><span class="co">//body3 inferred type is 'unknown'</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a><span class="kw">const</span> body3  <span class="op">=</span> <span class="cf">await</span> <span class="fu">officePromise</span> (<span class="fu">curry3</span> (item<span class="op">.</span><span class="at">body</span><span class="op">.</span><span class="at">getAsync</span>)(Office<span class="op">.</span><span class="at">CoercionType</span><span class="op">.</span><span class="at">Html</span>)(<span class="fu">_</span>())) </span></code></pre></div>
<p>if I hover over the <code>_</code> function, the IntelliSense suggests this completely wrong type:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a>(alias) _<span class="op">&lt;</span>((asyncResult<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncResult</span><span class="op">&lt;</span>string<span class="op">&gt;</span>) <span class="kw">=&gt;</span> <span class="kw">void</span>) <span class="op">|</span> <span class="kw">undefined</span><span class="op">&gt;</span>()<span class="op">:</span> ((asyncResult<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncResult</span><span class="op">&lt;</span>string<span class="op">&gt;</span>) <span class="kw">=&gt;</span> <span class="kw">void</span>) <span class="op">|</span> <span class="kw">undefined</span></span></code></pre></div>
<p>The type hole confirms that the compiler is trying to match against the two parameter overload of <code>item.body.getAsync</code>. This confirms my hypothesis from the last section that what made TS confused here was the overloading. There are a few things to note here:</p>
<ul>
<li>We are asking TS “why are you confused?” and that is a funny question.</li>
<li>This type hole did not tell us more than the compilation error message itself. However, the type hole is more targeted so it could reveal more specific information in some cases.</li>
<li>Type holes may tell us something useful in situations where the code compiles but we do not understand why.</li>
</ul>
<p>If, as before, I add the type application (<code>&lt;Office.CoercionType, Office.AsyncContextOptions, OfficeCallack&lt;string&gt;, void&gt;</code>) to <code>curry3</code> the <code>_()</code> will show the type correctly:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a>(alias) _<span class="op">&lt;</span>Office<span class="op">.</span><span class="at">AsyncContextOptions</span><span class="op">&gt;</span>()<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncContextOptions</span></span></code></pre></div>
<p><strong>About some limitations</strong><br />
Sadly, the <code>_&lt;T&gt;(): T</code> is not universally useful, e.g. this will not compile:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a><span class="co">//compilation error: </span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true"></a><span class="co">//       Argument of type '(ax: never, bx: never) =&gt; never' is not assignable </span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true"></a><span class="co">//       to parameter of type '(ax: unknown, bx: unknown) =&gt; unknown'.</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true"></a><span class="dt">const</span> testfn = <span class="fu">curry</span>(_()) </span></code></pre></div>
<div class="sourceCode" id="cb30"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a><span class="co">//interestingly the following compiles as curry&lt;unknown, unknown, unknown&gt;</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true"></a><span class="kw">const</span> testfn <span class="op">=</span> <span class="fu">curry</span>({} <span class="im">as</span> any)</span></code></pre></div>
<p>TS type checker does not work with type variables at the top level. That makes testing expressions like <code>curry(_())</code> rather pointless. The following compiles just fine, and would be a good (not very useful but good) choice for the inferred type of <code>_()</code>:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true"></a>type GenFn2Type <span class="op">=</span> (ax<span class="op">:</span> never<span class="op">,</span> bx<span class="op">:</span> never) <span class="kw">=&gt;</span> unknown</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true"></a></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true"></a><span class="kw">const</span> compiles <span class="op">=</span> <span class="fu">curry</span>(_<span class="op">&lt;</span>GenFn2Type<span class="op">&gt;</span>()) </span></code></pre></div>
<p>but TS fails instead of inferring that type.</p>
<p>There is an interesting relationship between the <code>never</code> type and <code>_&lt;T&gt;(): T</code>. There will be a future note about it.<br />
The type hole <code>_</code> function is a useful tool and we will keep using it in future type explorations.</p>
<p>Using types requires some experience, knowledge, and patience. More advanced types come with more misleading error messages, it takes experience to find the underlying cause of a misleading compilation error, and that is true in any language. Eventually, I (and you) will look at a TS compilation error and will say “ah, you really meant this: …”.</p>
<p>I am mostly left to my own devices when working with more involved types in TS. Hopefully the future will bring us mainstream grade interactive tools that allow asking type questions, browsing types, and help solving type puzzles. For now it is mostly the programmer who connects the dots.<br />
The good news is that this gets easier and easier with practice. I have been working in TS for only about 2 months now and I already see a difference.</p>
<p><em>Good code requires two type checkers: TypeScript and You</em></p>
<h3 id="compilation-bloopers">Compilation bloopers</h3>
<p>We already saw “correct” programs that should have compiled but did not (e.g. <code>curry(_())</code>, <code>body3</code> example) and we will see more in the future notes. Our <code>body4</code> example compiled but it was a bug.<br />
This note shows other, less contrived, examples that compile and are clearly bugs.</p>
<p>All of these type check:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true"></a><span class="co">//annotated correct code added for reference, this code compiles</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true"></a><span class="kw">const</span> good<span class="op">:</span> (a<span class="op">:</span> Office<span class="op">.</span><span class="at">CoercionType</span>) </span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true"></a>          <span class="kw">=&gt;</span> (b<span class="op">:</span> ((asyncResult<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncResult</span><span class="op">&lt;</span>string<span class="op">&gt;</span>) <span class="kw">=&gt;</span> <span class="kw">void</span>)) </span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true"></a>          <span class="kw">=&gt;</span> <span class="kw">void</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true"></a>    <span class="op">=</span> <span class="fu">curry</span> (item<span class="op">.</span><span class="at">body</span><span class="op">.</span><span class="at">getAsync</span>)</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true"></a></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true"></a><span class="co">//compiles but it should not, compiles even with type annotation</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true"></a><span class="kw">const</span> nonsense1<span class="op">:</span> (a<span class="op">:</span> Office<span class="op">.</span><span class="at">CoercionType</span>) </span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true"></a>          <span class="kw">=&gt;</span> (b<span class="op">:</span> ((asyncResult<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncResult</span><span class="op">&lt;</span>string<span class="op">&gt;</span>) <span class="kw">=&gt;</span> <span class="kw">void</span>)) </span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true"></a>          <span class="kw">=&gt;</span> <span class="kw">void</span></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true"></a>    <span class="op">=</span> <span class="fu">curry</span> (<span class="fu">curry</span> (item<span class="op">.</span><span class="at">body</span><span class="op">.</span><span class="at">getAsync</span>)) </span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true"></a></span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true"></a><span class="co">//compiles but it should not</span></span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true"></a><span class="kw">const</span> nonsense2 <span class="op">=</span> <span class="fu">curry</span>(curry)</span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true"></a></span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true"></a><span class="co">//... more examples in the linked github project</span></span></code></pre></div>
<p>and all, except the first one, are bugs.<br />
One pattern is clearly visible: <code>unknown</code> somewhere in the type<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>.<br />
The underlying reason seems to be much simpler: TS does not exactly match the types of parameters that are functions. The underlying reason is that <a href="https://github.com/Microsoft/TypeScript/wiki/FAQ#why-are-functions-with-fewer-parameters-assignable-to-functions-that-take-more-parameters" target="_blank">functions with fewer parameters are assignable to functions that take more parameters</a><a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true"></a>declare <span class="kw">function</span> <span class="fu">testfn</span>(fn<span class="op">:</span> (str<span class="op">:</span>string) <span class="kw">=&gt;</span> number)<span class="op">:</span>number</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true"></a></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true"></a><span class="co">//compiles, calculated type is: const num: number</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true"></a><span class="kw">const</span> num <span class="op">=</span> <span class="fu">testfn</span>(() <span class="kw">=&gt;</span> <span class="dv">1</span>)</span></code></pre></div>
<p>IMO this language design decision can lead to very confusing escaped bugs and it smells like subtyping<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>. Higher order functions are not uncommon in JavaScript. The <code>nonsense1</code> example is a piece of code I accidentally wrote in my project.<br />
This is very concerning since errors like these are likely to remain uncaught and become escaped bugs.<br />
Careful reader will notice that my <code>body4</code> example is a perfect storm. Here it is again:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a><span class="co">//this compiles by using a wrong input parameter type and returns 'body4: unknown'</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true"></a><span class="kw">const</span> crazyConfig <span class="op">:</span> (_<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncResult</span><span class="op">&lt;</span>string<span class="op">&gt;</span>) <span class="kw">=&gt;</span> <span class="kw">void</span> <span class="op">=</span> x <span class="kw">=&gt;</span> <span class="st">&quot;&quot;</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true"></a><span class="kw">const</span> body4 <span class="op">=</span> <span class="cf">await</span> <span class="fu">officePromise</span> (<span class="fu">curry3</span>(item<span class="op">.</span><span class="at">body</span><span class="op">.</span><span class="at">getAsync</span>)(Office<span class="op">.</span><span class="at">CoercionType</span><span class="op">.</span><span class="at">Html</span>)(crazyConfig)) </span></code></pre></div>
<p>TS picks a (wrong) 2 parameter overload of <code>item.body.getAsync</code> because it was defined last by <em>office.js</em>. It assigns it to <code>curry3</code> because <code>curry3</code> expects a 3 parameter function and 2 &lt; 3 is OK.<br />
Sadly, accepting <code>body4</code> code is TypeScript “Working as Intended” (<a href="https://github.com/microsoft/TypeScript/issues/43187" target="_blank">#43187</a>, <a href="https://github.com/microsoft/TypeScript/issues/48624" target="_blank">#48624</a>).</p>
<p>Compared to other programming languages I use, TS’s rate of compiler issues I encounter is much higher, the issues are more dangerous, and are likely to happen on more commonly used vanilla code (well… at least commonly used by me).<br />
I can see two general reasons for this: gradual typing on top of JS is not easy, subtyping is not easy. I plan to write a note about the complexity of TS types in a future post.</p>
<h3 id="its-all-worth-it">It’s all worth it</h3>
<p>One common concern related to using types (especially more advanced types) is a slowdown in the development speed.<br />
There is some truth to this in general because of things like compilation times in some language environments. I cannot comment on TS compilation times for large projects, so far it is not a problem for me. In my experience, having a type checker is a huge productivity bust. In my experience, the more types the faster the development speed. That is true even with compilation bloopers.<br />
Efficiency considerations are somewhat personal so your experience may vary.</p>
<p>I rewrote some legacy code using the techniques in this section. That effort resulted in significant size reduction and an overall big improvement in readability and correctness when compared to the code I was replacing or to code in the <em>office.js</em> documentation.<br />
A lot of the improvement comes from using <code>await</code> <code>async</code> syntax sugar but converting functions to their curried form and figuring out more terse ways to type annotate also results in added clarity and significant syntactic simplification.</p>
<p>In my book, there is just no comparing TS to JS, TS is the clear winner.<br />
How does TS compare to statically type checked frontend languages that compile to JS and have capable type checkers and solid types (e.g. Reason, Elm, PureScript, even Haskell)? I am not in a good position to discuss this yet.<br />
Lots of projects need to stay close to JS, my project at work falls into this group. For such projects TS is the right choice IMO.</p>
<h2 id="relevant-typescript-language-tickets">Relevant TypeScript Language tickets</h2>
<ul>
<li><a href="https://github.com/microsoft/TypeScript/issues/43187" target="_blank">#43187</a> the overloading issue (type inference considers the last overload only) has been known and has been marked as “Docs”.</li>
<li><a href="https://github.com/microsoft/TypeScript/issues/48624" target="_blank">#48624</a> (I entered it) about my blooper examples has been marked as “Working as Intended”</li>
<li><a href="https://github.com/microsoft/TypeScript/issues/48625" target="_blank">#48625</a> <code>curry(_())</code> not compiling issue (I entered it) has been marked as “Working as Intended”</li>
</ul>
<h2 id="next-chapter">Next Chapter</h2>
<p>We are not done with <em>office.js</em>. I will use it in future notes.</p>
<p>Do statically defined types reflect the actual runtime values? How to assure that they do?<br />
We will discuss these questions in the next installment. Here is the link: <a href="2021-12-24-ts-types-part2.html" target="_blank">Part 2. Typing Honestly</a></p>
<h2 id="summary-of-final-edits">Summary of final edits</h2>
<p>Added context to <a href="#bumps-on-the-path">bumps on the path</a> section about type inference not working well with overloaded methods.</p>
<p>Added context to why <code>curry(_())</code> is not compiling.</p>
<p>Added context to <a href="#compilation-bloopers">compilation bloopers</a> section explaining the underlying reason for TS accepting my blooper examples: TS allows to assign a function with fewer parameters to a function type with more parameters. The arity does not need to match.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>I rewrote the side note and improved <code>officePromise</code> type definition based on a <a href="https://www.reddit.com/r/typescript/comments/rnougu/comment/hptsnvg/?utm_source=share&amp;utm_medium=web2x&amp;context=3" target="_blank">comment</a> from <em>u/Tubthumper8</em> on reddit. Thanks!<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>The situation is just slightly more complicated since the <code>item</code> property is overloaded but that is not important for now.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>As the previously linked <a href="https://github.com/rpeszek/typescript-issues/blob/master/src/RejectingCorrectCode/RejectingOverloads.ts" target="_blank">example</a> shows, I indeed should worry.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>It should be noted that with this syntax type variables will be defined in the <em>lhs</em> of the definition and will be outside of the lexical scope in the <em>rhs</em>. You would have to re-declare them which makes this approach much less usable in the presence of type variables.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p><code>nonsense1</code> will will show <code>unknown</code> if you remove the type annotation.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>This took me a long time to figure out and was added late.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>In fact it is subtyping. In TS <code>() =&gt; number</code> extends <code>(_:string) =&gt; number</code>.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

    </section>
</article>
]]></summary>
</entry>
<entry>
    <title>Probability Tree Diagrams. Recursion Schemes. Why Finding the Right Solution is Sometimes Hard?</title>
    <link href="https://rpeszek.github.io//posts/2021-07-18-prob-tree-scheme.html" />
    <id>https://rpeszek.github.io//posts/2021-07-18-prob-tree-scheme.html</id>
    <published>2021-07-18T00:00:00Z</published>
    <updated>2021-07-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
    <section class="header">
        Posted on July 18, 2021
        
            by Robert Peszek
        
        
          <br /> Last Modified on Jul 18, 2021
        
        
        <div class="changelog"> <div>Revision History: <ul> <li> (2021.07.24-25) Fixed/Reworked `cata` examples (per <a target="_blank" href="https://www.reddit.com/r/haskell/comments/onrhtw/probability_tree_diagrams_recursion_schemes_why/h684cpr?utm_source=share&utm_medium=web2x&context=3">r/Tarmen</a>) and changed definition of example tree. </ul> </div></div>
        
        
        <div class="info">Tags: <a title="All pages tagged 'Haskell'." href="../tags/Haskell.html">Haskell</a></div>
        
    </section>
    <section>

    </section>
    <section>
        <div class="toc"><div class="header">Table of Contents</div>
<ul>
<li><a href="#the-problem">The Problem</a>
<ul>
<li><a href="#why-is-this-useful">Why is this useful?</a></li>
<li><a href="#plumbing">Plumbing</a></li>
<li><a href="#example-tree">Example Tree</a></li>
<li><a href="#traditional-solution-state-threads">Traditional Solution, State Threads</a></li>
<li><a href="#simple-recursion-schemes">Simple Recursion Schemes</a></li>
</ul></li>
<li><a href="#why-finding-the-right-solution-is-sometimes-hard">Why Finding the Right Solution is Sometimes Hard?</a>
<ul>
<li><a href="#human-condition">Human condition</a></li>
<li><a href="#time-pressure">Time Pressure</a></li>
<li><a href="#large-bag-of-tricks">Large Bag of Tricks</a></li>
<li><a href="#not-exactly-muscle-memory">Not exactly Muscle Memory</a></li>
<li><a href="#cookie-cutters">Cookie cutters</a></li>
<li><a href="#summary-1">Summary</a></li>
</ul></li>
</ul>
</div>
<p>Code for this project can be found in my <a href="https://github.com/rpeszek/experiments" target="_blank">experiments</a> github repo (<a href="https://github.com/rpeszek/experiments/tree/master/probability-tree-schemes" target="_blank">probability-tree-schemes</a> folder).</p>
<p>The goal of this post is to present a simple example that uses recursion schemes. My other goal is to discuss my thoughts about reasons for getting stuck on finding the right solution. It will be a bit of a rant.</p>
<p><strong>Motivation:</strong><br />
Last week I encountered a programming problem that kept defeating me. It took me forever just to figure out how to translate the requirements into something I can code. The gist of this problem turned out to be very straightforward: implement a probability tree diagram (a decision tree annotated with probabilities). Well not really, but close enough.<br />
I think, now, that the problem is simple, but it was not the case during the few hours I initially have spent on it. This experience was somewhat surprising to me as I have worked for several years with decision graphs (not trees, but still). I just I failed to make the association.</p>
<p>I am sharing my experience in this post. This post shows the solution program, and as such, ended up becoming a “tutorial” of sorts about the recursion schemes. I tried to make it easy to read even if some Haskell code is more at an intermediate level. In this tutorial I will get in trouble couple of times arriving at an incorrect solution.</p>
<p>At the end of this post (<a href="#why-finding-the-right-solution-is-sometimes-hard">Why Finding the Right Solution is Sometimes Hard?</a>) I rant about my beliefs pertaining to the question in the title.</p>
<h2 id="the-problem">The Problem</h2>
<p>Consider a tree with edges (or nodes) annotated with probability weights. The problem I am going to solve is simple: calculate the path likelihoods for each of the <em>leaves</em>. Basically multiply all the probabilities down each branch all the way to the leaf.</p>
<p>This is obviously not so hard, and the biggest challenge was to figure out that this was what the requirements needed.<br />
The solution seems like a good exercise and I am sharing my solutions here.</p>
<p>All the goodies (<code>a</code>) are at the leaves, in addition, each node is annotated with some probability <code>p</code> and a label <code>String</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">Data.Functor.Foldable.TH</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">ProbTree</span> p a <span class="ot">=</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>    <span class="dt">Leaf</span> p <span class="dt">String</span> a</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>    <span class="op">|</span> <span class="dt">Branches</span> p <span class="dt">String</span> [<span class="dt">ProbTree</span> p a]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>    <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Traversable</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>makeBaseFunctor '<span class="dt">'ProbTree</span></span></code></pre></div>
<p>The goal is implement a function that transforms <code>ProbTree NodeProb a</code> into <code>ProbTree CumulativeProb a</code>.</p>
<p>I will be using <a href="https://hackage.haskell.org/package/recursion-schemes" target="_blank"><em>recursion-schemes</em></a> package and <code>makeBaseFunctor</code> generates the code I will need to fold or unfold the tree. All the instances I have declared, <code>Functor, Foldable, Traversable</code>, are intended for the consumption of the goodies <code>a</code>. I will not care much about <code>a</code>-s in this post. I will care about the <code>p</code>-s.</p>
<p>This type is really a <code>Bifunctor</code> (Functor in both <code>p</code> and <code>a</code>), and most of the code I am going to show could just use that. Instead of implementing <code>Bifunctor</code> instance I will use:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.List</span> <span class="kw">as</span> <span class="dt">L</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="ot">probMap ::</span> (p1 <span class="ot">-&gt;</span> p2) <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> p1 a <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> p2 a</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>probMap fn (<span class="dt">Leaf</span> p l a) <span class="ot">=</span> <span class="dt">Leaf</span> (fn p) l a</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>probMap fn (<span class="dt">Branches</span> p l xs) <span class="ot">=</span> <span class="dt">Branches</span> (fn p) l <span class="op">$</span> L.map (probMap fn) xs</span></code></pre></div>
<p>However, for some examples I will need something stronger, I need it to be <code>Traversable</code> in <code>p</code>.<br />
I will just use the <a href="https://hackage.haskell.org/package/lens" target="_blank"><em>lens</em></a> package to get what I need. You do not need to know much about lenses to read on. I will try to explain the usage as I go.</p>
<p>Keeping <code>p</code> as a type variable is convenient and, for example, could allow me to use it for (<code>Natural</code>) distribution counts or other things that probabilities can morph into.</p>
<h3 id="why-is-this-useful">Why is this useful?</h3>
<p>Decision Trees are popular because of their ability to visualize outcomes of various processes.<br />
It is sometimes useful to know the distribution of the final outcomes. Think about using <em>QuickCheck</em> to randomly generate final outcomes or, maybe, randomly pick these outcomes from some big dataset of samples.<br />
<code>ProbTree p a</code> would use <code>a</code> to hold the generated values or to describe them in some way. It is convenient to keep the data samples <code>a</code> separate from probabilities <code>p</code> (instead of just using something like <code>RoseTree (p,a)</code>) because we care about these samples only at the final outcome / leaf level.<br />
The extra <code>String</code> label is for my own convenience. It allows me to trace how the recursion schemes work and will be handy in this presentation.<br />
<code>ProbTree p a</code> may not be the nicest to use when implementing recursion-schemes. All the better as the choice of training!</p>
<h3 id="plumbing">Plumbing</h3>
<p>So I have a lens that will let me ‘focus’ on the <code>p</code>-s:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">Control.Lens</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a><span class="co">-- | needs to be non-polymorphic because of nesting</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a><span class="ot">probability ::</span> <span class="dt">Lens'</span> (<span class="dt">ProbTree</span> p a) p</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>probability <span class="ot">=</span> lens get set </span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>    get (<span class="dt">Leaf</span> p _ _) <span class="ot">=</span> p</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>    get (<span class="dt">Branches</span> p _ _) <span class="ot">=</span> p</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>    set (<span class="dt">Leaf</span> _ l x) r <span class="ot">=</span> <span class="dt">Leaf</span> r l x</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a>    set (<span class="dt">Branches</span> _ l x) r <span class="ot">=</span> <span class="dt">Branches</span> r l x</span></code></pre></div>
<p>It is considered a bad karma to use Record syntax for types that have several constructors. So I coded this by hand. Otherwise template Haskell <code>makeLenses</code> could create <code>probability</code> if both constructors had a field with the same name <code>_probability :: p</code>. If you new to lenses, think that the above code <em>encapsulates</em> getting and setting <code>p</code>-s.<br />
This thing is what is called a simple lens. That means it does not allow me to change the <code>p</code> type. I will need something more flexible than that(<code>makeLenses</code> does not create what I need anyway).</p>
<p>In a dream, dependently typed, world there would be a type level guarantee that in <code>Branches (p1 :: p) String [ProbTree (pn :: p) a]</code> we have <code>1 ~ sum pn</code> for probability weights and <code>p1 ~ sum pn</code> for cumulative case.<br />
In reality, it would be nice to, at least, not use <code>p ~ Float</code> all the time.<br />
Since I will be changing the meaning of what <code>p</code> is from a probability assigned to a node to calculated cumulative probability of getting to this node:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">NodeProb</span> <span class="ot">=</span> <span class="dt">NodeProb</span> {<span class="ot">unNodeProb ::</span> <span class="dt">Float</span>} <span class="kw">deriving</span> <span class="dt">Eq</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">CumulativeProb</span> <span class="ot">=</span> <span class="dt">CumulativeProb</span> {<span class="ot">unCumulativeProb ::</span> <span class="dt">Float</span>} <span class="kw">deriving</span> <span class="dt">Eq</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a><span class="co">-- Show instances implemented, but not shown (pun not intended)</span></span></code></pre></div>
<p>To deal with swapping <code>p</code>’s I need to implement an honest to god traversal. Consider this as just a boilerplate:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="ot">probabilityT ::</span> <span class="kw">forall</span> p r a f <span class="op">.</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> </span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>    (p <span class="ot">-&gt;</span> f r) </span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>    <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> p a </span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>    <span class="ot">-&gt;</span> f (<span class="dt">ProbTree</span> r a)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>probabilityT fn (<span class="dt">Leaf</span> p l a) <span class="ot">=</span> <span class="dt">Leaf</span> <span class="op">&lt;$&gt;</span> fn p <span class="op">&lt;*&gt;</span> <span class="fu">pure</span> l <span class="op">&lt;*&gt;</span> <span class="fu">pure</span> a</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>probabilityT fn (<span class="dt">Branches</span> p l xs) <span class="ot">=</span> <span class="dt">Branches</span> <span class="op">&lt;$&gt;</span> fn p <span class="op">&lt;*&gt;</span> <span class="fu">pure</span> l <span class="op">&lt;*&gt;</span> fx xs</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>  <span class="kw">where</span><span class="ot"> fx ::</span> [<span class="dt">ProbTree</span> p a] <span class="ot">-&gt;</span> f [<span class="dt">ProbTree</span> r a]</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>        fx xs <span class="ot">=</span> <span class="fu">traverse</span> (probabilityT fn) xs</span></code></pre></div>
<p>Now I can implement cumulative probabilities working with <code>Float</code>s and expose them to external code using more descriptive types (<em>lens</em> <a href="https://hackage.haskell.org/package/lens-5.0.1/docs/Control-Lens-Iso.html"><code>Iso</code></a>-s would be nicer, this seems to work better in the context of this post):</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="ot">compWithFloats ::</span> </span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>   (<span class="dt">ProbTree</span> <span class="dt">Float</span> a <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">Float</span> a) </span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>   <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">NodeProb</span> a </span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>   <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">CumulativeProb</span> a</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>compWithFloats fn <span class="ot">=</span> over probabilityT <span class="dt">CumulativeProb</span> <span class="op">.</span> fn <span class="op">.</span> over probabilityT unNodeProb</span></code></pre></div>
<h3 id="example-tree">Example Tree</h3>
<p>I am now in the position to define a simple example tree:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="ot">exTree ::</span> <span class="dt">ProbTree</span> <span class="dt">NodeProb</span> ()</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>exTree <span class="ot">=</span> over probabilityT <span class="dt">NodeProb</span> <span class="op">$</span> <span class="dt">Branches</span> <span class="dv">1</span> <span class="st">&quot;R&quot;</span> [</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>   <span class="dt">Branches</span> <span class="fl">0.5</span> <span class="st">&quot;1&quot;</span> [</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>      <span class="dt">Branches</span> <span class="fl">0.5</span> <span class="st">&quot;11&quot;</span> [</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>          <span class="dt">Leaf</span> <span class="fl">0.5</span> <span class="st">&quot;111&quot;</span> ()</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a>          , <span class="dt">Leaf</span> <span class="fl">0.5</span> <span class="st">&quot;112&quot;</span> ()</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a>       ]</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>       , <span class="dt">Branches</span> <span class="fl">0.5</span> <span class="st">&quot;12&quot;</span> [</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>          <span class="dt">Leaf</span> <span class="dv">1</span> <span class="st">&quot;121&quot;</span> ()</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a>       ]</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a>   ]</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a>   , <span class="dt">Branches</span> <span class="fl">0.5</span> <span class="st">&quot;2&quot;</span> [</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true"></a>      <span class="dt">Leaf</span> <span class="fl">0.2</span> <span class="st">&quot;21&quot;</span> ()</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true"></a>      , <span class="dt">Leaf</span> <span class="fl">0.4</span> <span class="st">&quot;22&quot;</span> ()</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true"></a>      , <span class="dt">Branches</span> <span class="fl">0.4</span> <span class="st">&quot;23&quot;</span> [</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true"></a>          <span class="dt">Leaf</span> <span class="fl">0.5</span> <span class="st">&quot;231&quot;</span> ()</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true"></a>          , <span class="dt">Leaf</span> <span class="fl">0.5</span> <span class="st">&quot;232&quot;</span> ()</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true"></a>       ]</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true"></a>   ]</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true"></a> ]</span></code></pre></div>
<p>the lens <code>over</code> allows me to type the Floats and <code>map</code> these to the <code>NodeProb</code> type to indicate what the numbers represent at the type level. I will use this example moving forward. The final result (leaves only) of what I want to compute annotated with labels should look like this:</p>
<pre><code>&quot;(0.125,&quot;111&quot;),(0.125,&quot;112&quot;),(0.25,&quot;121&quot;),(0.1,&quot;21&quot;),(0.2,&quot;22&quot;),(0.1,&quot;231&quot;),(0.1,&quot;232&quot;)&quot;</code></pre>
<h3 id="traditional-solution-state-threads">Traditional Solution, State Threads</h3>
<p>There is a good possibility of finding a ready solution for the problem on <em>stackoverflow</em> or even in <em>wikipedia</em>.<br />
The code in some psedo-language that mutates variables would look something like:</p>
<pre><code>// some C-like language
// mutate in-place all probabilities on all nodes on a tree. 

calculateProbNode (weight, node) = 
   node.prob = weight * node.prob
   children = node.children
   for (child :: children) {
     calculateProb (node.prob, child)
   } 

calcuateProb (node) =  calculateProbNode (1, node)    </code></pre>
<p>Since I moved to Haskell, code like this started to scare me. It mutates things, returns nothing, and it is easy to get it wrong.<br />
However, there are reasons (e.g. performance) when code like this is needed.<br />
There it the misconceptions about Haskell not being able to mutate variables. In particular, variable mutation in internal implementation that leads to a referentially transparent result can be even implemented as a pure function. The tooling for this is called <code>ST</code> monad.</p>
<p>This is the above code implemented in Haskell:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">Control.Monad.ST</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">Data.STRef</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">MutableFloat</span> s <span class="ot">=</span> <span class="dt">STRef</span> s <span class="dt">Float</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a><span class="ot">computeProbMutable ::</span> <span class="kw">forall</span> a <span class="op">.</span> <span class="dt">ProbTree</span> <span class="dt">NodeProb</span> a <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">CumulativeProb</span> a </span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a>computeProbMutable <span class="ot">=</span> compWithFloats (</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a>    \t <span class="ot">-&gt;</span> runST <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a>        mutable <span class="ot">&lt;-</span> makeMutable t </span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true"></a>        mutableres <span class="ot">&lt;-</span> recursion <span class="dv">1</span> mutable</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true"></a>        makeNonMutable mutableres</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true"></a>    )</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true"></a> <span class="kw">where</span> </span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true"></a><span class="ot">   recursion ::</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> (<span class="dt">MutableFloat</span> s) a <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">ProbTree</span> (<span class="dt">MutableFloat</span> s) a)   </span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true"></a>   recursion n (<span class="dt">Branches</span> mutp l xs)  <span class="ot">=</span> <span class="kw">do</span> </span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true"></a>     modifySTRef mutp (n <span class="op">*</span>) <span class="co">-- modify probability in place</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true"></a>     n1 <span class="ot">&lt;-</span> readSTRef mutp   <span class="co">-- read modified probablity</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true"></a>     xs1 <span class="ot">&lt;-</span> <span class="fu">mapM</span> (recursion n1) xs <span class="co">-- recursively apply modified value to children</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true"></a>     <span class="fu">return</span> <span class="op">$</span> <span class="dt">Branches</span> mutp l xs1  </span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true"></a></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true"></a>   recursion n x<span class="op">@</span>(<span class="dt">Leaf</span> mutp _ _) <span class="ot">=</span> <span class="kw">do</span> </span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true"></a>     modifySTRef mutp (n <span class="op">*</span>)  <span class="co">-- on Leaf there is not much to do, only modify the propability</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true"></a>     <span class="fu">return</span> x</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true"></a></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true"></a><span class="co">-- | Traverse all Tree nodes and replace Float's with `MutableFloat`-s.</span></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true"></a><span class="ot">makeMutable ::</span> <span class="dt">ProbTree</span> <span class="dt">Float</span> a <span class="ot">-&gt;</span>  <span class="dt">ST</span> s (<span class="dt">ProbTree</span> (<span class="dt">MutableFloat</span> s) a)</span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true"></a>makeMutable <span class="ot">=</span>  </span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true"></a>   traverseOf probabilityT (newSTRef <span class="op">@</span><span class="dt">Float</span>)</span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true"></a></span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true"></a><span class="co">-- | Traverse all Tree nodes and replace `MutableFloat`-s with not mutable regular `Float`s</span></span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true"></a><span class="ot">makeNonMutable ::</span>  <span class="dt">ProbTree</span> (<span class="dt">MutableFloat</span> s) a <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">ProbTree</span> <span class="dt">Float</span> a) </span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true"></a>makeNonMutable <span class="ot">=</span> traverseOf probabilityT readSTRef</span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true"></a></span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt; tstMutable</span></span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true"></a><span class="co">-- &quot;(0.125,\&quot;111\&quot;,()),(0.125,\&quot;112\&quot;,()),(0.25,\&quot;121\&quot;,()),(0.1,\&quot;21\&quot;,()),(0.2,\&quot;22\&quot;,()),(0.1,\&quot;231\&quot;,()),(0.1,\&quot;232\&quot;,())&quot;</span></span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true"></a><span class="ot">tstMutable ::</span> <span class="dt">String</span></span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true"></a>tstMutable <span class="ot">=</span> printLeaves <span class="op">$</span> computeProbMutable exTree  </span></code></pre></div>
<p>The bulk of the code is translating from not mutable Haskell to mutable variable <code>type MutableFloat s = STRef s Float</code>. The rest is very similar to the psedo-code above.</p>
<p>If you are not familiar with <code>ST</code>, the <code>s</code> is existential and prevents mutable Floats from escaping the <code>ST</code> Monad. You can use them inside <code>ST</code> but not after you leave it.</p>
<p>What is mind-blowing to me is that Haskell introduced this in 1993! Now such existential tricks are used a lot (e.g. in dependently typed code) so the concept probably does not need much introduction.</p>
<h3 id="simple-recursion-schemes">Simple Recursion Schemes</h3>
<p>The above solution leaves a bad taste in my mouth. The idea I will pursue is that I can compute these values by <em>folding</em> or maybe <em>unfolding</em> the tree. This example uses the <a href="https://hackage.haskell.org/package/recursion-schemes" target="_blank"><em>recursion-schemes</em></a> package. I am not going to delve deep into recursion schemes. My goal is to show the code with high level explanations for how and why it works.</p>
<p>Great information about some of the category theoretical background can be found in Bartosz Milewski’s <a href="https://bartoszmilewski.com/2017/02/28/f-algebras/" target="_blank">CTFP Book, F-Algebras secion</a>.<br />
There is a series of blogs devoted to recursion-schemes by Patrick Thomson that are very good reading as well <a href="https://blog.sumtypeofway.com/posts/introduction-to-recursion-schemes.html" target="_blank">An Introduction to Recursion Schemes</a>.</p>
<p><strong>Quick intro to recursion-schemes.</strong></p>
<p>The Template Haskell instruction, <code>makeBaseFunctor ''ProbTree</code>, we have started with generated a new type that looks like this:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">ProbTreeF</span> p a r <span class="ot">=</span> <span class="dt">LeafF</span> p <span class="dt">String</span> a <span class="op">|</span> <span class="dt">BranchesF</span> p <span class="dt">String</span> [r]</span></code></pre></div>
<p>As you can see, <code>ProbTreeF</code> is very similar to <code>ProbTree</code>, except the original ‘recursive’ <code>ProbTree p a</code> in <code>Branches p String [ProbTree p a]</code> got replaced with a new type variable <code>r</code> in <code>BranchesF p String [r]</code>.</p>
<p><em>recursion_schemes</em> uses <code>Base t</code> type family and <code>ProbTreeF p a r</code> is the <em>Base</em> functor for <code>ProbTree</code>.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Base</span><span class="ot"> t ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Base</span> (<span class="dt">ProbTree</span> p a) <span class="ot">=</span> <span class="dt">ProbTreeF</span> p a</span></code></pre></div>
<p>and the library uses <code>Base</code> in all of its definitions. I will use <code>ProbTreeF</code> for clarity.</p>
<p>Classic recursion scheme code often starts with the base functor and derives the recursive target type by applying <a href="https://hackage.haskell.org/package/data-fix-0.3.1/docs/Data-Fix.html#g:1" target="_blank"><em>Fix</em></a> from <a href="https://hackage.haskell.org/package/data-fix" target="_blank"><code>data-fix</code></a>. Both are isomorphic:</p>
<pre><code>Fix (ProbTreeF p a) =~ ProbTree p a</code></pre>
<p>If this is new to you it will take some time digest. (<strong>end</strong>)</p>
<h4 id="catamorphism">Catamorphism</h4>
<p>As a warm-up let’s fold the tree by collecting information about leaves onto a single String:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="ot">printLeaves ::</span> <span class="kw">forall</span> p a<span class="op">.</span> (<span class="dt">Show</span> p, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">ProbTree</span> p a <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>printLeaves <span class="ot">=</span> fold fn</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a><span class="ot">      fn ::</span> <span class="dt">ProbTreeF</span> p a <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>      fn (<span class="dt">LeafF</span> n lb a) <span class="ot">=</span> <span class="fu">show</span> (n, lb, a)</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a>      fn (<span class="dt">BranchesF</span> _ _ xs) <span class="ot">=</span> L.intercalate <span class="st">&quot;,&quot;</span> xs</span></code></pre></div>
<p>This code folds the tree onto a String by spelling out the <code>LeafF</code> content and then by concatenating the strings using comma when processing <code>BranchesF</code>.</p>
<p><strong>Back to a quick into:</strong><br />
The <em>Base</em> functor for <em>List</em> (i.e. <code>[]</code>) looks like this:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">ListF</span> a b <span class="ot">=</span> <span class="dt">Nil</span> <span class="op">|</span> <span class="dt">Cons</span> a b </span></code></pre></div>
<p>folding a list would amount to:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="ot">printList ::</span> (<span class="dt">Show</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>printList <span class="ot">=</span> fold fn</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a><span class="ot">      fn ::</span> <span class="dt">ListF</span> a <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>      fn <span class="dt">Nil</span> <span class="ot">=</span> <span class="st">&quot;(START)&quot;</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a>      fn (<span class="dt">Cons</span> a str) <span class="ot">=</span> <span class="fu">show</span> a <span class="op">&lt;&gt;</span> <span class="st">&quot;:&quot;</span> <span class="op">&lt;&gt;</span> str</span></code></pre></div>
<p>compare it to</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>printList' <span class="ot">=</span> L.foldr (\a str <span class="ot">-&gt;</span> <span class="fu">show</span> a <span class="op">&lt;&gt;</span> <span class="st">&quot;,&quot;</span> <span class="op">&lt;&gt;</span> str) <span class="st">&quot;(START)&quot;</span> </span></code></pre></div>
<p>These are effectively the same!</p>
<p>Ability to fold arbitrary recursive data is rely very convenient. For example, JSON data served by some micro-services may lack consistency (not all micro-services are implemented in Haskell, you know)</p>
<blockquote>
<p>“What if I told you it is possible to fold JSON values?”</p>
</blockquote>
<p>Morpheus, The Matrix</p>
<p><em>recursion-schemes</em> defines <em>cata</em> as an alternative name for <em>fold</em>. <em>cata</em> seems to be more popular and stands for <em>catamorphism</em>. (<strong>end</strong>)</p>
<p><strong>Continuing the warm-up:</strong></p>
<p>We can do effectful things too!</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="ot">printIO ::</span> <span class="kw">forall</span> p a<span class="op">.</span> (<span class="dt">Show</span> p, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">ProbTree</span> p a <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">String</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a>printIO <span class="ot">=</span> fold fn</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a><span class="ot">      fn ::</span> <span class="dt">ProbTreeF</span> p a (<span class="dt">IO</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">String</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a>      fn (<span class="dt">LeafF</span> n lb a) <span class="ot">=</span> <span class="kw">do</span> </span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a>          <span class="fu">print</span> (n, lb, a) <span class="co">-- as before</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true"></a>          <span class="fu">return</span> <span class="op">$</span> <span class="st">&quot;done leaf &quot;</span> <span class="op">&lt;&gt;</span> lb</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true"></a>      fn (<span class="dt">BranchesF</span> _ lb ixs) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true"></a>           xs <span class="ot">&lt;-</span> <span class="fu">sequence</span> ixs</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true"></a>           <span class="fu">print</span> <span class="op">$</span> <span class="st">&quot;Processed so far: &quot;</span> <span class="op">++</span> <span class="fu">show</span> xs</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true"></a>           <span class="fu">return</span> <span class="op">$</span> <span class="st">&quot;done branch &quot;</span> <span class="op">&lt;&gt;</span> lb</span></code></pre></div>
<p>This will print content of leaves, when processing branches will print what it processed before.</p>
<p>It produces this output:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="op">*</span><span class="dt">Schemes</span><span class="op">&gt;</span> tstPrintIO</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a>(<span class="fl">0.5</span>,<span class="st">&quot;111&quot;</span>,())</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a>(<span class="fl">0.5</span>,<span class="st">&quot;112&quot;</span>,())</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a><span class="st">&quot;Processed so far: [\&quot;done leaf 111\&quot;,\&quot;done leaf 112\&quot;]&quot;</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a>(<span class="fl">1.0</span>,<span class="st">&quot;121&quot;</span>,())</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true"></a><span class="st">&quot;Processed so far: [\&quot;done leaf 121\&quot;]&quot;</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true"></a><span class="st">&quot;Processed so far: [\&quot;done branch 11\&quot;,\&quot;done branch 12\&quot;]&quot;</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true"></a>(<span class="fl">0.2</span>,<span class="st">&quot;21&quot;</span>,())</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true"></a>(<span class="fl">0.4</span>,<span class="st">&quot;22&quot;</span>,())</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true"></a>(<span class="fl">0.5</span>,<span class="st">&quot;231&quot;</span>,())</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true"></a>(<span class="fl">0.5</span>,<span class="st">&quot;232&quot;</span>,())</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true"></a><span class="st">&quot;Processed so far: [\&quot;done leaf 231\&quot;,\&quot;done leaf 232\&quot;]&quot;</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true"></a><span class="st">&quot;Processed so far: [\&quot;done leaf 21\&quot;,\&quot;done leaf 22\&quot;,\&quot;done branch 23\&quot;]&quot;</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true"></a><span class="st">&quot;Processed so far: [\&quot;done branch 1\&quot;,\&quot;done branch 2\&quot;]&quot;</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true"></a><span class="st">&quot;done branch R&quot;</span></span></code></pre></div>
<h4 id="solution-using-anamorphism">Solution using Anamorphism</h4>
<p>Instead of using <code>fold</code> / <code>cata</code>-morphism, I will first use its opposite: <code>unfold</code> / <code>ana</code>-morphism to solve the problem of computing the commutative probabilities.<br />
We will solve the problem by unfolding the tree onto itself (I will be constructing <code>ProbTreeF</code>).<br />
<em>recusion-schemes</em> provides a convenient <code>project</code> function that typically can be used to implement all the uninteresting cases when unfolding the structure onto itself:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt; printLeaves . computeProb $ exTree</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a><span class="co">-- &quot;(0.125,\&quot;111\&quot;,()),(0.125,\&quot;112\&quot;,()),(0.25,\&quot;121\&quot;,()),(0.1,\&quot;21\&quot;,()),(0.2,\&quot;22\&quot;,()),(0.1,\&quot;231\&quot;,()),(0.1,\&quot;232\&quot;,())&quot;</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a><span class="ot">computeProb ::</span> <span class="dt">ProbTree</span> <span class="dt">NodeProb</span> a <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">CumulativeProb</span> a</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a>computeProb <span class="ot">=</span> compWithFloats (unfold fn)</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true"></a><span class="ot">    fn ::</span> <span class="dt">ProbTree</span> <span class="dt">Float</span> a <span class="ot">-&gt;</span> <span class="dt">ProbTreeF</span> <span class="dt">Float</span> a (<span class="dt">ProbTree</span> <span class="dt">Float</span> a)</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true"></a>    fn (<span class="dt">Branches</span> n l xs) <span class="ot">=</span> <span class="dt">BranchesF</span> n l (L.map (over probability (<span class="op">*</span> n)) xs)</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true"></a>    fn x <span class="ot">=</span> project x</span></code></pre></div>
<p>the only interesting case is unfolding the <code>Branches n l xs</code> constructor. It is unfolded into <code>BranchesF n l xs'</code> where <code>xs'</code> is a list of children with probability modified by the current value on the branch. This line makes the computation flow towards the leaves. Thus, we can assume that the current probability value <code>n</code> has been already computed.</p>
<p>Note that to test print the outcome, we have unfolded the tree in <code>computeProb</code> and then folded it using <code>printLeaves</code> there is a convenience function <code>hylo</code> or <code>refold</code> included in <em>recursion-schemes</em> package that does exactly that.</p>
<h4 id="back-to-catamorphism.">Back to Catamorphism.</h4>
<p>(EDITED, previous version of this post had it wrong, thanks <a href="https://www.reddit.com/r/haskell/comments/onrhtw/probability_tree_diagrams_recursion_schemes_why/h684cpr?utm_source=share&amp;utm_medium=web2x&amp;context=3" target="_blank">r/Tarmen</a>)</p>
<p>In the previous section, I have unfolded the tree onto itself. That did not really unfold or construct much as the unfolding type was the tree itself. We can as well try the same trick using <code>cata</code> or <code>fold</code>, since we will not be destroying / folding much either.</p>
<p><em>recusion-schemes</em> provides a convenient <code>embed</code> function that typically can be used to implement all the uninteresting cases:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="co">-- |</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt; printLeaves . computeProbBad $ exTree</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a><span class="co">-- &quot;(0.25,\&quot;111\&quot;,()),(0.25,\&quot;112\&quot;,()),(0.5,\&quot;121\&quot;,()),(0.1,\&quot;21\&quot;,()),(0.2,\&quot;22\&quot;,()),(0.2,\&quot;231\&quot;,()),(0.2,\&quot;232\&quot;,())&quot;</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a><span class="ot">computeProbBad ::</span> <span class="dt">ProbTree</span> <span class="dt">NodeProb</span> a <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">CumulativeProb</span> a</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a>computeProbBad <span class="ot">=</span> compWithFloats (cata fn)</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true"></a><span class="ot">      fn ::</span> <span class="dt">ProbTreeF</span> <span class="dt">Float</span> a (<span class="dt">ProbTree</span> <span class="dt">Float</span> a) <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">Float</span> a</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true"></a>      fn (<span class="dt">BranchesF</span> n l xs) <span class="ot">=</span> <span class="dt">Branches</span> n l (L.map (over probability (<span class="op">*</span> n)) xs)</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true"></a>      fn x <span class="ot">=</span> embed x</span></code></pre></div>
<p>notice there is a problem, the numbers are off. The problem is subtle. The <em>lens</em> over just modifies the current node, what we want is to apply the probability modification to the whole subtree:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt; printLeaves . computeProbCata $ exTree</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a><span class="co">-- &quot;(0.125,\&quot;111\&quot;,()),(0.125,\&quot;112\&quot;,()),(0.25,\&quot;121\&quot;,()),(0.1,\&quot;21\&quot;,()),(0.2,\&quot;22\&quot;,()),(0.1,\&quot;231\&quot;,()),(0.1,\&quot;232\&quot;,())&quot;</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a><span class="ot">computeProbCata ::</span> <span class="dt">ProbTree</span> <span class="dt">NodeProb</span> a <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">CumulativeProb</span> a</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a>computeProbCata <span class="ot">=</span> compWithFloats (cata fn)</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true"></a><span class="ot">      fn ::</span> <span class="dt">ProbTreeF</span> <span class="dt">Float</span> a (<span class="dt">ProbTree</span> <span class="dt">Float</span> a) <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">Float</span> a</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true"></a>      fn (<span class="dt">BranchesF</span> n l xs) <span class="ot">=</span> <span class="dt">Branches</span> n l (L.map (probMap (<span class="op">*</span> n)) xs)</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true"></a>      fn x <span class="ot">=</span> embed x</span></code></pre></div>
<p>This works, but it is interesting to play little more with folding just to see how else I can get in trouble.</p>
<h4 id="st-example">ST Example</h4>
<p><strong>Bad attempt:</strong></p>
<p>If you looked closely at the <code>printIO</code> example in the <a href="#catamorphism">Catamorphism</a> section, you may have noticed that that the fold of <code>Branches</code> was able to do effecty things on the children. We can use the same approach to our advantage.<br />
We will go into a mutating franzy and fold <code>ProbTree</code> into just <code>MutableFloat s</code>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="ot">computeSTBad ::</span> <span class="kw">forall</span> s a <span class="op">.</span> <span class="dt">ProbTree</span> (<span class="dt">ST</span> s (<span class="dt">MutableFloat</span> s)) a <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">MutableFloat</span> s)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a>computeSTBad <span class="ot">=</span> fold fn</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a><span class="ot">      fn ::</span> <span class="dt">ProbTreeF</span> (<span class="dt">ST</span> s (<span class="dt">MutableFloat</span> s)) a (<span class="dt">ST</span> s (<span class="dt">MutableFloat</span> s)) <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">MutableFloat</span> s)</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a>      fn (<span class="dt">LeafF</span> n _ _) <span class="ot">=</span> n</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true"></a></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true"></a>      fn (<span class="dt">BranchesF</span> stmn lb ixs) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true"></a><span class="ot">           mn ::</span> <span class="dt">MutableFloat</span> s <span class="ot">&lt;-</span> stmn</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true"></a><span class="ot">           n ::</span> <span class="dt">Float</span> <span class="ot">&lt;-</span> readSTRef mn <span class="co">-- read branch proability</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true"></a><span class="ot">           mxs ::</span> [<span class="dt">MutableFloat</span> s] <span class="ot">&lt;-</span> <span class="fu">sequence</span> ixs <span class="co">-- get access to mutable probablities for direct children </span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true"></a>           <span class="fu">mapM_</span> (<span class="ot">`modifySTRef`</span> (n <span class="op">*</span>)) mxs <span class="co">-- mutate the children's probabilities (This even sounds wrong!)</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true"></a>           stmn <span class="co">-- return back the untouched branch probability</span></span></code></pre></div>
<p>Making this into a pure function requires even crazier mutations (this reuses previously defined <code>makeMutable</code> and <code>makeNonMutable</code>):</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="ot">computeProbMutableBad ::</span> <span class="kw">forall</span> a <span class="op">.</span> <span class="dt">ProbTree</span> <span class="dt">NodeProb</span> a <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">CumulativeProb</span> a</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a>computeProbMutableBad <span class="ot">=</span> compWithFloats (</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a>    \t <span class="ot">-&gt;</span> runST <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a>        mutable <span class="ot">&lt;-</span> makeMutable t</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a>        mutable' <span class="ot">&lt;-</span> traverseOf probabilityT (<span class="fu">pure</span> <span class="op">.</span> <span class="fu">pure</span>) mutable</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true"></a>        computeSTBad mutable'</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true"></a>        makeNonMutable mutable</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true"></a>    )</span></code></pre></div>
<p>the result of <code>computeST mutable</code> is discarded, and I use <code>pure . pure</code> (double effectful?), how crazy is that!</p>
<p>But, we see exactly the same issue as with our naive <code>cata</code> attempt in the previous section:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a><span class="co">-- |</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt; tstMutableBad</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a><span class="co">-- &quot;(0.25,\&quot;111\&quot;,()),(0.25,\&quot;112\&quot;,()),(0.5,\&quot;121\&quot;,()),(0.1,\&quot;21\&quot;,()),(0.2,\&quot;22\&quot;,()),(0.2,\&quot;231\&quot;,()),(0.2,\&quot;232\&quot;,())&quot;</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true"></a><span class="ot">tstMutableBad ::</span> <span class="dt">String</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true"></a>tstMutableBad <span class="ot">=</span> printLeaves <span class="op">$</span> computeProbMutableBad exTree</span></code></pre></div>
<p>This approach applies the correction to probabilities of the node children. We need to apply the correction all the way down the child subtree!</p>
<p><strong>So let’s fix it:</strong></p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a><span class="ot">computeST ::</span> <span class="kw">forall</span> s a <span class="op">.</span> <span class="dt">ProbTree</span> (<span class="dt">ST</span> s (<span class="dt">MutableFloat</span> s)) a <span class="ot">-&gt;</span> <span class="dt">ST</span> s [<span class="dt">MutableFloat</span> s]</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a>computeST <span class="ot">=</span> fold fn</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true"></a><span class="ot">      fn ::</span> <span class="dt">ProbTreeF</span> (<span class="dt">ST</span> s (<span class="dt">MutableFloat</span> s)) a (<span class="dt">ST</span> s [<span class="dt">MutableFloat</span> s]) <span class="ot">-&gt;</span> <span class="dt">ST</span> s [<span class="dt">MutableFloat</span> s]</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true"></a>      fn (<span class="dt">LeafF</span> n _ _) <span class="ot">=</span>  (<span class="op">:</span>[]) <span class="op">&lt;$&gt;</span> n</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true"></a>      </span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true"></a>      fn (<span class="dt">BranchesF</span> stmn lb ixs) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true"></a><span class="ot">        mn ::</span> <span class="dt">MutableFloat</span> s <span class="ot">&lt;-</span> stmn</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true"></a><span class="ot">        n ::</span> <span class="dt">Float</span> <span class="ot">&lt;-</span> readSTRef mn <span class="co">-- read branch proability</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true"></a><span class="ot">        mxs ::</span> [<span class="dt">MutableFloat</span> s] <span class="ot">&lt;-</span> <span class="fu">concat</span> <span class="op">&lt;$&gt;</span> <span class="fu">sequence</span> ixs <span class="co">-- get access to mutable probablities for children </span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true"></a>        <span class="fu">mapM_</span> (<span class="ot">`modifySTRef`</span> (n <span class="op">*</span>)) mxs <span class="co">-- mutate the subtree's probabilities </span></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true"></a>        <span class="fu">pure</span> <span class="op">$</span> mn <span class="op">:</span> mxs <span class="co">--return all mutable floats, including the current node</span></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true"></a></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true"></a><span class="ot">computeProbMutable ::</span> <span class="kw">forall</span> a <span class="op">.</span> <span class="dt">ProbTree</span> <span class="dt">NodeProb</span> a <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">CumulativeProb</span> a</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true"></a>computeProbMutable <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true"></a></span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true"></a><span class="co">-- |</span></span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt; tstMutable</span></span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true"></a><span class="co">-- &quot;(0.125,\&quot;111\&quot;,()),(0.125,\&quot;112\&quot;,()),(0.25,\&quot;121\&quot;,()),(0.1,\&quot;21\&quot;,()),(0.2,\&quot;22\&quot;,()),(0.1,\&quot;231\&quot;,()),(0.1,\&quot;232\&quot;,())&quot;</span></span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true"></a><span class="ot">tstMutable ::</span> <span class="dt">String</span></span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true"></a>tstMutable <span class="ot">=</span> printLeaves <span class="op">$</span> computeProbMutable exTree</span></code></pre></div>
<p>It works! The trick was to change to folding structure to accumulate all mutable floats for the whole subtree and keep mutating them.<br />
The key is to find the correct structure to fold onto.</p>
<p>I do not like code like this type of code, but, I think, it does provide interesting imperative intuitions about the recursive fold.</p>
<h4 id="catamorphism.-reader-example.">Catamorphism. Reader Example.</h4>
<p>But there is a nice solution that learns from the previous <code>ST</code> example and is very close to the idea of folding the tree onto itself:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">Control.Monad.Reader</span> </span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt; printLeaves . computeProbRdr $ exTree</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true"></a><span class="co">-- &quot;(0.125,\&quot;111\&quot;,()),(0.125,\&quot;112\&quot;,()),(0.25,\&quot;121\&quot;,()),(0.1,\&quot;21\&quot;,()),(0.2,\&quot;22\&quot;,()),(0.1,\&quot;231\&quot;,()),(0.1,\&quot;232\&quot;,())&quot;</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true"></a><span class="ot">computeProbRdr ::</span> <span class="dt">ProbTree</span> <span class="dt">NodeProb</span> a <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">CumulativeProb</span> a</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true"></a>computeProbRdr <span class="ot">=</span> compWithFloats (\t <span class="ot">-&gt;</span> runReader (computePropRdr t) <span class="dv">1</span>)</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true"></a></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true"></a><span class="ot">computePropRdr ::</span> <span class="dt">ProbTree</span> <span class="dt">Float</span> a <span class="ot">-&gt;</span> <span class="dt">Reader</span> <span class="dt">Float</span> (<span class="dt">ProbTree</span> <span class="dt">Float</span> a)</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true"></a>computePropRdr <span class="ot">=</span> cata fn</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true"></a><span class="ot">    fn ::</span> <span class="dt">ProbTreeF</span> <span class="dt">Float</span> a (<span class="dt">Reader</span> <span class="dt">Float</span> (<span class="dt">ProbTree</span> <span class="dt">Float</span> a)) <span class="ot">-&gt;</span> <span class="dt">Reader</span> <span class="dt">Float</span> (<span class="dt">ProbTree</span> <span class="dt">Float</span> a)</span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true"></a>    fn (<span class="dt">BranchesF</span> n l xs) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true"></a>      p <span class="ot">&lt;-</span> ask</span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true"></a>      xss <span class="ot">&lt;-</span> <span class="fu">mapM</span> (local (<span class="op">*</span>n)) xs</span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true"></a>      <span class="fu">pure</span> <span class="op">$</span> <span class="dt">Branches</span> (p <span class="op">*</span> n) l xss</span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true"></a>    fn (<span class="dt">LeafF</span> n l a) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true"></a>      p <span class="ot">&lt;-</span> ask</span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true"></a>      <span class="fu">pure</span> <span class="op">$</span> <span class="dt">Leaf</span> (p <span class="op">*</span> n) l a  </span></code></pre></div>
<p>If you are not using <code>Reader</code> a lot it may be easier to look at this, more explicit solution:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a><span class="ot">computeProbFn ::</span> <span class="dt">ProbTree</span> <span class="dt">Float</span> a <span class="ot">-&gt;</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">Float</span> a</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true"></a>computeProbFn <span class="ot">=</span> cata fn</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true"></a><span class="ot">    fn ::</span> <span class="dt">ProbTreeF</span> <span class="dt">Float</span> a (<span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">Float</span> a) <span class="ot">-&gt;</span> (<span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">Float</span> a)</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true"></a>    fn (<span class="dt">BranchesF</span> n l xs) p <span class="ot">=</span> <span class="dt">Branches</span> (p <span class="op">*</span> n) l <span class="op">$</span> L.map (\fn <span class="ot">-&gt;</span> fn <span class="op">.</span> ( <span class="op">*</span>n ) <span class="op">$</span> p ) xs</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true"></a>    fn (<span class="dt">LeafF</span> n l a) p <span class="ot">=</span> <span class="dt">Leaf</span> (p <span class="op">*</span> n) l a</span></code></pre></div>
<p>What we are accumulating, is the ability to conjure a descendant tree at any point from the current probability <code>Float</code>.<br />
We “conjure” the tree by modifying how the children are being “conjured”: we pre-compose <code>(* n)</code> (<code>n</code> is current node probability) to each of the functions that “conjure” the children. This forces recomputation of the probabilities all the way down to the leaves.<br />
This, no longer stops at depth 2.</p>
<h4 id="summary">Summary</h4>
<p>I have shown a few ways to compute <code>ProbTree CumulativeProb a</code>. I ended up getting in trouble a couple of times. <em>In fact, the original version of this post had bugs in it!</em> Recursion is dangerous, recursion has gotcha’s, it has to! Recursion is power with a price tag. Types is not very helpful when we recurse:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a><span class="ot">myUndefined ::</span> a</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true"></a>myUndefined <span class="ot">=</span> myUndefined</span></code></pre></div>
<p>It is easy to get in trouble!</p>
<h2 id="why-finding-the-right-solution-is-sometimes-hard">Why Finding the Right Solution is Sometimes Hard?</h2>
<p><strong>Rant Alert.</strong> This is about the cases where we know or knew how to do thing well but we get stuck anyway. Obviously, finding better and even better ways for writing code is a subject of a never ending research, I am not going to discuss that.</p>
<p>Haskell is an amazingly efficient tool for writing new code when our fingertips know what to do.<br />
Sometimes they do not, and then it is not much better than other languages. It lets us brute-force the code to satisfy the requirements. It is Turing complete, meaning that you can write as much nonsense as you want.</p>
<p>What bit me is:</p>
<ul>
<li>Short amount of time (few hours)</li>
<li>Difficulty in identifying a nice abstraction to solve the problem</li>
<li>The abstractions I ended up wanting to use were not in my short memory</li>
</ul>
<p>So instead I went pushing a brute-force solution…</p>
<p>This experience put me in a philosophical mood of trying to pin-point the reasons why sometimes the code just writes itself and sometimes we get stuck.</p>
<h3 id="human-condition">Human condition</h3>
<p>The underlying reason for why I do something wrong is typically me.<br />
We are not perfect, probably nothing shows it better than the software we write.</p>
<blockquote>
<p>“The universal aptitude for ineptitude makes any human accomplishment an incredible miracle”</p>
</blockquote>
<p>Stapp’s Law</p>
<p>Stapp and Murphy (his coworker) laws are not about giving up, these statements are about understanding our limitations and acting on this understanding.</p>
<h3 id="time-pressure">Time Pressure</h3>
<p>A hard deadline of a few hours does not (typically) happen in software engineering when writing a new code. It does for some data scientist. It also happens in competitive programming. I am not a competitive programmer and I believe very few programmers are.</p>
<p>Software engineers have to (sometimes) work with a short hard timeline when troubleshooting critical application errors. I believe, seasoned developers get years of conditioning that puts them into a troubleshooting mindset when under stress. This is not a creative mindset effective in designing a new code.</p>
<p>For code that is not a cookie-cutter, I believe I write the best code at night, when I sleep. Sometimes I need a few nights. It took two nights (no involvement otherwise) and then &lt; 1 hour of coding for the core examples presented here. It is not just about the time spend on the task, it is often about the latency.</p>
<p>Time pressure can be very destructive. It can reduce both the development speed and the code quality.<br />
That applies to longer time scales as well. Software industry, in my experience, is focused on short term goals. Quality is a long term goal.<br />
No project can afford to have no time constraints, so a balance needs to be struck. I believe the trade-offs are not well understood by the decision makers. … But this is well beyond what this post is about.</p>
<p>‘Uncle Bob’ (Robert C. Martin) likes to talk about a process in which you are not done when you finish writing the code and it works. It is the sweat time for making the code nice.</p>
<h3 id="large-bag-of-tricks">Large Bag of Tricks</h3>
<p>In this analogy a programmer is a magician with a bag of tricks. The bigger the bag the better the programmer. It takes more effort to sort through a bigger bag. There are some interesting indexers in that solution space allowing really good programmers to find a trick faster. One such indexer is the Category Theory. In general, any conceptual understanding of something is a record in some imaginary index.</p>
<p>The index record does not contain all the details, it is just a pointer, it takes time to load the actual details into short memory. That could involve looking up some stuff in the code or re-reading an article… Developer is a magician that needs time to prepare before he pulls out an <strong>old</strong> trick.</p>
<h3 id="not-exactly-muscle-memory">Not exactly Muscle Memory</h3>
<p><em>Muscle Memory</em> is a sports term. You train muscle memory so the movements happen on an auto-pilot.<br />
Muscle memory tends to be a long term memory (“it is like riding a bike”), it is also hard to change. This resistance to change could manifest itself as ‘bad muscle habits’ (e.g. a ski instructor skiing with a slight wedge, static body when making a shot in tennis…). Muscle memory is a long term memory, however athletes still require a warm-up lap / game / run…</p>
<p>For a long time, I have observed something very similar in programmers. Programming work is surprisingly repetitive, we develop something that resembles ‘muscle memory’ without even realizing it. We can do things much faster when we work on familiar problems. We are expert cookie-cutters.</p>
<p>Programmers tend to repeat the previously used patterns, even if these patterns are inferior to other methods (“bad muscle habits”).</p>
<p>Mainstream resistance to FP can be viewed as an example of resistance to change the “muscle memory”.</p>
<p>The analogy is not perfect. We do not need to do a warm-up typing when we start work, instead, we do need longer warm-up period when switching to a programming area we neglected for months or years. For me, that applies especially to the ability to translate ‘real world requirements’ to code design. I will just not think in terms that are not in my short memory, especially when under time pressure.</p>
<h3 id="cookie-cutters">Cookie cutters</h3>
<p>Cookie cutting is not just about repeating ingrained habits. I believe there is some project to project, program to program inertia which makes us want to repeat the same approach. This is not necessarily a bad thing if we are aware of it and if we are not afraid to explore other options.</p>
<p>Even looking at the job interview process, notice the focus on finding someone with a very closely fitting background.<br />
Have you ever seen a job posting asking for someone with a significantly different skill set from what the group already has? Hiring managers want to find cookie-cutters that can make cookies of a very similar shape that their team bakes.<br />
I think this is not optimal in long term. This bias creates groups with a narrow pool of experience and expertise.</p>
<p>I have to consider myself a cookie cutter too. The choices I made in the code I design are be biased by my other work.</p>
<h3 id="summary-1">Summary</h3>
<p>We can’t change who we are, we are unlikely to change the industry.</p>
<p>Instead, we can try to train “good movements” into our “muscle memory” and grow our bag of tricks.</p>
<blockquote>
<p>“In short, I suggest that the programmer should continue to understand what he is doing, that his growing product remains firmly within his intellectual grip.”</p>
</blockquote>
<p>Edsger W. Dijkstra</p>
<p>My conclusion is this: it does not really matter if I get stuck and can’t figure it out for a few days. For some problems I will be stuck for much longer.<br />
I am talking about pursuit of a well designed code, not finding a brute-force kludge.<br />
What really matters is not giving up and eventually figuring it out.</p>
<blockquote>
<p>“You must understand, young Hobbit, it takes a long time to say anything in Old Entish. And we never say anything unless it is worth taking a long time to say.”</p>
</blockquote>
<p>J.R.R Tolkien and Treebeard</p>
<p>The original version of this post had bugs.<br />
Yeah, what really matters is not giving up and eventually figuring it out;) I this post I ate my own dog food.</p>

    </section>
</article>
]]></summary>
</entry>
<entry>
    <title>Arming polysemy with Arrows</title>
    <link href="https://rpeszek.github.io//posts/2021-06-28-polysemy-arrows.html" />
    <id>https://rpeszek.github.io//posts/2021-06-28-polysemy-arrows.html</id>
    <published>2021-06-28T00:00:00Z</published>
    <updated>2021-06-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
    <section class="header">
        Posted on June 28, 2021
        
            by Robert Peszek
        
        
          <br /> Last Modified on Jul 04, 2021
        
        
        <div class="changelog"> <div>Revision History: <ul> <li> (2021.07.02) Added Semantic Note in <a href="#creating-arrow-effects">Creating Arrow Effects</a> section </li> <li> (2021.07.02-05) Added <a href="#tweag-workflows">Tweag Workflows</a> section </li> <li> (2021.07.24) Minor changes in <a href="#tweag-workflows">Tweag Workflows</a> section </li> </ul> </div></div>
        
        
        <div class="info">Tags: <a title="All pages tagged 'Haskell'." href="../tags/Haskell.html">Haskell</a></div>
        
    </section>
    <section>

    </section>
    <section>
        <div class="toc"><div class="header">Table of Contents</div>
<ul>
<li><a href="#arrow-effects.-semantics">Arrow Effects. Semantics</a>
<ul>
<li><a href="#tweag-workflows">Tweag Workflows</a></li>
<li><a href="#chris-penners-arrow-idea">Chris Penner’s <del>arr</del>ow idea</a></li>
</ul></li>
<li><a href="#monadic-polysemy-working-example">Monadic polysemy, Working example</a></li>
<li><a href="#semarr-type"><code>SemArr</code> type</a></li>
<li><a href="#consuming-polysemy-effects-using-arrows">Consuming <em>polysemy</em> effects using arrows</a></li>
<li><a href="#arrow-effects.-the-plumbing">Arrow Effects. The Plumbing</a></li>
<li><a href="#creating-arrow-effects">Creating Arrow Effects</a></li>
<li><a href="#creating-nested-effects">Creating Nested Effects</a></li>
<li><a href="#final-thoughts">Final Thoughts</a></li>
</ul>
</div>
<p>Code for this project can be found in my <a href="https://github.com/rpeszek/experiments" target="_blank">experiments</a> github repo (<a href="https://github.com/rpeszek/experiments/tree/master/polysemy-arrows" target="_blank">polysemy-arrows</a> folder).<br />
It is based on <a href="https://hackage.haskell.org/package/polysemy-1.3.0.0" target="_blank"><em>polysemy 1.3.0.0</em></a>.</p>
<p>The goal of this post is to show how to use arrows when working with or creating <em>polysemy</em> effects.</p>
<p><strong>Motivation:</strong> At work I use a proprietary effect system which is based on <a href="https://www.haskell.org/arrows" target="_blank">arrows</a>. I like it quite a bit, but… For something like an effect system, proprietary is not ideal. The effect system has a huge syntactic and semantic impact on the code. IMO it is a worthy goal to try limit the fragmentation of the ecosystem and (in the industrial context) focus on a small set of effect libraries.<br />
This task became my weekend pet project, and I have done some proof of concept work that added arrows to <a href="https://hackage.haskell.org/package/polysemy" target="_blank"><em>polysemy</em></a>. This post summarizes my effort. I believe similar approach can be used with other monadic effect libraries (like <a href="https://hackage.haskell.org/package/fused-effects" target="_blank"><em>fused-effects</em></a>). <em>polysemy</em> seems much closer to the design of the library I use at work, and was my first choice for this proof of concept work.</p>
<p><strong>Nutshell:</strong> There are two reasons for using arrows: syntactic and semantic. This blog, I am afraid, is about the first one. It is mostly about syntax sugar. Polysemy’s <a href="https://hackage.haskell.org/package/polysemy-1.3.0.0/docs/Polysemy.html#t:Sem" target="_blank"><code>Sem r</code></a> Monad instance is unconstrained, and that translates to arrow effects getting the equivalent <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Arrow.html#t:ArrowMonad" target="_blank"><code>ArrowApply</code></a> typeclass instance for free.<br />
The code I am about to present is trivial (at least in the mathematical sense). Monads and arrows loaded with the power of <code>ArrowApply</code> are equivalent. Semantic arrows I am going to implement here are just monads in arrow’s clothing. There is still some coding that needs to happen to implement the transformation and this code is the main subject of this post.</p>
<p>Algebraic effects for arrows <em>that are less expressive</em> (i.e. are not <code>ArrowApply</code> or even <code>ArrowChoice</code>) are meaningfully different and will be briefly discussed in the next section.</p>
<p>The code I write at work uses DSLs with “fully loaded” <code>ArrowApply</code> semantic arrows. We have build a lot of functionality that is directly concerned with inputs and outputs and arrows are a perfect syntactic match for us. DSL expressiveness is also what we want.</p>
<p>My coding goal in this post is to:</p>
<ul>
<li>be able to consume monadic polysemy effects using arrows</li>
<li>write arrow-like effects and consume them in monadic code</li>
</ul>
<p>Another words, a programmer should be able to create monadic effects using arrow effects and vice-versa.<br />
This is largely accomplished by using the <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Arrow.html#t:Kleisli" target="_blank">Control.Arrow.Kleisli</a> type and an effect construction that mimics <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Arrow.html#t:ArrowMonad" target="_blank">Control.Arrow.ArrowMonad</a>.</p>
<p>Many of my coworkers have, at some point, done a presentation or a tutorial about arrows. (<a href="https://www.youtube.com/watch?v=msQiLyExM3w" target="_blank">Jake’s talk</a>, <a href="https://www.youtube.com/watch?v=YqVTCZFPoyQ" target="_blank">Jason’s talk</a>).<br />
I guess this post qualifies as one and, thus, I am joining the club.</p>
<p>This post assumes the reader has at least basic familiarity with the concepts of arrows and algebraic effects.</p>
<h2 id="arrow-effects.-semantics">Arrow Effects. Semantics</h2>
<p>Since this will mostly be a syntax sugar, I need to talk about the semantics … just to add some depth.<br />
In this section I want to explore the realm of theoretical possibilities for what arrow algebraic effects could possibly look like and how they could differ from monadic algebraic effects.</p>
<p>It is interesting to think about arrows from the point of view of code expressiveness. Syntax aside, you can view arrow code as a subset of monadic code. Monadic code is the most expressive, arrows are much more restrictive (<a href="https://www.cl.cam.ac.uk/~jdy22/papers/idioms-are-oblivious-arrows-are-meticulous-monads-are-promiscuous.pdf" target="_blank">Idioms are oblivious, arrows are meticulous, monads are promiscuous</a> by Lindley, Wadler, Yallop). In Haskell, additional <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Arrow.html#t:ArrowChoice" target="_blank"><code>ArrowChoice</code></a> instance is needed to be able to write conditional (<code>if</code> and <code>case</code>) statements, <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Arrow.html#t:ArrowMonad" target="_blank"><code>ArrowApply</code></a> is needed to partially apply things. To focus this fantasy exploration, I want to forget about <code>ArrowChoice</code> and <code>ArrowApply</code> for a moment and consider what arrow effect system would look like for DSLs based on the <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Arrow.html#t:Arrow" target="_blank"><code>Arrow</code></a> typeclass only.</p>
<p>If an arrow code is a subset of a monadic code then monadic handlers (interpreters) have to also work on arrow DSLs. (With some adjustments of course, this is exactly what this post implements.) The question is what kind of other interesting interpreters one could come up with, that wouldn’t work on promiscuous monads but would work on meticulous arrows?</p>
<p>For one, arrow effects should be able to interpret to other interesting arrows. Basically, the handler (defined as the final interpreter / compilation target) should be able live outside of the standard (monadic) function space. There are examples of open source code out there that make steps in this direction. One example is tweag’s <a href="https://hackage.haskell.org/package/funflow-1.3.2/docs/Control-Arrow-Free.html" target="_blank">funflow</a>.</p>
<p>That sounds interesting but it is good to see a more practical benefit. To do that let’s think about what it means to have lack of conditional statements.</p>
<p>A great reading (somewhat on a theoretical side) is the Lindley’s paper <a href="https://homepages.inf.ed.ac.uk/slindley/papers/aeia.pdf" target="_blank">Algebraic Effects and Effect Handlers for Idioms and Arrows</a>.</p>
<p>Lindley uses the terms <em>static control flow</em> and <em>dynamic control flow</em>. Arrows allow for <em>static control flow</em> only.</p>
<p>Consider this monadic code:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>countTo10 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>  i <span class="ot">&lt;-</span> get</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>  <span class="kw">if</span> i <span class="op">&lt;</span> <span class="dv">10</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>  <span class="kw">then</span> put (i <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>  <span class="kw">else</span> <span class="fu">pure</span> ()</span></code></pre></div>
<p>that uses some <em>State</em> effect and increments it until it reaches 10.<br />
This code uses dynamic control flow (<code>if</code>-s on the result of the previous computation) and cannot be implemented with plain arrows.</p>
<p>This leads to the following 2 interesting observations:</p>
<ul>
<li>Arrow effects need to be more precise</li>
<li>Arrow effect handlers could conceivably do crazy stuff</li>
</ul>
<p><strong>Arrow Effects need to be more precise:</strong><br />
Monadic effect algebra GADT for <em>State</em> is likely to look like this (actually copied it from polysemy):</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">State</span> s m a <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>  <span class="dt">Get</span><span class="ot"> ::</span> <span class="dt">State</span> s m s</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>  <span class="dt">Put</span><span class="ot"> ::</span> s <span class="ot">-&gt;</span> <span class="dt">State</span> s m ()</span></code></pre></div>
<p>to implement <code>countTo10</code> without conditional statements I need more precise instructions! For example, I could add:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>  <span class="dt">Modify</span><span class="ot"> ::</span> (s <span class="ot">-&gt;</span> s) <span class="ot">-&gt;</span> <span class="dt">State</span> s m ()</span></code></pre></div>
<p>This forced precision could be perceived as a benefit in some situations. It gives more power to the interpreter to do different things when interpreting <code>Modify</code> than just <code>Get</code>/<code>Put</code> (for example, do something that is more performant or use different log messages).</p>
<p><strong>Arrow effect handlers could conceivably do crazy stuff:</strong><br />
Static control flow makes for a much more predictable syntax tree. In an example mentioned in the above paper, the interpreter statically infers when the <code>put</code> operation is used and when is not!<br />
Again, this translates to more power given to the interpreters, no <code>put</code>-s could, for example, mean a more aggressive optimization that somehow caches the state…</p>
<h3 id="tweag-workflows">Tweag Workflows</h3>
<p><em>u/Ywen</em> pointed out to me <a href="https://www.reddit.com/r/haskell/comments/o9y7re/arming_polysemy_with_arrows/h3oru2a?utm_source=share&amp;utm_medium=web2x&amp;context=3" target="_blank">here</a> that I missed a very cool presentation in the last ICFP, and indeed I did!<br />
References: <a href="https://richarde.dev/papers/2020/workflows/workflows.pdf" target="_blank">Composing Effects into Tasks and Workflows</a> by Parès, Bernardy, and Eisenberg; <a href="https://github.com/tweag/kernmantle" target="_blank"><em>kernmantle</em></a> effects library; here it is on <a href="https://www.youtube.com/watch?v=AiHOBF3BiLY&amp;t=834s" target="_blank">youtube</a>.</p>
<p>The paper is about creating data science workflow pipelines that decouple two runtime phases: config-time and process-time. This allows for fail-early benefits (if config-time effects fail).</p>
<p>This approach uses an arrow (without <em>ArrowApply</em> and with optional (opt-in) <em>ArrowChoice</em>) DSL that contains both applicative (config-phase) effects that do not depend on the result of previous computation and monadic (process-time) effects that do. The effect algebra GADTs separately define parameters that the DSL <em>has to provide statically</em> and parameters that can be used in dynamic arrow invocation. Thus, the interpreters have more power to infer information about the statically used configuration. This allows interpreters to perform config-time checks, for example, if some statically specified model training data file exists and fail early if it does not, interpreters can pre-download needed artifacts at the config-time, etc.</p>
<p>The presentation (see the youtube link) also shows a general <code>ArrowFromEffects</code> arrow type that generalizes <code>Kleisli</code>, <a href="https://hackage.haskell.org/package/comonad-5.0.8/docs/Control-Comonad.html#t:Cokleisli" target="_blank"><code>Cokleisli</code></a> (from <em>comondad</em>), and <a href="https://hackage.haskell.org/package/profunctors-5.6.2/docs/Data-Profunctor-Cayley.html" target="_blank"><code>Cayley</code></a> (from <em>profunctors</em>). <code>Cayley</code> plays an important role in <em>kernmantle</em>. As the interpretation target, it allows for isolating: the process-time computation and the config-time computation that can be used to analyze program configuration without running it.</p>
<p>The ideas in the paper apply well beyond data-science workflows. I am still in the process of absorbing this paper and code.</p>
<p>Separation between static and dynamic data is impossible when using monadic / ArrowApply computations. I will discuss this a little bit more in the <a href="#creating-arrow-effects">Creating Arrow Effects</a> section of this post.</p>
<h3 id="chris-penners-arrow-idea">Chris Penner’s <del>arr</del>ow idea</h3>
<p>A very interesting <a href="https://www.youtube.com/channel/UCNp-DVb8cQRIOo32sZhWgNg" target="_blank">Berlin’s FP Group</a> presentation by Chris Penner <a href="https://www.youtube.com/watch?v=xZmPuz9m2t0" target="_blank">Deconstructing Lambdas—An Awkward Guide to Programming Without Functions</a> envisions a world with something <code>Arrow</code>-like that does not have the <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Arrow.html#v:arr" target="_blank"><code>arr</code></a>.<br />
From a DSLs prospective, <code>Arrow</code>’s <code>arr</code> translates to the ability to use any Haskell <code>a -&gt; b</code> function inside the DSL.<br />
Removing this ability is very interesting. It is also a hard stop when trying to reuse any monadic effects library.</p>
<p>It seems that Chris Penner’s vision could be implemented with some Arrow-Minus like construction that cares about inputs and outputs and algebraic effect system that will be completely divorced from monadic effects.</p>
<p><strong>The point</strong> I tried to make in this section is that Arrow-like effect systems that are not convertible to monadic effects are very interesting and semantically important. The rest of this post is about interpreting arrows using polysemy and is more a syntax sugar thing.</p>
<p>Now back to <em>polysemy</em> and monads:</p>
<h2 id="monadic-polysemy-working-example">Monadic polysemy, Working example</h2>
<p>I will use the classic <code>Teletype</code> effect as my driving example. This is taken (almost) straight from the polysemy’s github readme:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Teletype</span> m a <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>  <span class="dt">ReadTTY</span><span class="ot">  ::</span> <span class="dt">Teletype</span> m <span class="dt">String</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>  <span class="dt">WriteTTY</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Teletype</span> m ()</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>makeSem '<span class="dt">'Teletype</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a><span class="ot">echo ::</span> <span class="dt">Member</span> <span class="dt">Teletype</span> r <span class="ot">=&gt;</span> <span class="dt">Sem</span> r ()</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>echo <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>  i <span class="ot">&lt;-</span> readTTY</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>  <span class="kw">case</span> i <span class="kw">of</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a>    <span class="st">&quot;&quot;</span> <span class="ot">-&gt;</span> writeTTY <span class="st">&quot;Need some input&quot;</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a>    _  <span class="ot">-&gt;</span> writeTTY <span class="op">$</span> <span class="st">&quot;You said &quot;</span> <span class="op">&lt;&gt;</span> i</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a><span class="co">-- * interpreters</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a><span class="ot">teletypeToIO ::</span> <span class="dt">Member</span> (<span class="dt">Embed</span> <span class="dt">IO</span>) r <span class="ot">=&gt;</span> <span class="dt">Sem</span> (<span class="dt">Teletype</span> '<span class="op">:</span> r) a <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a>teletypeToIO <span class="ot">=</span> interpret \<span class="kw">case</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a>  <span class="dt">ReadTTY</span>      <span class="ot">-&gt;</span> embed <span class="fu">getLine</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true"></a>  <span class="dt">WriteTTY</span> msg <span class="ot">-&gt;</span> embed <span class="op">$</span> <span class="fu">putStrLn</span> msg</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true"></a></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true"></a><span class="ot">interpreter ::</span> r <span class="op">~</span> '[<span class="dt">Teletype</span>, <span class="dt">Embed</span> <span class="dt">IO</span>] <span class="ot">=&gt;</span> <span class="dt">Sem</span> r a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true"></a>interpreter <span class="ot">=</span> runM <span class="op">.</span> teletypeToIO</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true"></a></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true"></a><span class="ot">test ::</span> <span class="dt">IO</span> ()</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true"></a>test <span class="ot">=</span> interpreter echo</span></code></pre></div>
<p>I have spelled out the effect stack in the type signature of the <code>interpreter</code> combinator to add the clarity. I will do that in following examples as well. Compiler can infer these and typical <em>polysemy</em> examples do not list the complete effect list.<br />
The goal is to replace monadic computations with arrows.</p>
<h2 id="semarr-type"><code>SemArr</code> type</h2>
<p>Let me introduce our semantic arrow type:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Control.Arrow</span> <span class="kw">as</span> <span class="dt">Arr</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a><span class="co">-- | Semantic arrows in polysemy</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">SemArr</span> r a b <span class="ot">=</span> <span class="dt">Arr.Kleisli</span> (<span class="dt">Sem</span> r) a b</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a><span class="co">-- | Used to define atomic effect arrows</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a><span class="ot">constSemArr ::</span> (<span class="dt">Sem</span> r) b <span class="ot">-&gt;</span> <span class="dt">SemArr</span> r () b</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>constSemArr c <span class="ot">=</span> <span class="dt">Arr.Kleisli</span> (<span class="fu">const</span> c)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a><span class="co">-- | Used to define atomic effect arrows</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a><span class="ot">semArr ::</span> (a <span class="ot">-&gt;</span> (<span class="dt">Sem</span> r) b)<span class="ot">-&gt;</span> <span class="dt">SemArr</span> r a b</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a>semArr <span class="ot">=</span> <span class="dt">Arr.Kleisli</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true"></a><span class="co">-- | transforms @Sem@ compilation stacks to @SemArr@ compilation stacks.</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true"></a><span class="ot">semArrCompl ::</span> (<span class="dt">Sem</span> r1 b1 <span class="ot">-&gt;</span> <span class="dt">Sem</span> r2 b2) <span class="ot">-&gt;</span> <span class="dt">SemArr</span> r1 a b1 <span class="ot">-&gt;</span> <span class="dt">SemArr</span> r2 a b2 </span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true"></a>semArrCompl comp (<span class="dt">Arr.Kleisli</span> fn) <span class="ot">=</span> <span class="dt">Arr.Kleisli</span> (comp <span class="op">.</span> fn)</span></code></pre></div>
<p><code>Kleisli m a b</code> wraps <code>a -&gt; m b</code> function and is the standard way to express monadic computations as arrows.</p>
<p>It is probably obvious, but it is good to remember that <code>Kleisli</code> is just a type and it does not imply monad payload by itself. In particular, it has these instances:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Functor</span> m <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">Kleisli</span> m a)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">Kleisli</span> m a)</span></code></pre></div>
<p><code>SemArr r a b</code> comes fully loaded with all <code>Arrow</code> typeclass instances (like <code>ArrowApply</code>) because <code>(Sem r)</code> has the unconstrained <code>Monad</code> instance:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">Sem</span> f)</span></code></pre></div>
<p><code>SemArr r a b</code> is a monad in arrow’s clothing.</p>
<h2 id="consuming-polysemy-effects-using-arrows">Consuming <em>polysemy</em> effects using arrows</h2>
<p>This is section will not be interesting. We can tranform monads to arrows using Kleisli, duh:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="ot">readTTYA ::</span> <span class="kw">forall</span> (<span class="ot">r ::</span> [<span class="dt">Effect</span>])<span class="op">.</span> <span class="dt">MemberWithError</span> <span class="dt">Teletype</span> r <span class="ot">=&gt;</span> <span class="dt">SemArr</span> r () <span class="dt">String</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>readTTYA <span class="ot">=</span> constSemArr readTTY</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a><span class="ot">writeTTYA ::</span> <span class="kw">forall</span> (<span class="ot">r ::</span> [<span class="dt">Effect</span>])<span class="op">.</span> <span class="dt">MemberWithError</span> <span class="dt">Teletype</span> r <span class="ot">=&gt;</span> <span class="dt">SemArr</span> r <span class="dt">String</span> ()</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>writeTTYA <span class="ot">=</span> semArr writeTTY</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a><span class="ot">echoA ::</span> <span class="dt">Member</span> <span class="dt">Teletype</span> r <span class="ot">=&gt;</span> <span class="dt">SemArr</span> r () ()</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a>echoA <span class="ot">=</span> proc _ <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a>    i <span class="ot">&lt;-</span> readTTYA <span class="op">-&lt;</span> ()</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a>    <span class="kw">case</span> i <span class="kw">of</span> </span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a>       <span class="st">&quot;&quot;</span> <span class="ot">-&gt;</span> </span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true"></a>           writeTTYA <span class="op">-&lt;</span> <span class="st">&quot;Need some input&quot;</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true"></a>       _ <span class="ot">-&gt;</span>  </span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true"></a>           writeTTYA <span class="op">-&lt;</span> <span class="st">&quot;You said &quot;</span> <span class="op">&lt;&gt;</span> i</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true"></a></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true"></a><span class="co">-- Notice interpreter is input - output based, the last bit @a -&gt; IO b@ is effectively Kleisli arrow</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true"></a></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true"></a><span class="ot">interpreter ::</span>  r <span class="op">~</span> '[<span class="dt">Teletype</span>, <span class="dt">Embed</span> <span class="dt">IO</span>] <span class="ot">=&gt;</span> <span class="dt">SemArr</span> r a b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> b</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true"></a>interpreter arr a <span class="ot">=</span> runM <span class="op">.</span> teletypeToIO <span class="op">$</span> Arr.runKleisli arr a</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true"></a></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true"></a><span class="ot">testA ::</span> <span class="dt">IO</span> ()</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true"></a>testA <span class="ot">=</span> interpreter echoA ()</span></code></pre></div>
<p><code>readTTYA</code> and <code>writeTTYA</code> are arrow-ised versions of the monadic <code>readTTY</code> and <code>writeTTY</code> primitives.</p>
<p>Notice the change in the type signature for <code>interpreter</code>. <code>interpreter</code> now threads the input data into the computation and spells out the output at the end. You can also view it as compiling the <code>SemArr r a b</code> arrow down to <code>Kleisli IO a b</code> (only with <code>Kleisli</code> unwrapped for extra convenience).</p>
<p>Let’s move onto some more interesting stuff:</p>
<h2 id="arrow-effects.-the-plumbing">Arrow Effects. The Plumbing</h2>
<p>One of the syntactic advantages of using arrow effects, at least for me, is the simplified construction of the effect algebra GADT. This definition nicely spells out the input and the output:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Teletype2</span> a b <span class="kw">where</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>  <span class="dt">ReadTTY2</span><span class="ot">  ::</span> <span class="dt">Teletype2</span> () <span class="dt">String</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>  <span class="dt">WriteTTY2</span><span class="ot"> ::</span> <span class="dt">Teletype2</span> <span class="dt">String</span> ()</span></code></pre></div>
<p>I want to be able to add <code>Teletype2</code> to the list of polysemy effects. This needs some plumbing:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Eff2</span> arr r b <span class="kw">where</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>  <span class="dt">MkEff2</span><span class="ot"> ::</span> arr () b <span class="ot">-&gt;</span> <span class="dt">Eff2</span> arr r b</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a><span class="ot">interpretEff2 ::</span> (<span class="kw">forall</span> x <span class="op">.</span> m x <span class="ot">-&gt;</span> <span class="dt">Sem</span> r x) <span class="ot">-&gt;</span> (<span class="kw">forall</span> x y <span class="op">.</span> arr x y <span class="ot">-&gt;</span>  <span class="dt">Arr.Kleisli</span> m x y) <span class="ot">-&gt;</span> <span class="dt">Sem</span> (<span class="dt">Eff2</span> arr '<span class="op">:</span> r) a <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>interpretEff2 comp fn <span class="ot">=</span> interpret \<span class="kw">case</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>  <span class="dt">MkEff2</span> arr   <span class="ot">-&gt;</span> comp (Arr.runKleisli (fn arr) ())</span></code></pre></div>
<p><code>MkEff2</code> is the bit which mimics <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Arrow.html#t:ArrowMonad" target="_blank">Control.Arrow.ArrowMonad</a>! This trick is based on the fact <code>B = B ^ 1</code>: one can represent elements in a set <code>B</code> by using fuctions from a one element set (here <code>()</code>) ending in <code>B</code> that pick that element. That observation nicely generalizes to categorical constructions that use terminal objects and this principled idea works great for what I need.</p>
<p><code>interpretEff2</code> is actually quite powerful. It allows me to implement an equivalent to polysemy’s <code>embed</code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="ot">embedEff2 ::</span> <span class="dt">Member</span> (<span class="dt">Embed</span> m) r <span class="ot">=&gt;</span> (<span class="kw">forall</span> x y <span class="op">.</span> arr x y <span class="ot">-&gt;</span>  <span class="dt">Arr.Kleisli</span> m x y) <span class="ot">-&gt;</span> <span class="dt">Sem</span> (<span class="dt">Eff2</span> arr '<span class="op">:</span> r) a <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>embedEff2 <span class="ot">=</span> interpretEff2 embed</span></code></pre></div>
<p>it will also allow me to reinterpret an arrow effect using other (possibly arrow) effects. We will see it again in the <a href="#effects-based-on-arrow-effects">Nested Effects</a> section.</p>
<p>However, there is a clear problem with what we have so far: <code>arr () b</code> in the definition of <code>Eff2</code> does not match with the <code>WriteTTY2</code> constructor. We need to embed <code>WriteTTY2</code> in a bigger instruction set that has enough expressiveness to be able use the above <code>() -&gt;</code> trick. To do that I will do the following, minimalist, free construction:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Eff2Free</span> eff a b <span class="kw">where</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>  <span class="dt">Pure</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Eff2Free</span> eff a b</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>  <span class="dt">Effect</span><span class="ot"> ::</span> eff a b <span class="ot">-&gt;</span> <span class="dt">Eff2Free</span> eff a b</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>  <span class="dt">Seq</span><span class="ot"> ::</span> <span class="dt">Eff2Free</span> eff a b <span class="ot">-&gt;</span> <span class="dt">Eff2Free</span> eff b c <span class="ot">-&gt;</span> <span class="dt">Eff2Free</span> eff a c</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Category</span> (<span class="dt">Eff2Free</span> eff) <span class="kw">where</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a>  <span class="fu">id</span> <span class="ot">=</span> <span class="dt">Pure</span> Cat.id</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a>  (<span class="op">.</span>) <span class="ot">=</span> <span class="fu">flip</span> <span class="dt">Seq</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true"></a><span class="ot">liftCompKl ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (<span class="kw">forall</span> x y <span class="op">.</span> eff x y <span class="ot">-&gt;</span>  <span class="dt">Arr.Kleisli</span> m x y) <span class="ot">-&gt;</span> <span class="dt">Eff2Free</span> eff a b <span class="ot">-&gt;</span> <span class="dt">Arr.Kleisli</span> m a b</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true"></a>liftCompKl _ (<span class="dt">Pure</span> f) <span class="ot">=</span>  <span class="dt">Arr.Kleisli</span> (<span class="fu">pure</span> <span class="op">Cat..</span> f)</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true"></a>liftCompKl fn (<span class="dt">Effect</span> eff) <span class="ot">=</span> fn eff</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true"></a>liftCompKl fn (<span class="dt">Seq</span> a1 a2) <span class="ot">=</span> liftCompKl fn a1 <span class="op">&gt;&gt;&gt;</span> liftCompKl fn a2</span></code></pre></div>
<p>Combining <code>Eff2</code> with <code>Eff2Free</code> is what I need to move forward.</p>
<p><code>liftCompKl</code> allows me to expand <code>Kleisli</code> encoding of <code>Teletype2</code> to the mini-DSL: <code>Eff2Free Teletype2</code>.</p>
<p><strong>Semantic Note:</strong> When I started working on this, I assumed my <code>Eff2Free</code> will be a free construction of the <code>Arrow</code>, and possibly <code>ArrowChoice</code> or even <code>ArrowApply</code>. This ended up being much more minimalist, we get arrows for free from using <code>SemArr r a b</code>.</p>
<p>What is really needed, is the ability to pre-compose mapped (i.e. <code>Pure</code>) functions with the lifted effect. This free construction needs only to be compatible with the <code>Contravariant</code> Functor (or <code>Profunctor</code> <code>lmap</code>) and there should be some flexibility of how it is done.</p>
<h2 id="creating-arrow-effects">Creating Arrow Effects</h2>
<p>Here is the whole program that uses an Arrow-like effect algebra, arrow instruction primitives, and a DSL program that uses arrows:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Teletype2</span> a b <span class="kw">where</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>  <span class="dt">ReadTTY2</span><span class="ot">  ::</span> <span class="dt">Teletype2</span> () <span class="dt">String</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>  <span class="dt">WriteTTY2</span><span class="ot"> ::</span> <span class="dt">Teletype2</span> <span class="dt">String</span> ()</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a><span class="co">-- type Effect2 arr r b = Eff2 (Eff2Free arr) r b</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a><span class="co">-- | arrow frienly combinator</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a><span class="ot">readTTY2A ::</span> <span class="kw">forall</span> (<span class="ot">r ::</span> [<span class="dt">Effect</span>])<span class="op">.</span> <span class="dt">Member</span> (<span class="dt">Eff2</span> (<span class="dt">Eff2Free</span> <span class="dt">Teletype2</span>)) r <span class="ot">=&gt;</span> <span class="dt">SemArr</span> r () <span class="dt">String</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a>readTTY2A <span class="ot">=</span>  constSemArr readTTY2</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a><span class="co">-- | monad frienly combinator, can be consumed by monadic programs and effects</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true"></a><span class="ot">readTTY2 ::</span> <span class="kw">forall</span> (<span class="ot">r ::</span> [<span class="dt">Effect</span>])<span class="op">.</span> <span class="dt">Member</span> (<span class="dt">Eff2</span> (<span class="dt">Eff2Free</span> <span class="dt">Teletype2</span>)) r <span class="ot">=&gt;</span> <span class="dt">Sem</span> r <span class="dt">String</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true"></a>readTTY2 <span class="ot">=</span> send (<span class="dt">MkEff2</span> (<span class="dt">Effect</span> <span class="dt">ReadTTY2</span>)) </span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true"></a></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true"></a><span class="ot">writeTTY2A ::</span> <span class="kw">forall</span> (<span class="ot">r ::</span> [<span class="dt">Effect</span>])<span class="op">.</span> <span class="dt">Member</span> (<span class="dt">Eff2</span> (<span class="dt">Eff2Free</span> <span class="dt">Teletype2</span>)) r <span class="ot">=&gt;</span> <span class="dt">SemArr</span> r <span class="dt">String</span> ()</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true"></a>writeTTY2A <span class="ot">=</span> semArr writeTTY2</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true"></a></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true"></a><span class="co">-- | mini-DLS @Eff2Free Teletype2@ allows me to encode input paramter to the @WriteTTY2@ instruction</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true"></a><span class="ot">writeTTY2 ::</span> <span class="kw">forall</span> (<span class="ot">r ::</span> [<span class="dt">Effect</span>])<span class="op">.</span> <span class="dt">Member</span> (<span class="dt">Eff2</span> (<span class="dt">Eff2Free</span> <span class="dt">Teletype2</span>)) r <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Sem</span> r ()</span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true"></a>writeTTY2 s <span class="ot">=</span> send (<span class="dt">MkEff2</span> (<span class="dt">Pure</span> (<span class="fu">const</span> s) <span class="op">&gt;&gt;&gt;</span> <span class="dt">Effect</span> <span class="dt">WriteTTY2</span>)) </span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true"></a></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true"></a><span class="ot">echo2A ::</span> <span class="dt">Member</span> (<span class="dt">Eff2</span> (<span class="dt">Eff2Free</span> <span class="dt">Teletype2</span>)) r <span class="ot">=&gt;</span> <span class="dt">SemArr</span> r () ()</span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true"></a>echo2A <span class="ot">=</span> proc _ <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true"></a>    i <span class="ot">&lt;-</span> readTTY2A <span class="op">-&lt;</span> ()</span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true"></a>    <span class="kw">case</span> i <span class="kw">of</span> </span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true"></a>       <span class="st">&quot;&quot;</span> <span class="ot">-&gt;</span> </span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true"></a>           writeTTY2A <span class="op">-&lt;</span> <span class="st">&quot;Need some input&quot;</span></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true"></a>       _ <span class="ot">-&gt;</span>  </span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true"></a>           writeTTY2A <span class="op">-&lt;</span> <span class="st">&quot;You said &quot;</span> <span class="op">&lt;&gt;</span> i</span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true"></a></span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true"></a><span class="co">-- * interpreters</span></span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true"></a></span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true"></a><span class="co">-- | Teletype2 instructions are interpreted as Kleisli</span></span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true"></a><span class="ot">tele2ToKlIO ::</span> <span class="dt">Teletype2</span> a b <span class="ot">-&gt;</span> <span class="dt">Arr.Kleisli</span> <span class="dt">IO</span> a b</span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true"></a>tele2ToKlIO <span class="dt">ReadTTY2</span> <span class="ot">=</span> <span class="dt">Arr.Kleisli</span> <span class="op">$</span> <span class="fu">const</span> <span class="fu">getLine</span></span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true"></a>tele2ToKlIO <span class="dt">WriteTTY2</span> <span class="ot">=</span> <span class="dt">Arr.Kleisli</span> <span class="fu">putStrLn</span></span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true"></a></span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true"></a><span class="co">-- | tele2ToKlIO is extended to the the mini-DLS @Eff2Free Teletype2@</span></span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true"></a><span class="ot">interpreter ::</span>  r <span class="op">~</span> '[<span class="dt">Eff2</span> (<span class="dt">Eff2Free</span> <span class="dt">Teletype2</span>), <span class="dt">Embed</span> <span class="dt">IO</span>] <span class="ot">=&gt;</span> <span class="dt">SemArr</span> r a b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> b</span>
<span id="cb13-39"><a href="#cb13-39" aria-hidden="true"></a>interpreter arr a <span class="ot">=</span> runM <span class="op">.</span> embedEff2 (liftCompKl tele2ToKlIO)  <span class="op">$</span> Arr.runKleisli arr a</span>
<span id="cb13-40"><a href="#cb13-40" aria-hidden="true"></a></span>
<span id="cb13-41"><a href="#cb13-41" aria-hidden="true"></a><span class="ot">testA2 ::</span> <span class="dt">IO</span> ()</span>
<span id="cb13-42"><a href="#cb13-42" aria-hidden="true"></a>testA2 <span class="ot">=</span> interpreter echo2A ()</span></code></pre></div>
<ul>
<li><code>readTTY2</code> and <code>writeTTY2</code> primitives can be used by any monadic polysemy code to create new effects or to use in programs where effect the <code>Eff2 (Eff2Free Teletype2)</code> is available.</li>
<li><code>readTTY2A</code> and <code>writeTTY2A</code> are available for any arrow code. In particular, these can be used to create new arrow effects that compile down to <code>Eff2 (Eff2Free Teletype2)</code>.</li>
</ul>
<p><strong>Semantic Note:</strong> Notice that, when defining monadic version of <code>Teletype</code> GADT, we used value level <code>String</code> in the <code>WriteTTY</code> constructor, now the <code>String</code> input is defined squarely on the type level.<br />
We could consider defining <code>WriteTTY2</code> as <code>WriteTTY2 :: String -&gt; Teletype2 () ()</code> instead.<br />
This would yield <code>String -&gt; SemArr r () ()</code> type for the above <code>writeTTY2A</code>. In the expressive world of <em>monads</em> / <em>ArrowApply</em> both constructions are largely equivalent. Not so in the more restrictive universe of general arrows we discussed in the <a href="#arrow-effects.-semantics">Semantics</a> section.<br />
The new construction would allow a more static handling of the <code>String</code> parameter by the interpreter but the <code>String</code> parameter would not be available for dynamic use at the DSL level. We would not be able to write the above <code>echo2A</code> program. A code example of this is provided in the included repo <a href="https://github.com/rpeszek/experiments/blob/05e23cdca5766b947b731d9084bdfe96c7bcbaae/polysemy-arrows/src/Teletype2B.hs" target="_blank">here</a></p>
<p>Implementing arrow effects on top of other arrows effects seems to be the most interesting case of nesting and is shown next:</p>
<h2 id="creating-nested-effects">Creating Nested Effects</h2>
<p><code>DoEcho2</code> instruction has a non-unit input and output making it more interesting. We will interpret it down to <code>Teletype2</code> effect by writing its input, reading a new input and returning it as the result.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Echoer2</span> a b <span class="kw">where</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>  <span class="dt">DoEcho2</span><span class="ot"> ::</span> <span class="dt">Echoer2</span> <span class="dt">String</span> <span class="dt">String</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a><span class="ot">doEcho2 ::</span> <span class="kw">forall</span> (<span class="ot">r ::</span> [<span class="dt">Effect</span>])<span class="op">.</span> <span class="dt">Member</span> (<span class="dt">Eff2</span> (<span class="dt">Eff2Free</span> <span class="dt">Echoer2</span>)) r <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Sem</span> r <span class="dt">String</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>doEcho2 s <span class="ot">=</span> send (<span class="dt">MkEff2</span> (<span class="dt">Pure</span> (<span class="fu">const</span> s) <span class="op">&gt;&gt;&gt;</span> <span class="dt">Effect</span> <span class="dt">DoEcho2</span>)) </span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a><span class="ot">doEcho2A ::</span> <span class="kw">forall</span> (<span class="ot">r ::</span> [<span class="dt">Effect</span>])<span class="op">.</span> <span class="dt">Member</span> (<span class="dt">Eff2</span> (<span class="dt">Eff2Free</span> <span class="dt">Echoer2</span>)) r <span class="ot">=&gt;</span> <span class="dt">SemArr</span> r <span class="dt">String</span> <span class="dt">String</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true"></a>doEcho2A <span class="ot">=</span> semArr doEcho2 </span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true"></a></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true"></a><span class="co">-- | nice use of arrows to create complex effects</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true"></a><span class="ot">echoer2ToKl ::</span> <span class="dt">Member</span> (<span class="dt">Eff2</span> (<span class="dt">Eff2Free</span> <span class="dt">Teletype2</span>)) r <span class="ot">=&gt;</span> <span class="dt">Echoer2</span> a b <span class="ot">-&gt;</span> <span class="dt">Arr.Kleisli</span> (<span class="dt">Sem</span> r) a b</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true"></a>echoer2ToKl <span class="dt">DoEcho2</span> <span class="ot">=</span> proc inp <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true"></a>  _ <span class="ot">&lt;-</span> writeTTY2A <span class="op">-&lt;</span> inp</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true"></a>  txt <span class="ot">&lt;-</span> readTTY2A <span class="op">-&lt;</span> ()</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true"></a>  <span class="kw">if</span> txt <span class="op">==</span> <span class="st">&quot;&quot;</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true"></a>  <span class="kw">then</span> arr <span class="fu">id</span> <span class="op">-&lt;</span> <span class="st">&quot;No Input&quot;</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true"></a>  <span class="kw">else</span> arr <span class="fu">id</span> <span class="op">-&lt;</span> <span class="st">&quot;You said &quot;</span> <span class="op">&lt;&gt;</span> txt</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true"></a></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true"></a><span class="co">-- | interpretEff2 allows to intepret down the effect</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true"></a><span class="ot">echoer2ToTeletype2 ::</span> <span class="kw">forall</span> r a <span class="op">.</span> <span class="dt">Member</span> (<span class="dt">Eff2</span> (<span class="dt">Eff2Free</span> <span class="dt">Teletype2</span>)) r <span class="ot">=&gt;</span> <span class="dt">Sem</span> (<span class="dt">Eff2</span> (<span class="dt">Eff2Free</span> <span class="dt">Echoer2</span>) '<span class="op">:</span> r) a <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true"></a>echoer2ToTeletype2 <span class="ot">=</span> interpretEff2 <span class="fu">id</span> (liftCompKl <span class="op">@</span> (<span class="dt">Sem</span> r) echoer2ToKl)</span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true"></a></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true"></a><span class="ot">interpreter ::</span>  r <span class="op">~</span> '[<span class="dt">Eff2</span> (<span class="dt">Eff2Free</span> <span class="dt">Echoer2</span>), <span class="dt">Eff2</span> (<span class="dt">Eff2Free</span> <span class="dt">Teletype2</span>), <span class="dt">Embed</span> <span class="dt">IO</span>] <span class="ot">=&gt;</span> <span class="dt">SemArr</span> r a b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> b</span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true"></a>interpreter arr a <span class="ot">=</span> runM <span class="op">.</span> embedEff2 (liftCompKl tele2ToKlIO) <span class="op">.</span> echoer2ToTeletype2 <span class="op">$</span> Arr.runKleisli arr a</span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true"></a></span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true"></a><span class="ot">testEchoerA ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">String</span></span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true"></a>testEchoerA  <span class="ot">=</span> interpreter (doEcho2A <span class="op">&gt;&gt;&gt;</span> doEcho2A) </span></code></pre></div>
<p><code>echoer2ToKl</code> plays the role of an interpreter for the effect algebra. It is implemented using arrows!<br />
The <code>interpretEff2</code> combinator (defined in the <a href="#arrow-effects-the-plumbing">plumbing</a> section) returns an interpreter that <em>polysemy</em> understands.<br />
Again, I view <code>interpreter</code> as a natural transformation between <code>SemArr r a b</code> arrow and <code>Kelisly IO a b</code> arrow (ignoring the <code>runKleisli</code> unwrapping).</p>
<p>We have a two way street to writing compilation stacks:</p>
<ul>
<li>compose <code>Sem r</code> interpreters that remove effects from the <code>r</code> record and compile <code>Sem r1 a</code> monadic computation to a simpler monadic computation <code>Sem r2 a</code> (the standard <em>polysemy</em>’s approach)</li>
<li>compose <code>SemArr r</code> interpreters that compile <code>SemArr r1 a b</code> arrow to a simpler <code>SemArr r2 a b</code> arrow.</li>
</ul>
<p>or mixing both ways. These options are all possible (my git repo has the necessary combinators).</p>
<h2 id="final-thoughts">Final Thoughts</h2>
<p>We have accomplished the goal. We can program <em>polysemy</em> effects by using interchangeably both the monadic and the arrow syntax.</p>
<p>This seems to be an interesting engineering problem: effective refactoring methods for swapping effect systems.<br />
The task of refactoring a large code base to change its effect library will not be easy and I am not even sure it will be attempted.<br />
The differences are not just in the use of arrows vs monads. The effects are declared polymorphically in both cases but in very different ways. The collections of the base (batteries included) effects has subtle differences. There are subtle but important differences in error handling …<br />
It will require much more footwork to be able to do it piece by piece.</p>
<p>The <code>Eff2</code> / <code>Eff2Free</code> tooling is not really arrow specific. I believe, it could be used with other things. That is the reason behind the names (for not using something like <code>EffArr</code>). However, whatever you come up with (e.g. a free Profunctor construction) this will be just dressing a monad in some other clothing - it will be syntactic only. The <code>Arrow</code> seems to be the only meaningful exception, because it comes with the syntax extension (the Arrows pragma).</p>
<p>This was all very much a quick prototype. I am sure the presented code can be improved in many ways. I hope it was good enough to allow for an interesting reading.</p>

    </section>
</article>
]]></summary>
</entry>
<entry>
    <title>Is Alternative a Wrong Abstraction for Handling Failures?</title>
    <link href="https://rpeszek.github.io//posts/2021-02-13-alternative.html" />
    <id>https://rpeszek.github.io//posts/2021-02-13-alternative.html</id>
    <published>2021-02-13T00:00:00Z</published>
    <updated>2021-02-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
    <section class="header">
        Posted on February 13, 2021
        
            by Robert Peszek
        
        
          <br /> Last Modified on February 17, 2021
        
        
        <div class="changelog"> <div>Revision History: <ul> <li> (2021.02.13) Edited <a href="#pessimistic-instances">Pessimistic Instances</a> top section</li> <li> (2021.02.14) <a href="#pessimists-intro-to-alternative">Intro</a> adds a clarification paragraph linking failures to instances (prompted by reddit), <a href="#nutshell">Nutshell</a> clearly lists goals </li> <li> (2021.02.15-16) Added <a href="#readers-response">Reader's Response</a> section</li> <li> (2021.02.16) Laws&colon; clarified some text</li> <li> (2021.02.17) <a href="#rethinking-the-typeclass-itself">Rethinking</a> section reworded a little</li> </ul> </div></div>
        
        
        <div class="info">Tags: <a title="All pages tagged 'Haskell'." href="../tags/Haskell.html">Haskell</a>, <a title="All pages tagged 'error-messages'." href="../tags/error-messages.html">error-messages</a>, <a title="All pages tagged 'maintainability'." href="../tags/maintainability.html">maintainability</a>, <a title="All pages tagged 'correctness'." href="../tags/correctness.html">correctness</a></div>
        
    </section>
    <section>

    </section>
    <section>
        <div class="toc"><div class="header">Table of Contents</div>
<ul>
<li><a href="#nutshell">Nutshell</a></li>
<li><a href="#pessimists-intro-to-alternative">Pessimist’s Intro to <code>Alternative</code></a></li>
<li><a href="#alternative-laws-pessimistically">Alternative Laws, Pessimistically</a></li>
<li><a href="#real-world-alternative-optimism-with-experience">Real-World <code>Alternative</code> (Optimism with Experience)</a>
<ul>
<li><a href="#failure-at-the-end">Failure at the end</a></li>
<li><a href="#permissive-computation-at-the-end">Permissive computation at the end</a></li>
</ul></li>
<li><a href="#pessimistic-instances">Pessimistic Instances</a>
<ul>
<li><a href="#either-e-a"><code>Either [e] a</code></a></li>
<li><a href="#a-decent-blueprint-either-e-e-a">A Decent Blueprint: <code>Either [e] ([e], a)</code></a></li>
<li><a href="#code-example">Code Example</a></li>
<li><a href="#extending-either-e-e-a">Extending <code>Either [e] ([e], a)</code></a></li>
</ul></li>
<li><a href="#rethinking-the-typeclass-itself">Rethinking the Typeclass Itself</a></li>
<li><a href="#alternative-beyond-parsing"><code>Alternative</code> Beyond Parsing</a></li>
<li><a href="#relevant-work-on-hackage">Relevant work on Hackage</a></li>
<li><a href="#conclusions-thoughts">Conclusions, Thoughts</a>
<ul>
<li><a href="#readers-response">Reader’s Response</a></li>
</ul></li>
</ul>
</div>
<p><strong><em>subtitle:</em> A Constructive <del>Criticism</del> Pessimism about the Alternative Typeclass</strong></p>
<p>Code for this project can be found in my <a href="https://github.com/rpeszek/experiments" target="_blank">experiments</a> repo (<a href="https://github.com/rpeszek/experiments/tree/master/alternative" target="_blank">alternative</a> folder).<br />
This is my second post dedicated to the <em>error information loss</em> in Haskell (the first was about <a href="https://rpeszek.github.io/posts/2021-01-17-maybe-overuse.html" target="_blank">Maybe Overuse</a>).</p>
<h2 id="nutshell">Nutshell</h2>
<p><code>Alternative</code> is a popular functional programming concept and the name of a frequently used Haskell typeclass. <code>Alternative</code> helps in writing elegant, concise code. <code>Alternative</code> instances are also known for producing confusing errors. In this post, we do a deep dive into the alternative thinking only about the errors.</p>
<p>The goals for this post are:</p>
<ul>
<li>discuss how <code>Alternative</code> laws impact the instance ability to keep error information</li>
<li>provide examples of how some <code>Alternative</code> instances can get programmers in trouble</li>
<li>show a ‘blueprint’ <a href="#a-decent-blueprint-either-e-e-a"><code>Either [e] ([e],_)</code></a> instance with a strong ability to preserve error information. This blueprint can be extended to a transformer, parser, etc.</li>
<li>very briefly discuss extending or rethinking the <code>Alternative</code> typeclass itself</li>
</ul>
<p>I realized that there is an interesting connection between many <code>Alternative</code> instances and optimism:<br />
Thinking about <em>the glass being half empty or half full</em>, look at this computation: <code>a &lt;|&gt; b</code> and assume that <code>a</code> fails and <code>b</code> succeeds.<br />
<em>A half empty glass</em> makes us think about the failure of <code>a</code>:<br />
<em>Why</em> did <code>a</code> fail?<br />
Would it not be better if some <code>a</code> failures caused the whole computation to fail?…<br />
<em>A half full glass</em> makes us ignore the failure and focus on <code>b</code>… this is exactly the semantics of <code>&lt;|&gt;</code>.<br />
A half full glass is not what you always want. This post looks at the alternative, its laws, and its instances from the “pessimistic” point of view. In this post pessimism is defined as, simply, thinking about the errors.</p>
<p>This is a long post. You may prefer to pick a section you consider interesting and backtrack from it. The information is largely self-contained (except for referring to the laws).</p>
<p>Implementing good error messages is not trivial. This post should not be viewed as criticism but as a challenge.</p>
<p>I am using the term <em>error</em> colloquially, the correct term is <em>exception</em>. <em>Exception information loss</em> just does not have a ring to it.</p>
<h2 id="pessimists-intro-to-alternative">Pessimist’s Intro to <code>Alternative</code></h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Alternative</span> f <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="ot">  empty ::</span> f a</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="ot">  (&lt;|&gt;) ::</span> f a <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f a</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="ot">  some ::</span> f a <span class="ot">-&gt;</span> f [a] <span class="co">-- optional</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a><span class="ot">  many ::</span> f a <span class="ot">-&gt;</span> f [a] <span class="co">-- optional</span></span></code></pre></div>
<p>The typeclass does not specify the semantics of <code>empty</code> and <code>&lt;|&gt;</code> other than their monoidal nature.<br />
However, many instances link the <code>empty</code> and <code>&lt;|&gt;</code> semantics to computation failures.</p>
<p><em>Optimist, First Look</em>:</p>
<ul>
<li><code>empty</code> typically represents a failed computation</li>
<li><code>(&lt;|&gt;)</code> combines 2 alternatives returning one that is successful. The most common approach is to return the left-to-right first success. This is called left-bias, I like to think about it as <em>right-catch semantics</em>.</li>
<li><code>some</code> and <code>many</code> run the computation until first failure and return the successful results, <code>some</code> expects at least one success, otherwise it will fail. <code>some</code> and <code>many</code> are a nod towards parsers or other computations that change state. <code>some</code> and <code>many</code> are likely to yield bottom (e.g. <code>many (Just 1)</code> does not terminate).</li>
</ul>
<p><code>Alternative</code> is the <code>Monoid</code> for the <code>* -&gt; *</code> types, <code>empty</code> representing <code>mempty</code> and <code>&lt;|&gt;</code> representing <code>mappend</code>. This equivalence is “witnessed” by the <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Monoid.html#t:Alt" target="_blank"><code>Data.Monoid.Alt</code></a> monoid instance. The left-bias semantics is equivalent to the <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Monoid.html#t:First." target="_blank"><code>Data.Monoid.First</code></a> monoid.</p>
<p>The definition of <code>Alternative</code> begs this question: Why the <code>Applicative</code> superclass? As far as I know this is because the intended use of <code>empty</code> and <code>&lt;|&gt;</code> is in the applicative context. More on this later.</p>
<p>As we know, <code>MonadPlus</code> provides a similar semantics for monads. <code>Alternative</code> and <code>MonadPlus</code> are most commonly used with parsers. You are likely to use it with <em>aeson</em>, <em>parsec</em> / <em>megaparsec</em>, <em>attoparsec</em>, etc.<br />
In this post the focus is the <code>Alternative</code> with the typical right-catching, left-biased <code>&lt;|&gt;</code> and the examples typically use <em>attoparsec</em>.</p>
<p><em>Pessimist, First Look</em>:</p>
<ul>
<li><code>empty</code> does not accept any error information. It represents a failure of some unknown reason.<br />
I consider this problematic and an oversimplification.<br />
Unless we introduce a zero-information (let me call it <em>noOp</em>) failure, this probably will bite.<br />
I will leave it to you to ponder philosophical questions about <em>noOp</em> (e.g. <code>Left []</code>) failure.<br />
What does: nothing went wrong but the computation failed mean?<br />
</li>
<li><code>(&lt;|&gt;)</code> semantics is unclear about error information.</li>
<li><code>some</code> and <code>many</code> provide no error information about the failure that ended the production of the result list. I will not discuss <code>some</code> or <code>many</code> in this post.</li>
</ul>
<p>A somewhat popular behavior is: If all alternatives fail, then the error information comes from the last tried computation. Examples of alternatives that behave this way are: <em>attoparsec</em> <code>Parser</code>, <em>aeson</em> <code>Parser</code>, <code>IO</code>.</p>
<p>I am not that deeply familiar with GHC internals. However, as a black box, the GHC compiler often behaves in a very similar way. For example, GHC message could indicate a problem with unifying types; it may suggest that my function needs to be applied to more arguments; … while the real issue is that I am missing a typeclass instance somewhere or something else is happening that is completely not related to the error message. Generating useful compiler messages must be very hard and this is not a criticism of GHC but a familiar UX example.<br />
From time to time, GHC will throw Haskell developers for a loop.</p>
<p><strong>Side-Note:</strong> <em>parsec</em> and <em>megaparsec</em> packages implemented sophisticated ways to provide better error messages by looking at things like longest parsed path. Lack of backtracking is what makes the <em>(maga)parsec</em> <code>Parser</code> not a fully lawful <em>Alternative/MonadPlus</em> (violating <em>right zero</em>). The <em>megaparsec</em> haddock suggest adding <code>try</code> to improve the lawfulness. Adding <code>try</code> can mess up error messages. There appears to be an interesting pragmatic trade-off: <em>good error messages</em> vs <em>more lawful alternative behavior</em>.<br />
A great, related, reading is: <a href="http://blog.ezyang.com/2014/05/parsec-try-a-or-b-considered-harmful/" target="_blank">Parsec: “try a &lt;|&gt; b” considered harmful</a>.</p>
<p>A random advice from a discussion about <em>attoparsec</em> errors:</p>
<blockquote>
<p><em>The trick is to use the parsers library, which lets you switch out parsing backends. You can prototype with the trifecta library (which has good error messages) and then switch to attoparsec when you’re done</em></p>
</blockquote>
<p>(I assume that the author was thinking about parsing something, like a standard protocol, where user input cannot cause errors.)<br />
So, this is clearly a bit of a mess and we are looking for crazy workarounds. I will delve deeper into alternative error outputs by looking at the alternative laws next.</p>
<h2 id="alternative-laws-pessimistically">Alternative Laws, Pessimistically</h2>
<p>The required laws (copied from <a href="https://wiki.haskell.org/Typeclassopedia#Laws_6" target="_blank">Typeclassopedia</a>, see also <a href="https://en.wikibooks.org/wiki/Haskell/Alternative_and_MonadPlus#Alternative_and_MonadPlus_laws" target="_blank">Haskell wikibooks</a>) are:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>empty <span class="op">&lt;|&gt;</span> u  <span class="ot">=</span>  u    <span class="co">-- (1)</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>u <span class="op">&lt;|&gt;</span> empty  <span class="ot">=</span>  u    <span class="co">-- (2)</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>u <span class="op">&lt;|&gt;</span> (v <span class="op">&lt;|&gt;</span> w)  <span class="ot">=</span>  (u <span class="op">&lt;|&gt;</span> v) <span class="op">&lt;|&gt;</span> w  <span class="co">-- (3)</span></span></code></pre></div>
<p>Note that these laws do not link <code>Applicative</code> and <code>Alternative</code> in any way. That happens in the following, optional, set of laws:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>f <span class="op">&lt;*&gt;</span> empty <span class="ot">=</span> empty                        <span class="co">-- (4) Rigth Zero</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>(a <span class="op">&lt;|&gt;</span> b) <span class="op">&lt;*&gt;</span> c <span class="ot">=</span> (a <span class="op">&lt;*&gt;</span> c) <span class="op">&lt;|&gt;</span> (b <span class="op">&lt;*&gt;</span> c)  <span class="co">-- (5) Left Distribution</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>a <span class="op">&lt;*&gt;</span> (b <span class="op">&lt;|&gt;</span> c) <span class="ot">=</span> (a <span class="op">&lt;*&gt;</span> b) <span class="op">&lt;|&gt;</span> (a <span class="op">&lt;*&gt;</span> c)  <span class="co">-- (6) Right Distribution</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>(<span class="fu">pure</span> a) <span class="op">&lt;|&gt;</span> x <span class="ot">=</span> <span class="fu">pure</span> a                    <span class="co">-- (7) Left catch</span></span></code></pre></div>
<p>For example, when writing a parser you may decide to use one of these approaches:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>p1 <span class="ot">=</span> <span class="dt">Employee</span> <span class="op">&lt;$&gt;</span> employeeIdParser <span class="op">&lt;*&gt;</span> (nameParser1 <span class="op">&lt;|&gt;</span> nameParser2)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>p2 <span class="ot">=</span> (<span class="dt">Employee</span> <span class="op">&lt;$&gt;</span> employeeIdParser <span class="op">&lt;*&gt;</span> nameParser1) <span class="op">&lt;|&gt;</span> (<span class="dt">Employee</span> <span class="op">&lt;$&gt;</span> employeeIdParser <span class="op">&lt;*&gt;</span> nameParser2)</span></code></pre></div>
<p>it is good to know that these approaches are equivalent.</p>
<p>The laws are strong enough to restrict what failures can be (this is not necessarily a bad thing). For example, <em>(1)</em> and <em>(4)</em> prevent expressing the concept of a critical failure. A sane definition would be: <code>f</code> is a critical failure if <code>f &lt;|&gt; a = f</code> and <code>f &lt;*&gt; a = f</code> for any <code>a</code>.<br />
<code>empty</code> cannot represent a critical failure because of <em>(1)</em><br />
non-<code>empty</code> cannot represent a critical failure because of <em>(4)</em>.<br />
Critical failures are simply not what <code>Alternative</code> is about and that is OK.</p>
<p><em>Pessimist’s Concerns</em>:</p>
<ul>
<li><code>empty</code> typically represents a failure. <em>(4)</em> is problematic if you want to have other possible failures (e.g. failures with different error messages):<br />
<code>otherFailure &lt;*&gt; empty</code> is likely to be <code>otherFailure</code> not <code>empty</code>.<br />
</li>
<li><em>(1 - 3)</em> force a monoidal structure on the failures themselves (under a reasonable assumption that <code>empty</code> is a failure and alternating two failures produces a failure). This is a good property but instances often ignore it. A semigroup structure would make more pragmatic sense (i.e. what is <code>empty</code> error?).<br />
</li>
<li>Note that any instance of <code>Alternative</code> that tries to accumulate failures is likely to have a problem satisfying the distribution laws <em>(5,6)</em>, as the <em>rhs</em> combines 4 potential failures and <em>lhs</em> combines 3.<br />
Would you expect <em>(5,6)</em> to hold in the context of a failure (e.g. parser error messages)? My answer is: I do not! Violating these laws is not necessarily a bad thing. The end result is that the programmer needs to make an explicit choice between <code>p1</code> and <code>p2</code> selecting one with the more desirable error output. The trade-off is similar to one made by the <em>monad_validate</em> package linked at the end of this article.</li>
</ul>
<p>Let me return to the basic laws, particularly <em>(2)</em>: <code>u &lt;|&gt; empty  =  u</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Attoparsec.ByteString</span> <span class="kw">as</span> <span class="dt">A</span> </span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a><span class="ot">testSuccess ::</span> <span class="dt">A.Parser</span> a <span class="ot">-&gt;</span> <span class="dt">A.Result</span> a</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>testSuccess p <span class="ot">=</span> A.parse p <span class="st">&quot;foo&quot;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a><span class="ot">testFail ::</span> <span class="dt">A.Parser</span> a <span class="ot">-&gt;</span> <span class="dt">A.Result</span> a</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>testFail p <span class="ot">=</span> A.parse p <span class="st">&quot;bar&quot;</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>u <span class="ot">=</span> A.string <span class="st">&quot;foo&quot;</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a>lhs <span class="ot">=</span> u <span class="op">&lt;|&gt;</span> empty</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a>rhs <span class="ot">=</span> u</span></code></pre></div>
<p>Here are the results:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt; testFail lhs</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="co">-- Fail &quot;bar&quot; [] &quot;Failed reading: empty&quot;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt;  testFail rhs</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a><span class="co">-- Fail &quot;bar&quot; [] &quot;string&quot;</span></span></code></pre></div>
<p>So we broke the required second law. Incidentally, we would not be able to break this law using <code>testSuccess</code>.<br />
This should not be surprising, (1-3) imply a monoidal structure on failures and this is not what <em>attoparsec</em> does.</p>
<p><em>attoparsec</em> gets a lot of blame for its error output. Let’s try the <code>IO</code> alternative:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>uIO <span class="ot">=</span> <span class="fu">fail</span> <span class="st">&quot;foo&quot;</span><span class="ot"> ::</span> <span class="dt">IO</span> a</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>lhsIO <span class="ot">=</span> uIO <span class="op">&lt;|&gt;</span> empty</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>rhsIO <span class="ot">=</span> uIO</span></code></pre></div>
<p>ghci:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> lhsIO</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="op">***</span> <span class="dt">Exception</span><span class="op">:</span> user <span class="fu">error</span> (mzero)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> rhsIO</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a><span class="op">***</span> <span class="dt">Exception</span><span class="op">:</span> user <span class="fu">error</span> (foo)</span></code></pre></div>
<p>We see the same issue.</p>
<p>One way to look at this, and I believe this is how some programmers are looking at this issue, is that any failure with any error message is considered equivalent to <code>empty</code>. The laws hold if the error information is ignored. Somewhat of a downer if you care about errors.</p>
<p><strong>Side-Note:</strong> Numerous instances of <code>Alternative</code> manage to satisfy <em>(2)</em>.<br />
That includes <code>ExceptT</code>, the <code>Validatation</code> type listed at the end of this post. Here is the law working for ‘trifecta’</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Text.Trifecta</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>u <span class="ot">=</span> string <span class="st">&quot;foo&quot;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>lhs <span class="ot">=</span> parseTest (u <span class="op">&lt;|&gt;</span> empty) <span class="st">&quot;bar&quot;</span><span class="ot"> ::</span> <span class="dt">IO</span> ()</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>rhs <span class="ot">=</span> parseTest u <span class="st">&quot;bar&quot;</span><span class="ot"> ::</span> <span class="dt">IO</span> ()</span></code></pre></div>
<p>ghci:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> lhs</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>(interactive)<span class="op">:</span><span class="dv">1</span><span class="op">:</span><span class="dv">1</span><span class="op">:</span> <span class="fu">error</span><span class="op">:</span> expected<span class="op">:</span> <span class="st">&quot;foo&quot;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a><span class="dv">1</span> <span class="op">|</span> bar<span class="op">&lt;</span><span class="dt">EOF</span><span class="op">&gt;</span> </span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>  <span class="op">|</span> <span class="op">^</span>        </span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> rhs</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>(interactive)<span class="op">:</span><span class="dv">1</span><span class="op">:</span><span class="dv">1</span><span class="op">:</span> <span class="fu">error</span><span class="op">:</span> expected<span class="op">:</span> <span class="st">&quot;foo&quot;</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a><span class="dv">1</span> <span class="op">|</span> bar<span class="op">&lt;</span><span class="dt">EOF</span><span class="op">&gt;</span> </span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a>  <span class="op">|</span> <span class="op">^</span>    </span></code></pre></div>
<p>We will see the blueprint <code>Monoid</code> fix for <em>(2)</em> in the <a href="#either-e-a"><code>Either [e] a</code></a> section.</p>
<h2 id="real-world-alternative-optimism-with-experience">Real-World <code>Alternative</code> (Optimism with Experience)</h2>
<p>Here are some examples of problems arising from the use of <code>Alternative</code> semantics</p>
<h3 id="failure-at-the-end">Failure at the end</h3>
<p>Laws are important, functional programmers use laws (sometimes even subconsciously) when thinking about, implementing, or designing the code. The second law tells us that we can slap a computation that always errors out at the end without messing things up.</p>
<p>Consider this (a slightly adjusted real-world) situation: your app needs to talk to an external website which can decide to do A, B, or C and will reply with A, B, or C json message. Based on what happened, your app will need to do different things. You need to parse the reply to know how to proceed.<br />
The good news is that only A and B are needed in the short term, C can wait. For now, you are only required to tell the user when C happens.</p>
<p>This should be <em>aeson</em> but I keep <em>attoparsec</em> for consistency (the behavior is the same):</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a>parseReply <span class="ot">=</span> parseA <span class="op">&lt;|&gt;</span> parseB <span class="op">&lt;|&gt;</span> parseC </span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>    parseA <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>    parseB <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>    parseC <span class="ot">=</span> <span class="fu">fail</span> <span class="st">&quot;C is not supported yet!&quot;</span></span></code></pre></div>
<p>The external website changed how they report A, now when A is processed <code>parseA</code> fails, the user sees: “C is not supported yet!”.</p>
<p>The following would be a slightly better code, the user would see <code>parseB</code> error message instead:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a>parseReply <span class="ot">=</span> parseC <span class="op">&lt;|&gt;</span> parseA <span class="op">&lt;|&gt;</span> parseB </span></code></pre></div>
<p><em>(sigh)</em></p>
<p>One way out is to parse A, B, and C separately and handle the results (and the parsing errors) outside of the <code>Parser</code>.</p>
<p>The other design risk is in thinking about the second law as ‘stable’: We will not disturb the computation too much if we append (add at the end of the <code>&lt;|&gt;</code> chain) a very restrictive parser that fails most of the time.<br />
An example would be fixing an existing parser <code>p</code> with a missed corner case parser, <code>p &lt;|&gt; cornerCaseP</code>. Errors from <code>p</code> are now almost not visible.</p>
<p>So would <code>cornerCaseP &lt;|&gt; p</code> be a better solution? Next section covers that case.</p>
<h3 id="permissive-computation-at-the-end">Permissive computation at the end</h3>
<p>This is the example I started with. Consider code like this:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a>specificComputation <span class="op">&lt;|&gt;</span> bestEffortComputation</span></code></pre></div>
<p>The specs may change and you will never learn that <code>specificComputation</code> no longer works because <code>bestEffortComputation</code> effectively hides the issue.</p>
<p>The way out is to run <code>specificComputation</code> and <code>bestEffortComputation</code> separately and handle results (e.g. parsing errors if the computation is a parser) outside, or come up with a different way of not using the alternative.</p>
<p><em>Failure at the end</em> situation improves a bit with certain (other than <em>aeson</em> or <em>attoparsec</em>) alternatives, <em>Permissive computation at the end</em> does not seem to have a good available solution.</p>
<h2 id="pessimistic-instances">Pessimistic Instances</h2>
<p>It would be ideal if the following property was true:</p>
<p><em>If a typeclass A is defined in the <strong>base</strong> package and A has something to do with failures, then there exist at least one instance of <em>A</em> in the <strong>base</strong> allowing to recover the error information</em></p>
<p><code>MonadFail</code> fails this property (especially when combined with <code>MonadPlus</code>: <a href="https://rpeszek.github.io/posts/2021-01-17-maybe-overuse.html#monadfail-and-maybe" target="_blank">Maybe Overuse - MonadFail</a>).</p>
<p><code>Alternative</code> <del>fails it as well</del>. (<strong>EDIT Feb 13, 2021</strong>: It has been pointed out to me on <a href="https://www.reddit.com/r/haskell/comments/lj3h47/is_alternative_a_wrong_abstraction_for_handling/gnas3y2?utm_source=share&amp;utm_medium=web2x&amp;context=3" target="_blank">reddit by u/gcross</a> that this is <strong>not a fair criticism</strong>. <em>base</em> typeclass definition does not really claim any relationship to failures. I stand corrected on this. I still think that it would be very nice to have error information friendly instance of Alternative in <em>base</em>.)</p>
<p>Can we come up with <code>Alternative</code> instances that do a decent job of maintaining error information? It seems that the answer is yes.</p>
<h3 id="either-e-a"><code>Either [e] a</code></h3>
<p>This is a warm-up.</p>
<p>This instance is not new. It matches the <code>ExceptT</code> alternative instance from <em>transformers</em> / <em>mtl</em>. It uses standard <code>Either</code> monad and this is a <code>MonadPlus</code> (with a somewhat questionable right-zero law):</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Monoid</span> e <span class="ot">=&gt;</span> <span class="dt">Alternative</span> (<span class="dt">Either</span> e) <span class="kw">where</span> </span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>    empty  <span class="ot">=</span> <span class="dt">Left</span> <span class="fu">mempty</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>    <span class="dt">Left</span> e1 <span class="op">&lt;|&gt;</span> <span class="dt">Left</span> e2 <span class="ot">=</span> <span class="dt">Left</span> <span class="op">$</span> e1 <span class="op">&lt;&gt;</span> e2</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a>    (<span class="dt">Left</span> _) <span class="op">&lt;|&gt;</span> r <span class="ot">=</span> r</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>    r <span class="op">&lt;|&gt;</span> _ <span class="ot">=</span> r</span></code></pre></div>
<p><em>(Note: transformers package has a conflicting instance in the deprecated <code>Control.Monad.Trans.Error</code> module, in a real code a <code>newtype</code> would be needed to avoid this conflict)</em></p>
<p>I have included <code>Monoid e =&gt; Alternative (Either e)</code> instance as a warm-up and to discuss the laws.</p>
<p><strong>Laws:</strong><br />
The required <em>(1-3)</em> laws are satisfied without resorting to any sort of questionable reasoning that treats all errors as <code>empty</code>. However, <code>empty</code> represents a <em>noOp failure</em> computation (somewhat questionable meaning).</p>
<p>Optional <em>(4 Right Zero)</em> law (<code>f &lt;*&gt; empty = empty</code>) is questionable (consider <code>f = Left e</code> with a non-trivial <code>e</code>).<br />
<em>(7 Left Catch)</em> is OK.<br />
As we have predicted, the distribution laws are not satisfied.<br />
<em>(5)</em> is NOT satisfied:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a>(f <span class="op">&lt;|&gt;</span> g) <span class="op">&lt;*&gt;</span> a <span class="ot">=</span> (f <span class="op">&lt;*&gt;</span> a) <span class="op">&lt;|&gt;</span> (g <span class="op">&lt;*&gt;</span> a) </span></code></pre></div>
<p>If <code>f</code> and <code>g</code> represent successful computation and <code>a</code> is a list of errors then the <em>rhs</em> has twice as many errors as the <em>lhs</em>.</p>
<p><em>(6)</em> is not satisfied either:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a>f <span class="op">&lt;*&gt;</span> (b <span class="op">&lt;|&gt;</span> c) <span class="ot">=</span> (f <span class="op">&lt;*&gt;</span> b) <span class="op">&lt;|&gt;</span> (f <span class="op">&lt;*&gt;</span> c) </span></code></pre></div>
<p>If <code>f</code> represents a failed computation then <em>rhs</em> will duplicate <code>f</code> errors.<br />
This looks like a bigger problem than it really is. The <em>lhs</em> and <em>rhs</em> contain the same amount of error information.</p>
<p>So, overall, <code>Either [e] a</code> has done quite well as an alternative!</p>
<h3 id="a-decent-blueprint-either-e-e-a">A Decent Blueprint: <code>Either [e] ([e], a)</code></h3>
<p>What would really be nice, is to have a standard “right-catch with warnings” <code>Alternative</code> instance (please let me know if you have seen it somewhere on Hackage):</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">ErrWarn</span> e w a <span class="ot">=</span> <span class="dt">EW</span> {<span class="ot">runEW ::</span> <span class="dt">Either</span> e (w, a)} <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Functor</span>)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>  </span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a><span class="kw">instance</span> (<span class="dt">Monoid</span> e) <span class="ot">=&gt;</span> <span class="dt">Alternative</span> (<span class="dt">ErrWarn</span> e e) <span class="kw">where</span> </span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a>    empty  <span class="ot">=</span> <span class="dt">EW</span> <span class="op">$</span> <span class="dt">Left</span> <span class="fu">mempty</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a>    <span class="dt">EW</span> (<span class="dt">Left</span> e1) <span class="op">&lt;|&gt;</span> <span class="dt">EW</span> (<span class="dt">Left</span> e2) <span class="ot">=</span> <span class="dt">EW</span> (<span class="dt">Left</span> <span class="op">$</span> e1 <span class="op">&lt;&gt;</span> e2)</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a>    <span class="dt">EW</span> (<span class="dt">Left</span> e1) <span class="op">&lt;|&gt;</span> <span class="dt">EW</span> (<span class="dt">Right</span> (w2, r)) <span class="ot">=</span> <span class="dt">EW</span> <span class="op">$</span> <span class="dt">Right</span> (e1 <span class="op">&lt;&gt;</span> w2, r) <span class="co">-- coupling between @Either e@ and @(e,)@</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true"></a>    r<span class="op">@</span>(<span class="dt">EW</span> (<span class="dt">Right</span> _)) <span class="op">&lt;|&gt;</span> _ <span class="ot">=</span> r</span></code></pre></div>
<p>This approach, when computing <code>a &lt;|&gt; b</code>, does not try to compute <code>b</code> if <code>a</code> succeeds. Thus, this instance matches the common left bias semantics. The approach accumulates all errors encountered up to the point of the first success and returns them as warnings.<br />
This is a lawful <code>Alternative</code> (satisfies required laws <em>(1-3)</em>) and it does not rely on any questionable unification of <code>empty</code> with non-trivial errors.</p>
<p>I now feel justified using <code>Monoid e</code> constraint. Empty failure makes no sense, but empty warnings make a lot of sense!</p>
<p>But wait! To have <code>Alternative</code> we need <code>Applicative</code>. It is possible to implement <code>Applicative</code> for this type in more than one way, one even leads to a valid <code>Monad</code> and <code>MonadPlus</code> (with the right-zero caveat discussed above).<br />
That approach is equivalent to <code>WriterT w (Except e)</code>, it does not try to <code>&lt;*&gt;</code>-accumulate <code>e</code>-s, it only accumulates <code>w</code>-s:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="kw">instance</span> (<span class="dt">Monoid</span> w) <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">ErrWarn</span> e w) <span class="kw">where</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a>    <span class="fu">pure</span> x <span class="ot">=</span> <span class="dt">EW</span> <span class="op">$</span> <span class="dt">Right</span> (<span class="fu">mempty</span>, x)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a>    <span class="dt">EW</span> (<span class="dt">Left</span> e) <span class="op">&lt;*&gt;</span> _ <span class="ot">=</span> <span class="dt">EW</span> <span class="op">$</span> <span class="dt">Left</span> e</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a>    <span class="dt">EW</span> (<span class="dt">Right</span> (u, f)) <span class="op">&lt;*&gt;</span> <span class="dt">EW</span> (<span class="dt">Right</span> (v, x)) <span class="ot">=</span> <span class="dt">EW</span> (<span class="dt">Right</span> (u <span class="op">&lt;&gt;</span> v, f x))</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a>    <span class="dt">EW</span> (<span class="dt">Right</span> (u, f)) <span class="op">&lt;*&gt;</span> <span class="dt">EW</span> (<span class="dt">Left</span> e)  <span class="ot">=</span> <span class="dt">EW</span> <span class="op">$</span> <span class="dt">Left</span> e</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true"></a><span class="kw">instance</span> (<span class="dt">Monoid</span> w) <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">ErrWarn</span> e w) <span class="kw">where</span> </span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true"></a>    <span class="dt">EW</span> (<span class="dt">Left</span> e) <span class="op">&gt;&gt;=</span> _  <span class="ot">=</span> <span class="dt">EW</span> <span class="op">$</span> <span class="dt">Left</span> e</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true"></a>    <span class="dt">EW</span> (<span class="dt">Right</span> (u, x)) <span class="op">&gt;&gt;=</span> k <span class="ot">=</span> </span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true"></a>        <span class="kw">case</span> k x <span class="kw">of</span> </span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true"></a>            <span class="dt">EW</span> (<span class="dt">Right</span> (v, b)) <span class="ot">-&gt;</span> <span class="dt">EW</span> (<span class="dt">Right</span> (u <span class="op">&lt;&gt;</span> v, b))</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true"></a>            <span class="dt">EW</span> (<span class="dt">Left</span> e) <span class="ot">-&gt;</span> <span class="dt">EW</span> (<span class="dt">Left</span> e)</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true"></a></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true"></a><span class="kw">instance</span> (<span class="dt">Monoid</span> e) <span class="ot">=&gt;</span> <span class="dt">MonadPlus</span> (<span class="dt">ErrWarn</span> e e)    </span></code></pre></div>
<p>Please note the small difference. Standard <em>transformers</em> / <em>mtl</em> <code>ExeptT</code> and <code>WriterT</code> both support <code>Alternative</code></p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a> (<span class="dt">Monad</span> m, <span class="dt">Monoid</span> e) <span class="ot">=&gt;</span> <span class="dt">Alternative</span> (<span class="dt">ExceptT</span> e m)	</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a> (<span class="dt">Monoid</span> w, <span class="dt">Alternative</span> m) <span class="ot">=&gt;</span> <span class="dt">Alternative</span> (<span class="dt">WriterT</span> w m) <span class="co">-- Monoid only used to define @empty@</span></span></code></pre></div>
<p>but in a decoupled way, <code>ErrWarn</code> couples these two by “writing” <code>e</code>-s.</p>
<p>This instance exhibits similar problems with matching the <code>&lt;*&gt;</code> semantics as the <code>Monoid e =&gt; Either e</code> instance from the previous section (i.e. <em>(5,6)</em> are not satisfied). Overall it is a very well behaved alternative.</p>
<h3 id="code-example">Code Example</h3>
<p>Here is a very convoluted (and not very good) parsing code that is intended only to demonstrate how <code>ErrWarn</code> works. This code creates a natural transformation from the <em>attoparsec</em> parser to <code>ErrWarn</code> and compares the error outputs from both.</p>
<p>This code will parse <em>ByteStrings</em> like “id last-first-name dept boss2” to produce, if successful, a hard-coded <em>id, name, department, and boss name</em>:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a>idP <span class="ot">=</span> <span class="dv">123</span> <span class="ot">`onKeyword`</span> <span class="st">&quot;id&quot;</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a>nameP1 <span class="ot">=</span> <span class="st">&quot;Smith John&quot;</span>  <span class="ot">`onKeyword`</span> <span class="st">&quot;last-first-name&quot;</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a>nameP2 <span class="ot">=</span> <span class="fu">fail</span> <span class="st">&quot;first-last-name not implemented yet&quot;</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a>deptP <span class="ot">=</span>  <span class="st">&quot;Billing&quot;</span> <span class="ot">`onKeyword`</span> <span class="st">&quot;dept&quot;</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a>bossP1 <span class="ot">=</span> <span class="st">&quot;Jim K&quot;</span> <span class="ot">`onKeyword`</span> <span class="st">&quot;boss1&quot;</span>     </span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true"></a>bossP2 <span class="ot">=</span> <span class="st">&quot;Kim J&quot;</span> <span class="ot">`onKeyword`</span> <span class="st">&quot;boss2&quot;</span>    </span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true"></a>bossP3 <span class="ot">=</span> <span class="fu">pure</span> <span class="st">&quot;Mij K bosses everyone&quot;</span> </span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true"></a></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true"></a><span class="ot">onKeyword ::</span> a <span class="ot">-&gt;</span> <span class="dt">B.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">AT.Parser</span> <span class="dt">B.ByteString</span> a</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true"></a>onKeyword val key <span class="ot">=</span> <span class="fu">const</span> val <span class="op">&lt;$&gt;</span> A.manyTill ACh.anyChar</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true"></a>                    (A.lookAhead <span class="op">$</span> A.string key)</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true"></a>                    <span class="op">A.&lt;?&gt;</span> <span class="fu">show</span> key</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true"></a></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Employee</span> <span class="ot">=</span> <span class="dt">Employee</span> {</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true"></a><span class="ot">    id ::</span> <span class="dt">Int</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true"></a>    ,<span class="ot"> name ::</span> <span class="dt">String</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true"></a>    ,<span class="ot"> dept  ::</span> <span class="dt">String</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true"></a>    ,<span class="ot"> boss ::</span> <span class="dt">String</span></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true"></a>   } <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true"></a></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true"></a><span class="ot">emplP ::</span> <span class="dt">A.Parser</span> <span class="dt">B.ByteString</span> <span class="dt">Employee</span></span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true"></a>emplP <span class="ot">=</span> </span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true"></a>   <span class="dt">Employee</span> </span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true"></a>   <span class="op">&lt;$&gt;</span> idP</span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true"></a>   <span class="op">&lt;*&gt;</span> (nameP1 <span class="op">&lt;|&gt;</span> nameP2)</span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true"></a>   <span class="op">&lt;*&gt;</span> deptP</span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true"></a>   <span class="op">&lt;*&gt;</span> (bossP1 <span class="op">&lt;|&gt;</span> bossP2 <span class="op">&lt;|&gt;</span> bossP3) </span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true"></a></span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true"></a><span class="ot">emplP' ::</span> <span class="dt">B.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">ErrWarn</span> [<span class="dt">String</span>] [<span class="dt">String</span>] <span class="dt">Employee</span></span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true"></a>emplP' txt <span class="ot">=</span> </span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true"></a>   <span class="dt">Employee</span> </span>
<span id="cb20-32"><a href="#cb20-32" aria-hidden="true"></a>   <span class="op">&lt;$&gt;</span> ew idP </span>
<span id="cb20-33"><a href="#cb20-33" aria-hidden="true"></a>   <span class="op">&lt;*&gt;</span> (ew nameP1  <span class="op">&lt;|&gt;</span> ew nameP2 )</span>
<span id="cb20-34"><a href="#cb20-34" aria-hidden="true"></a>   <span class="op">&lt;*&gt;</span> ew deptP </span>
<span id="cb20-35"><a href="#cb20-35" aria-hidden="true"></a>   <span class="op">&lt;*&gt;</span> (ew bossP1  <span class="op">&lt;|&gt;</span> ew bossP2 <span class="op">&lt;|&gt;</span> ew bossP3)</span>
<span id="cb20-36"><a href="#cb20-36" aria-hidden="true"></a>   <span class="kw">where</span></span>
<span id="cb20-37"><a href="#cb20-37" aria-hidden="true"></a><span class="ot">        ew ::</span> <span class="dt">A.Parser</span> a  <span class="ot">-&gt;</span> <span class="dt">ErrWarn</span> [<span class="dt">String</span>] [<span class="dt">String</span>] a</span>
<span id="cb20-38"><a href="#cb20-38" aria-hidden="true"></a>        ew p <span class="ot">=</span> singleErr <span class="op">$</span> A.parseOnly p txt</span>
<span id="cb20-39"><a href="#cb20-39" aria-hidden="true"></a></span>
<span id="cb20-40"><a href="#cb20-40" aria-hidden="true"></a><span class="ot">        singleErr ::</span> <span class="dt">Either</span> e a <span class="ot">-&gt;</span> <span class="dt">ErrWarn</span> [e] [e] a</span>
<span id="cb20-41"><a href="#cb20-41" aria-hidden="true"></a>        singleErr (<span class="dt">Left</span> e) <span class="ot">=</span> <span class="dt">EW</span> <span class="op">$</span> <span class="dt">Left</span> [e]</span>
<span id="cb20-42"><a href="#cb20-42" aria-hidden="true"></a>        singleErr (<span class="dt">Right</span> r) <span class="ot">=</span> <span class="dt">EW</span> <span class="op">$</span> <span class="dt">Right</span> ([], r)</span></code></pre></div>
<p>Trying it with a good input:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt; A.parseOnly emplP &quot;id last-first-name dept boss1&quot;</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a><span class="co">-- Right (Employee {id = 123, name = &quot;Smith John&quot;, dept = &quot;Billing&quot;, boss = &quot;Jim K&quot;})</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt; emplP' &quot;id last-first-name dept boss1&quot;</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a><span class="co">-- EW {runEW = Right ([],Employee {id = 123, name = &quot;Smith John&quot;, dept = &quot;Billing&quot;, boss = &quot;Jim K&quot;})}</span></span></code></pre></div>
<p>Trying <a href="#failure-at-the-end">failure at the end</a> situation (typo in <code>"last-first-name"</code>):</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt; A.parseOnly emplP &quot;id last-firs-name dept boss2&quot;</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a><span class="co">-- Left &quot;Failed reading: first-last-name not implemented yet&quot;</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt; runEW $ emplP' &quot;id last-firs-name dept boss2&quot;</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a><span class="co">-- Left [&quot;\&quot;last-first-name\&quot;: not enough input&quot;,&quot;Failed reading: first-last-name not implemented yet&quot;]</span></span></code></pre></div>
<p>(A similar benefit can be achieved by using one of the Hackage <em>validation</em> packages listed at the end of this post or using the <code>ExceptT</code> alternative.)</p>
<p>Trying <a href="#permissive-computation-at-the-end">permissive computation at the end</a> situation (<code>"boss"</code> parsing error):</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt; A.parseOnly emplP &quot;id last-first-name dept boss&quot;</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a><span class="co">-- Right (Employee {id = 123, name = &quot;Smith John&quot;, dept = &quot;Billing&quot;, boss = &quot;Mij K bosses everyone&quot;})</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt;runEW $ emplP' &quot;id last-first-name dept boss&quot;</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a><span class="co">-- Right ([&quot;\&quot;boss1\&quot;: not enough input&quot;,&quot;\&quot;boss2\&quot;: not enough input&quot;],Employee {id = 123, name = &quot;Smith John&quot;, dept = &quot;Billing&quot;, boss = &quot;Mij K bosses everyone&quot;})</span></span></code></pre></div>
<p>(A similar benefit cannot be achieved by using a <em>validation</em> package from the list at the end of this post or a <em>transformers</em> stack. Please let me know if something like this exists elsewhere.)</p>
<p>We are no longer being thrown for a loop!</p>
<h3 id="extending-either-e-e-a">Extending <code>Either [e] ([e], a)</code></h3>
<p>The <em>right-catch with warnings</em> semantics of <code>Either [e] ([e], a)</code> is a decent principled computation that can be extended to other types. For example, a similar semantics could find its way into some parser internals.</p>
<p>I have created several prototype alternative instances (including a primitive <code>WarnParser</code> parser and <code>ErrWarnT</code> transformer) that follow the same semantics, they can be found in the linked <a href="https://github.com/rpeszek/experiments/tree/master/alternative" target="_blank">repo</a>.</p>
<p><code>ErrWarnT</code> allows to program in a <code>ErrWarnT e e f</code> alternative (e.g. <code>ErrWarnT e e Parser</code>) and annotate additional error information on <code>f</code> (e.g. during parsing). This allows, for example, to <em>pattern match on errors</em> to figure out which alternatives in <code>&lt;|&gt;</code> have failed even if the overall computation has succeeded.<br />
<code>WarnParser</code> accumulates <code>&lt;|&gt;</code> similar errors and warnings out of the box.</p>
<h2 id="rethinking-the-typeclass-itself">Rethinking the Typeclass Itself</h2>
<p>Is <code>Alternative</code> a wrong abstraction for alternating failing computations? I think it is. IMO any abstraction used for working with failures should include failures in its semantics. <code>Alternative</code> typeclass does not do that.</p>
<p><code>Alternative</code> is widely used and creating an ‘alternative’ to it will, probably, be very hard or even impossible. That typeclass would be useful only if the ecosystem accepted it.</p>
<p>One conceptually simple improvement would be to split <code>Alternative</code> to mimic the <code>Semigoup</code> / <code>Monoid</code> split (<em>semigroupoids</em> has <code>Data.Functor.Alt</code> which seems to fit the bill).<br />
This would clean up some instances like <code>ExceptT</code> (the above <a href="#either-e-a"><code>Either [e]</code></a>) or <a href="#relevant-work-on-hackage"><code>Validation</code></a> by reducing the need for questionable <code>empty</code> definitions like <code>Left []</code>. Incidentally, this would be the opposite of the <a href="https://wiki.haskell.org/MonadPlus_reform_proposal" target="_blank"><code>MonadZero</code></a> proposal.</p>
<p>I would really like to see <code>e</code>-s in the typeclass definition:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Semigroup1</span> f <span class="kw">where</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a><span class="ot">   (&lt;|&gt;)  ::</span> f a <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f a </span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">Applicative</span> (f e) <span class="ot">=&gt;</span> <span class="dt">Semigroup2</span> e f <span class="kw">where</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a><span class="ot">   (&lt;||&gt;)  ::</span> f e a <span class="ot">-&gt;</span> f e a <span class="ot">-&gt;</span> f e a </span></code></pre></div>
<p>The linked <a href="https://github.com/rpeszek/experiments/tree/master/alternative" target="_blank">repo</a> contains some loose replacement ideas for <code>Alternative</code> and <code>MonadPlus</code>. It is a work in progress.</p>
<h2 id="alternative-beyond-parsing"><code>Alternative</code> Beyond Parsing</h2>
<p>It should be mentioned that there are instances of <code>Alternative</code> such as the list <code>[]</code>, or <code>ZipList</code> where failures are not a concern. Sorting algorithms using MonadPlus are thumbs up. Examples like <code>LogicT</code> or other backtracking search mechanisms should be in the same boat (at least from the failure point of view, other aspects can be questionable and fascinating <a href="https://stackoverflow.com/questions/15722906/must-mplus-always-be-associative-haskell-wiki-vs-oleg-kiselyov" target="_blank">stackoverflow on mplus associativity</a>).</p>
<p>Also, these instances are rather cool.<br />
Languages like JavaScript, Python, Groovy have a concept of <em>truthiness</em>. <em>Truthy</em> <em>Falsy</em> are a thing and come with a Boolean algebra of sorts. Try evaluating this in you browser’s console:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a><span class="op">&gt;</span> <span class="st">&quot;hello&quot;</span> <span class="op">||</span> <span class="st">&quot;&quot;</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a><span class="st">&quot;hello&quot;</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a><span class="op">&gt;</span> <span class="st">&quot;&quot;</span> <span class="op">||</span> <span class="st">&quot;hello&quot;</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true"></a><span class="st">&quot;hello&quot;</span></span></code></pre></div>
<p><em>Truthiness</em> is questionable because the Boolean algebra laws (like <code>a || b = b || a</code>) no longer hold.</p>
<p>Now try these in ghci:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> <span class="st">&quot;&quot;</span> <span class="op">&lt;|&gt;</span> <span class="st">&quot;hello&quot;</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a><span class="st">&quot;hello&quot;</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> <span class="st">&quot;hello&quot;</span> <span class="op">&lt;|&gt;</span> <span class="st">&quot;&quot;</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true"></a><span class="st">&quot;hello&quot;</span></span></code></pre></div>
<p>Alternative is a principled version of the <em>truthiness</em>. The laws properly state the algebra limitations.<br />
As we have seen, the problem is in going with this generalization too far.</p>
<p><em>async</em> package uses <code>&lt;|&gt;</code> to return result form the computation that finishes first. This seems a good use to me.</p>
<p>Several types like <code>ExceptT</code>, <code>Validation</code> (see <a href="#relevant-work-on-hackage">hackage section</a> below) allow to use user defined monoid error types. <code>mempty</code> may not have much sense as an error, but this setup offers interesting options for accumulating errors. For example, using it with <code>Data.Monoid.Max</code> could be very interesting.</p>
<p><strong>Not so good:</strong><br />
An interesting case is the <code>STM</code> monad. <code>a &lt;|&gt; b</code> is used to chain computations that may want to <code>retry</code>. I imagine, composing <code>STM</code> computations this way is rare. If you wanted to communicate why <code>a</code> has decided to retry, how would you do that? I consider <code>STM</code> use of alternatives problematic.</p>
<p><code>IO</code> itself is an <code>Alternative</code> and uses <code>&lt;|&gt;</code> as a <code>catch</code> that throws away the error information. I dislike the <code>IO</code> instance. “Launching missiles” and not knowing what went wrong seems not ideal.</p>
<h2 id="relevant-work-on-hackage">Relevant work on Hackage</h2>
<p><a href="https://hackage.haskell.org/package/free" target="_blank"><em>free</em></a> package contains a semantic (free) version of <em>Alternative</em>.</p>
<p><a href="https://hackage.haskell.org/package/semigroupoids-5.3.5/docs/Data-Functor-Alt.html" target="_blank"><em>semigroupoids</em></a> offers <em>Alt</em> that is just a <em>Functor</em> and does not need to have <code>empty</code>.</p>
<p><a href="https://hackage.haskell.org/package/transformers-0.5.6.2" target="_blank"><em>transformers</em></a> ExceptT implements <code>Alternative</code> which accumulates “Lefts”.</p>
<p>A list of interesting packages that implement <code>Monoid</code>-like semantics for <code>Applicative</code> (most also implement <code>Alternative</code>) to accumulate errors provided by <a href="https://www.reddit.com/user/affinehyperplane/" target="_blank">u/affinehyperplane</a> on <a href="https://www.reddit.com/r/haskell/comments/kyo4xk/maybe_considered_harmful/gji7fmx?utm_source=share&amp;utm_medium=web2x&amp;context=3" target="_blank">reddit</a>:</p>
<p><a href="https://hackage.haskell.org/package/either-5.0.1.1/docs/Data-Either-Validation.html" target="_blank"><em>either</em></a> defines <code>Either</code> like <code>Validation e a</code> applicative, both <code>&lt;|&gt;</code> and <code>&lt;*&gt;</code> accumulate errors<br />
<a href="https://hackage.haskell.org/package/validation-1.1/docs/Data-Validation.html" target="_blank"><em>validation</em></a> defines a similar <code>Validation</code> type, it does not define alternative instance.<br />
<a href="https://hackage.haskell.org/package/validation-selective-0.1.0.0/docs/Validation.html" target="_blank"><em>validation-selective</em></a> defines a similar <code>Validation</code> type loaded with (non-monad) instances<br />
<a href="https://hackage.haskell.org/package/monad-validate-1.2.0.0/docs/Control-Monad-Validate.html" target="_blank"><em>monad-validate</em></a> provides an interesting and very useful validation <em>monad</em> transformer (this is lawful if you do not compare error outputs) that can accumulate errors, it does not implement <code>Alternative</code>.</p>
<p>In the context of parsers, it should be noted that packages like <em>trifecta</em>, <em>(mega)parsec</em> do nice job returning error messages when <code>&lt;|&gt;</code> fails.</p>
<p>A good references about Alternative and MonadPlus in general is the <a href="https://wiki.haskell.org/Typeclassopedia#Failure_and_choice:_Alternative.2C_MonadPlus.2C_ArrowPlus" target="_blank">Typeclassopedia</a> and <a href="https://en.wikibooks.org/wiki/Haskell/Alternative_and_MonadPlus" target="_blank">wikibooks</a>, both contain interesting links.</p>
<p>There are many stackoverflow answers about Haskell solutions to accumulating errors. These typically refer to some of the packages in the above list, I am not linking them here.<br />
There are many, many discussions about error output from different parsing libraries. These are typically focused on criticizing a particular package (typically <em>attoparsec</em>) not the <code>Alternative</code> typeclass itself.<br />
I am sure, this list is not complete. Please let me know if you see a relevant work elsewhere.</p>
<h2 id="conclusions-thoughts">Conclusions, Thoughts</h2>
<p>It is possible to implement instances that do a decent error management but it feels like this is accomplished despite of the <code>Alternative</code> typeclass definition and its laws. To answer my title: IMO <code>Alternative</code> is a wrong abstraction for managing computational failures.</p>
<p>The more I program in Haskell the more I view Functional Programming as a branch of Applied Mathematics.<br />
Criticizing mathematical abstractions does not make much sense. Criticism of how well an abstraction fits is application if a fair game.</p>
<p>Why errors are being overlooked? I assembled a possible list when writing about the <a href="https://rpeszek.github.io/posts/2021-01-17-maybe-overuse.html#why-maybe-is-overused-possible-explanations" target="_blank">Maybe Overuse</a> and that list seems to translate well to the alternative typeclass. For example, code using <code>&lt;|&gt;</code> is very terse, something with a stronger error semantics will most likely be more verbose; coding with <code>&lt;|&gt;</code> is simple, stronger error semantics will likely be more complex …<br />
I could be wrong on this: the original usages of MonadPlus were probably related to sorting/searching and lists. Alternative computations with more complex error structure were probably introduced later? … and, the instances ended up outgrowing the typeclass?</p>
<p>The <em>pessimist</em> theme was partially inspired by the following two concepts:<br />
<a href="https://link.springer.com/referenceworkentry/10.1007%2F978-94-007-0753-5_2219#:~:text=Definition,favor%20positive%20information%20in%20reasoning." target="_blank"><em>Positivity Bias</em></a> and, its opposite, the <a href="https://en.wikipedia.org/wiki/Negativity_bias" target="_blank"><em>Negativity Bias</em></a> are psychological notions that, I believe, have a deep relevance to the programming in general.<br />
<em>Positivity Bias</em> includes a <em>tendency to favor positive information in reasoning</em> and, by definition, will make you think about “happy path” and “sunny day scenarios”.<br />
<em>Negativity Bias</em> includes a <em>tendency to favor negative information in reasoning</em> and, by definition, will make you consider “rainy day scenarios”, corner cases, error handling, error information.<br />
I think we should embrace some form of <em>pessimism</em> and put in on the pedestal next to the principled construction.</p>
<p>I hope this post will motivate more discussion about the <em>error information</em> handling in Haskell.<br />
My particular interest is in discussing:</p>
<ul>
<li>your views about rethinking the <code>Alternative</code> typeclass</li>
<li>your views on pessimism in programming</li>
<li>your views on the error information loss in Haskell code</li>
<li>is <code>ErrWarn</code> somewhere on Hackage and I did not see it?</li>
<li>other interesting <code>Alternative</code> instances that care about errors</li>
<li>obviously, anything that I got wrong</li>
</ul>
<p><a href="https://www.reddit.com/r/haskell/comments/lj3h47/is_alternative_a_wrong_abstraction_for_handling/" target="_blank">reddit</a> discussion<br />
github <a href="https://github.com/rpeszek/rpeszek.github.io/discussions/1" target="_blank">discussions</a></p>
<p>Thank you for reading!</p>
<h3 id="readers-response">Reader’s Response</h3>
<p>Common critical response on reddit (2021-02-15) can be summarized as: Alternative should not be used like this and there are better ways of writing such code.</p>
<blockquote>
<p>“it seems a bit odd, to me, to criticize and talk about rethinking a typeclass because it does something that it was never intended to do”<br />
“people should be using a typeclass designed for handling errors”<br />
“maybe you are asking too much to Alternative”</p>
</blockquote>
<p>The <code>ErrWarn</code> blueprint or other instances with strong error information preserving abilities were not discussed.</p>
<p>There appears to be mixed response to the error information loss being a problem in general. Some readers claim that this is not a problem, some seem to share my concern.</p>
<p><strong>Author’s Defense</strong></p>
<p>I agree with the: “Alternative should not be used like this”.</p>
<p>Alternative is an example of an abstraction that is very easy to use, it makes coding fast.<br />
It most likely will end up being used (I have seen it) in ways similar to what I described in this post.<br />
It is important that the developers are aware of the gotchas that come with some of the instances.</p>
<p>Any code (alternative or not) producing confusing error output is a concern.<br />
IMO, every abstraction and every instance needs to be concerned about the error output quality. <em>Not being designed for error handling</em> should not be a thing. At the same time, error friendlier instances should be a good thing.</p>

    </section>
</article>
]]></summary>
</entry>

</feed>
