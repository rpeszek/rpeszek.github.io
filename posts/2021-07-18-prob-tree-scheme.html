<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Infrequent, Pragmatic, Lambda Blog - Probability Tree Diagrams. Recursion Schemes. Why Finding the Right Solution is Sometimes Hard?</title>
        <link rel="alternate" type="application/atom+xml" href="https://rpeszek.github.io/atom.xml" title="atom" />
        <link rel="alternate" type="application/rss+xml" href="https://rpeszek.github.io/RSS.xml" title="rss" />
        <!-- <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="atom"/>
        <link rel="alternate" type="application/rss+xml" href="/RSS.xml" title="rss"/> -->
        <link rel="stylesheet" href="../css/reset.css" />
        <link rel="stylesheet" href="../css/predefault.css" />
        <link rel="stylesheet" href="../css/default.css" />
         
        <link rel="stylesheet" href="../css/syntax.css" /> 
        
        
    </head>
    <body>
        <header>
            <div class="motto">
                <a href="../">hmm >>= oh!</a>
            </div>
            <div class="logo">
                <a href="../">Infrequent, Pragmatic, Lambda Blog</a>
            </div>
            <nav>
                <!-- <a href="/">Home</a> -->
                <a href="../thoughts.html">Semiserious</a>
                <a href="../about.html">About</a>
                <!-- <a href="/contact.html">Contact</a> -->
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>Probability Tree Diagrams. Recursion Schemes. Why Finding the Right Solution is Sometimes Hard?</h1>
            <article>
    <section class="header">
        Posted on July 18, 2021
        
            by Robert Peszek
        
        
          <br /> Last Modified on Jul 18, 2021
        
        
        <div class="changelog"> <div>Revision History: <ul> <li> (2021.07.24-25) Fixed/Reworked `cata` examples (per <a target="_blank" href="https://www.reddit.com/r/haskell/comments/onrhtw/probability_tree_diagrams_recursion_schemes_why/h684cpr?utm_source=share&utm_medium=web2x&context=3">r/Tarmen</a>) and changed definition of example tree. </ul> </div></div>
        
        
        <div class="info">Tags: <a title="All pages tagged 'Haskell'." href="../tags/Haskell.html">Haskell</a></div>
        
    </section>
    <section>

    </section>
    <section>
        <div class="toc"><div class="header">Table of Contents</div>
<ul>
<li><a href="#the-problem">The Problem</a>
<ul>
<li><a href="#why-is-this-useful">Why is this useful?</a></li>
<li><a href="#plumbing">Plumbing</a></li>
<li><a href="#example-tree">Example Tree</a></li>
<li><a href="#traditional-solution-state-threads">Traditional Solution, State Threads</a></li>
<li><a href="#simple-recursion-schemes">Simple Recursion Schemes</a></li>
</ul></li>
<li><a href="#why-finding-the-right-solution-is-sometimes-hard">Why Finding the Right Solution is Sometimes Hard?</a>
<ul>
<li><a href="#human-condition">Human condition</a></li>
<li><a href="#time-pressure">Time Pressure</a></li>
<li><a href="#large-bag-of-tricks">Large Bag of Tricks</a></li>
<li><a href="#not-exactly-muscle-memory">Not exactly Muscle Memory</a></li>
<li><a href="#cookie-cutters">Cookie cutters</a></li>
<li><a href="#summary-1">Summary</a></li>
</ul></li>
</ul>
</div>
<p>Code for this project can be found in my <a href="https://github.com/rpeszek/experiments" target="_blank">experiments</a> github repo (<a href="https://github.com/rpeszek/experiments/tree/master/probability-tree-schemes" target="_blank">probability-tree-schemes</a> folder).</p>
<p>The goal of this post is to present a simple example that uses recursion schemes. My other goal is to discuss my thoughts about reasons for getting stuck on finding the right solution. It will be a bit of a rant.</p>
<p><strong>Motivation:</strong><br />
Last week I encountered a programming problem that kept defeating me. It took me forever just to figure out how to translate the requirements into something I can code. The gist of this problem turned out to be very straightforward: implement a probability tree diagram (a decision tree annotated with probabilities). Well not really, but close enough.<br />
I think, now, that the problem is simple, but it was not the case during the few hours I initially have spent on it. This experience was somewhat surprising to me as I have worked for several years with decision graphs (not trees, but still). I just I failed to make the association.</p>
<p>I am sharing my experience in this post. This post shows the solution program, and as such, ended up becoming a “tutorial” of sorts about the recursion schemes. I tried to make it easy to read even if some Haskell code is more at an intermediate level. In this tutorial I will get in trouble couple of times arriving at an incorrect solution.</p>
<p>At the end of this post (<a href="#why-finding-the-right-solution-is-sometimes-hard">Why Finding the Right Solution is Sometimes Hard?</a>) I rant about my beliefs pertaining to the question in the title.</p>
<h2 id="the-problem">The Problem</h2>
<p>Consider a tree with edges (or nodes) annotated with probability weights. The problem I am going to solve is simple: calculate the path likelihoods for each of the <em>leaves</em>. Basically multiply all the probabilities down each branch all the way to the leaf.</p>
<p>This is obviously not so hard, and the biggest challenge was to figure out that this was what the requirements needed.<br />
The solution seems like a good exercise and I am sharing my solutions here.</p>
<p>All the goodies (<code>a</code>) are at the leaves, in addition, each node is annotated with some probability <code>p</code> and a label <code>String</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">Data.Functor.Foldable.TH</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">ProbTree</span> p a <span class="ot">=</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>    <span class="dt">Leaf</span> p <span class="dt">String</span> a</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>    <span class="op">|</span> <span class="dt">Branches</span> p <span class="dt">String</span> [<span class="dt">ProbTree</span> p a]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>    <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Traversable</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>makeBaseFunctor '<span class="dt">'ProbTree</span></span></code></pre></div>
<p>The goal is implement a function that transforms <code>ProbTree NodeProb a</code> into <code>ProbTree CumulativeProb a</code>.</p>
<p>I will be using <a href="https://hackage.haskell.org/package/recursion-schemes" target="_blank"><em>recursion-schemes</em></a> package and <code>makeBaseFunctor</code> generates the code I will need to fold or unfold the tree. All the instances I have declared, <code>Functor, Foldable, Traversable</code>, are intended for the consumption of the goodies <code>a</code>. I will not care much about <code>a</code>-s in this post. I will care about the <code>p</code>-s.</p>
<p>This type is really a <code>Bifunctor</code> (Functor in both <code>p</code> and <code>a</code>), and most of the code I am going to show could just use that. Instead of implementing <code>Bifunctor</code> instance I will use:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.List</span> <span class="kw">as</span> <span class="dt">L</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="ot">probMap ::</span> (p1 <span class="ot">-&gt;</span> p2) <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> p1 a <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> p2 a</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>probMap fn (<span class="dt">Leaf</span> p l a) <span class="ot">=</span> <span class="dt">Leaf</span> (fn p) l a</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>probMap fn (<span class="dt">Branches</span> p l xs) <span class="ot">=</span> <span class="dt">Branches</span> (fn p) l <span class="op">$</span> L.map (probMap fn) xs</span></code></pre></div>
<p>However, for some examples I will need something stronger, I need it to be <code>Traversable</code> in <code>p</code>.<br />
I will just use the <a href="https://hackage.haskell.org/package/lens" target="_blank"><em>lens</em></a> package to get what I need. You do not need to know much about lenses to read on. I will try to explain the usage as I go.</p>
<p>Keeping <code>p</code> as a type variable is convenient and, for example, could allow me to use it for (<code>Natural</code>) distribution counts or other things that probabilities can morph into.</p>
<h3 id="why-is-this-useful">Why is this useful?</h3>
<p>Decision Trees are popular because of their ability to visualize outcomes of various processes.<br />
It is sometimes useful to know the distribution of the final outcomes. Think about using <em>QuickCheck</em> to randomly generate final outcomes or, maybe, randomly pick these outcomes from some big dataset of samples.<br />
<code>ProbTree p a</code> would use <code>a</code> to hold the generated values or to describe them in some way. It is convenient to keep the data samples <code>a</code> separate from probabilities <code>p</code> (instead of just using something like <code>RoseTree (p,a)</code>) because we care about these samples only at the final outcome / leaf level.<br />
The extra <code>String</code> label is for my own convenience. It allows me to trace how the recursion schemes work and will be handy in this presentation.<br />
<code>ProbTree p a</code> may not be the nicest to use when implementing recursion-schemes. All the better as the choice of training!</p>
<h3 id="plumbing">Plumbing</h3>
<p>So I have a lens that will let me ‘focus’ on the <code>p</code>-s:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">Control.Lens</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a><span class="co">-- | needs to be non-polymorphic because of nesting</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a><span class="ot">probability ::</span> <span class="dt">Lens'</span> (<span class="dt">ProbTree</span> p a) p</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>probability <span class="ot">=</span> lens get set </span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>    get (<span class="dt">Leaf</span> p _ _) <span class="ot">=</span> p</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>    get (<span class="dt">Branches</span> p _ _) <span class="ot">=</span> p</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>    set (<span class="dt">Leaf</span> _ l x) r <span class="ot">=</span> <span class="dt">Leaf</span> r l x</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a>    set (<span class="dt">Branches</span> _ l x) r <span class="ot">=</span> <span class="dt">Branches</span> r l x</span></code></pre></div>
<p>It is considered a bad karma to use Record syntax for types that have several constructors. So I coded this by hand. Otherwise template Haskell <code>makeLenses</code> could create <code>probability</code> if both constructors had a field with the same name <code>_probability :: p</code>. If you new to lenses, think that the above code <em>encapsulates</em> getting and setting <code>p</code>-s.<br />
This thing is what is called a simple lens. That means it does not allow me to change the <code>p</code> type. I will need something more flexible than that(<code>makeLenses</code> does not create what I need anyway).</p>
<p>In a dream, dependently typed, world there would be a type level guarantee that in <code>Branches (p1 :: p) String [ProbTree (pn :: p) a]</code> we have <code>1 ~ sum pn</code> for probability weights and <code>p1 ~ sum pn</code> for cumulative case.<br />
In reality, it would be nice to, at least, not use <code>p ~ Float</code> all the time.<br />
Since I will be changing the meaning of what <code>p</code> is from a probability assigned to a node to calculated cumulative probability of getting to this node:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">NodeProb</span> <span class="ot">=</span> <span class="dt">NodeProb</span> {<span class="ot">unNodeProb ::</span> <span class="dt">Float</span>} <span class="kw">deriving</span> <span class="dt">Eq</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">CumulativeProb</span> <span class="ot">=</span> <span class="dt">CumulativeProb</span> {<span class="ot">unCumulativeProb ::</span> <span class="dt">Float</span>} <span class="kw">deriving</span> <span class="dt">Eq</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a><span class="co">-- Show instances implemented, but not shown (pun not intended)</span></span></code></pre></div>
<p>To deal with swapping <code>p</code>’s I need to implement an honest to god traversal. Consider this as just a boilerplate:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="ot">probabilityT ::</span> <span class="kw">forall</span> p r a f <span class="op">.</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> </span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>    (p <span class="ot">-&gt;</span> f r) </span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>    <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> p a </span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>    <span class="ot">-&gt;</span> f (<span class="dt">ProbTree</span> r a)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>probabilityT fn (<span class="dt">Leaf</span> p l a) <span class="ot">=</span> <span class="dt">Leaf</span> <span class="op">&lt;$&gt;</span> fn p <span class="op">&lt;*&gt;</span> <span class="fu">pure</span> l <span class="op">&lt;*&gt;</span> <span class="fu">pure</span> a</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>probabilityT fn (<span class="dt">Branches</span> p l xs) <span class="ot">=</span> <span class="dt">Branches</span> <span class="op">&lt;$&gt;</span> fn p <span class="op">&lt;*&gt;</span> <span class="fu">pure</span> l <span class="op">&lt;*&gt;</span> fx xs</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>  <span class="kw">where</span><span class="ot"> fx ::</span> [<span class="dt">ProbTree</span> p a] <span class="ot">-&gt;</span> f [<span class="dt">ProbTree</span> r a]</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>        fx xs <span class="ot">=</span> <span class="fu">traverse</span> (probabilityT fn) xs</span></code></pre></div>
<p>Now I can implement cumulative probabilities working with <code>Float</code>s and expose them to external code using more descriptive types (<em>lens</em> <a href="https://hackage.haskell.org/package/lens-5.0.1/docs/Control-Lens-Iso.html"><code>Iso</code></a>-s would be nicer, this seems to work better in the context of this post):</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="ot">compWithFloats ::</span> </span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>   (<span class="dt">ProbTree</span> <span class="dt">Float</span> a <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">Float</span> a) </span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>   <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">NodeProb</span> a </span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>   <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">CumulativeProb</span> a</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>compWithFloats fn <span class="ot">=</span> over probabilityT <span class="dt">CumulativeProb</span> <span class="op">.</span> fn <span class="op">.</span> over probabilityT unNodeProb</span></code></pre></div>
<h3 id="example-tree">Example Tree</h3>
<p>I am now in the position to define a simple example tree:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="ot">exTree ::</span> <span class="dt">ProbTree</span> <span class="dt">NodeProb</span> ()</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>exTree <span class="ot">=</span> over probabilityT <span class="dt">NodeProb</span> <span class="op">$</span> <span class="dt">Branches</span> <span class="dv">1</span> <span class="st">&quot;R&quot;</span> [</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>   <span class="dt">Branches</span> <span class="fl">0.5</span> <span class="st">&quot;1&quot;</span> [</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>      <span class="dt">Branches</span> <span class="fl">0.5</span> <span class="st">&quot;11&quot;</span> [</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>          <span class="dt">Leaf</span> <span class="fl">0.5</span> <span class="st">&quot;111&quot;</span> ()</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a>          , <span class="dt">Leaf</span> <span class="fl">0.5</span> <span class="st">&quot;112&quot;</span> ()</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a>       ]</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>       , <span class="dt">Branches</span> <span class="fl">0.5</span> <span class="st">&quot;12&quot;</span> [</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>          <span class="dt">Leaf</span> <span class="dv">1</span> <span class="st">&quot;121&quot;</span> ()</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a>       ]</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a>   ]</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a>   , <span class="dt">Branches</span> <span class="fl">0.5</span> <span class="st">&quot;2&quot;</span> [</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true"></a>      <span class="dt">Leaf</span> <span class="fl">0.2</span> <span class="st">&quot;21&quot;</span> ()</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true"></a>      , <span class="dt">Leaf</span> <span class="fl">0.4</span> <span class="st">&quot;22&quot;</span> ()</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true"></a>      , <span class="dt">Branches</span> <span class="fl">0.4</span> <span class="st">&quot;23&quot;</span> [</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true"></a>          <span class="dt">Leaf</span> <span class="fl">0.5</span> <span class="st">&quot;231&quot;</span> ()</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true"></a>          , <span class="dt">Leaf</span> <span class="fl">0.5</span> <span class="st">&quot;232&quot;</span> ()</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true"></a>       ]</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true"></a>   ]</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true"></a> ]</span></code></pre></div>
<p>the lens <code>over</code> allows me to type the Floats and <code>map</code> these to the <code>NodeProb</code> type to indicate what the numbers represent at the type level. I will use this example moving forward. The final result (leaves only) of what I want to compute annotated with labels should look like this:</p>
<pre><code>&quot;(0.125,&quot;111&quot;),(0.125,&quot;112&quot;),(0.25,&quot;121&quot;),(0.1,&quot;21&quot;),(0.2,&quot;22&quot;),(0.1,&quot;231&quot;),(0.1,&quot;232&quot;)&quot;</code></pre>
<h3 id="traditional-solution-state-threads">Traditional Solution, State Threads</h3>
<p>There is a good possibility of finding a ready solution for the problem on <em>stackoverflow</em> or even in <em>wikipedia</em>.<br />
The code in some psedo-language that mutates variables would look something like:</p>
<pre><code>// some C-like language
// mutate in-place all probabilities on all nodes on a tree. 

calculateProbNode (weight, node) = 
   node.prob = weight * node.prob
   children = node.children
   for (child :: children) {
     calculateProb (node.prob, child)
   } 

calcuateProb (node) =  calculateProbNode (1, node)    </code></pre>
<p>Since I moved to Haskell, code like this started to scare me. It mutates things, returns nothing, and it is easy to get it wrong.<br />
However, there are reasons (e.g. performance) when code like this is needed.<br />
There it the misconceptions about Haskell not being able to mutate variables. In particular, variable mutation in internal implementation that leads to a referentially transparent result can be even implemented as a pure function. The tooling for this is called <code>ST</code> monad.</p>
<p>This is the above code implemented in Haskell:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">Control.Monad.ST</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">Data.STRef</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">MutableFloat</span> s <span class="ot">=</span> <span class="dt">STRef</span> s <span class="dt">Float</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a><span class="ot">computeProbMutable ::</span> <span class="kw">forall</span> a <span class="op">.</span> <span class="dt">ProbTree</span> <span class="dt">NodeProb</span> a <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">CumulativeProb</span> a </span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a>computeProbMutable <span class="ot">=</span> compWithFloats (</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a>    \t <span class="ot">-&gt;</span> runST <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a>        mutable <span class="ot">&lt;-</span> makeMutable t </span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true"></a>        mutableres <span class="ot">&lt;-</span> recursion <span class="dv">1</span> mutable</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true"></a>        makeNonMutable mutableres</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true"></a>    )</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true"></a> <span class="kw">where</span> </span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true"></a><span class="ot">   recursion ::</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> (<span class="dt">MutableFloat</span> s) a <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">ProbTree</span> (<span class="dt">MutableFloat</span> s) a)   </span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true"></a>   recursion n (<span class="dt">Branches</span> mutp l xs)  <span class="ot">=</span> <span class="kw">do</span> </span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true"></a>     modifySTRef mutp (n <span class="op">*</span>) <span class="co">-- modify probability in place</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true"></a>     n1 <span class="ot">&lt;-</span> readSTRef mutp   <span class="co">-- read modified probablity</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true"></a>     xs1 <span class="ot">&lt;-</span> <span class="fu">mapM</span> (recursion n1) xs <span class="co">-- recursively apply modified value to children</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true"></a>     <span class="fu">return</span> <span class="op">$</span> <span class="dt">Branches</span> mutp l xs1  </span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true"></a></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true"></a>   recursion n x<span class="op">@</span>(<span class="dt">Leaf</span> mutp _ _) <span class="ot">=</span> <span class="kw">do</span> </span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true"></a>     modifySTRef mutp (n <span class="op">*</span>)  <span class="co">-- on Leaf there is not much to do, only modify the propability</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true"></a>     <span class="fu">return</span> x</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true"></a></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true"></a><span class="co">-- | Traverse all Tree nodes and replace Float's with `MutableFloat`-s.</span></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true"></a><span class="ot">makeMutable ::</span> <span class="dt">ProbTree</span> <span class="dt">Float</span> a <span class="ot">-&gt;</span>  <span class="dt">ST</span> s (<span class="dt">ProbTree</span> (<span class="dt">MutableFloat</span> s) a)</span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true"></a>makeMutable <span class="ot">=</span>  </span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true"></a>   traverseOf probabilityT (newSTRef <span class="op">@</span><span class="dt">Float</span>)</span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true"></a></span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true"></a><span class="co">-- | Traverse all Tree nodes and replace `MutableFloat`-s with not mutable regular `Float`s</span></span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true"></a><span class="ot">makeNonMutable ::</span>  <span class="dt">ProbTree</span> (<span class="dt">MutableFloat</span> s) a <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">ProbTree</span> <span class="dt">Float</span> a) </span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true"></a>makeNonMutable <span class="ot">=</span> traverseOf probabilityT readSTRef</span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true"></a></span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt; tstMutable</span></span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true"></a><span class="co">-- &quot;(0.125,\&quot;111\&quot;,()),(0.125,\&quot;112\&quot;,()),(0.25,\&quot;121\&quot;,()),(0.1,\&quot;21\&quot;,()),(0.2,\&quot;22\&quot;,()),(0.1,\&quot;231\&quot;,()),(0.1,\&quot;232\&quot;,())&quot;</span></span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true"></a><span class="ot">tstMutable ::</span> <span class="dt">String</span></span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true"></a>tstMutable <span class="ot">=</span> printLeaves <span class="op">$</span> computeProbMutable exTree  </span></code></pre></div>
<p>The bulk of the code is translating from not mutable Haskell to mutable variable <code>type MutableFloat s = STRef s Float</code>. The rest is very similar to the psedo-code above.</p>
<p>If you are not familiar with <code>ST</code>, the <code>s</code> is existential and prevents mutable Floats from escaping the <code>ST</code> Monad. You can use them inside <code>ST</code> but not after you leave it.</p>
<p>What is mind-blowing to me is that Haskell introduced this in 1993! Now such existential tricks are used a lot (e.g. in dependently typed code) so the concept probably does not need much introduction.</p>
<h3 id="simple-recursion-schemes">Simple Recursion Schemes</h3>
<p>The above solution leaves a bad taste in my mouth. The idea I will pursue is that I can compute these values by <em>folding</em> or maybe <em>unfolding</em> the tree. This example uses the <a href="https://hackage.haskell.org/package/recursion-schemes" target="_blank"><em>recursion-schemes</em></a> package. I am not going to delve deep into recursion schemes. My goal is to show the code with high level explanations for how and why it works.</p>
<p>Great information about some of the category theoretical background can be found in Bartosz Milewski’s <a href="https://bartoszmilewski.com/2017/02/28/f-algebras/" target="_blank">CTFP Book, F-Algebras secion</a>.<br />
There is a series of blogs devoted to recursion-schemes by Patrick Thomson that are very good reading as well <a href="https://blog.sumtypeofway.com/posts/introduction-to-recursion-schemes.html" target="_blank">An Introduction to Recursion Schemes</a>.</p>
<p><strong>Quick intro to recursion-schemes.</strong></p>
<p>The Template Haskell instruction, <code>makeBaseFunctor ''ProbTree</code>, we have started with generated a new type that looks like this:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">ProbTreeF</span> p a r <span class="ot">=</span> <span class="dt">LeafF</span> p <span class="dt">String</span> a <span class="op">|</span> <span class="dt">BranchesF</span> p <span class="dt">String</span> [r]</span></code></pre></div>
<p>As you can see, <code>ProbTreeF</code> is very similar to <code>ProbTree</code>, except the original ‘recursive’ <code>ProbTree p a</code> in <code>Branches p String [ProbTree p a]</code> got replaced with a new type variable <code>r</code> in <code>BranchesF p String [r]</code>.</p>
<p><em>recursion_schemes</em> uses <code>Base t</code> type family and <code>ProbTreeF p a r</code> is the <em>Base</em> functor for <code>ProbTree</code>.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Base</span><span class="ot"> t ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Base</span> (<span class="dt">ProbTree</span> p a) <span class="ot">=</span> <span class="dt">ProbTreeF</span> p a</span></code></pre></div>
<p>and the library uses <code>Base</code> in all of its definitions. I will use <code>ProbTreeF</code> for clarity.</p>
<p>Classic recursion scheme code often starts with the base functor and derives the recursive target type by applying <a href="https://hackage.haskell.org/package/data-fix-0.3.1/docs/Data-Fix.html#g:1" target="_blank"><em>Fix</em></a> from <a href="https://hackage.haskell.org/package/data-fix" target="_blank"><code>data-fix</code></a>. Both are isomorphic:</p>
<pre><code>Fix (ProbTreeF p a) =~ ProbTree p a</code></pre>
<p>If this is new to you it will take some time digest. (<strong>end</strong>)</p>
<h4 id="catamorphism">Catamorphism</h4>
<p>As a warm-up let’s fold the tree by collecting information about leaves onto a single String:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="ot">printLeaves ::</span> <span class="kw">forall</span> p a<span class="op">.</span> (<span class="dt">Show</span> p, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">ProbTree</span> p a <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>printLeaves <span class="ot">=</span> fold fn</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a><span class="ot">      fn ::</span> <span class="dt">ProbTreeF</span> p a <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>      fn (<span class="dt">LeafF</span> n lb a) <span class="ot">=</span> <span class="fu">show</span> (n, lb, a)</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a>      fn (<span class="dt">BranchesF</span> _ _ xs) <span class="ot">=</span> L.intercalate <span class="st">&quot;,&quot;</span> xs</span></code></pre></div>
<p>This code folds the tree onto a String by spelling out the <code>LeafF</code> content and then by concatenating the strings using comma when processing <code>BranchesF</code>.</p>
<p><strong>Back to a quick into:</strong><br />
The <em>Base</em> functor for <em>List</em> (i.e. <code>[]</code>) looks like this:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">ListF</span> a b <span class="ot">=</span> <span class="dt">Nil</span> <span class="op">|</span> <span class="dt">Cons</span> a b </span></code></pre></div>
<p>folding a list would amount to:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="ot">printList ::</span> (<span class="dt">Show</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>printList <span class="ot">=</span> fold fn</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a><span class="ot">      fn ::</span> <span class="dt">ListF</span> a <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>      fn <span class="dt">Nil</span> <span class="ot">=</span> <span class="st">&quot;(START)&quot;</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a>      fn (<span class="dt">Cons</span> a str) <span class="ot">=</span> <span class="fu">show</span> a <span class="op">&lt;&gt;</span> <span class="st">&quot;:&quot;</span> <span class="op">&lt;&gt;</span> str</span></code></pre></div>
<p>compare it to</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>printList' <span class="ot">=</span> L.foldr (\a str <span class="ot">-&gt;</span> <span class="fu">show</span> a <span class="op">&lt;&gt;</span> <span class="st">&quot;,&quot;</span> <span class="op">&lt;&gt;</span> str) <span class="st">&quot;(START)&quot;</span> </span></code></pre></div>
<p>These are effectively the same!</p>
<p>Ability to fold arbitrary recursive data is rely very convenient. For example, JSON data served by some micro-services may lack consistency (not all micro-services are implemented in Haskell, you know)</p>
<blockquote>
<p>“What if I told you it is possible to fold JSON values?”</p>
</blockquote>
<p>Morpheus, The Matrix</p>
<p><em>recursion-schemes</em> defines <em>cata</em> as an alternative name for <em>fold</em>. <em>cata</em> seems to be more popular and stands for <em>catamorphism</em>. (<strong>end</strong>)</p>
<p><strong>Continuing the warm-up:</strong></p>
<p>We can do effectful things too!</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="ot">printIO ::</span> <span class="kw">forall</span> p a<span class="op">.</span> (<span class="dt">Show</span> p, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">ProbTree</span> p a <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">String</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a>printIO <span class="ot">=</span> fold fn</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a><span class="ot">      fn ::</span> <span class="dt">ProbTreeF</span> p a (<span class="dt">IO</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">String</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a>      fn (<span class="dt">LeafF</span> n lb a) <span class="ot">=</span> <span class="kw">do</span> </span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a>          <span class="fu">print</span> (n, lb, a) <span class="co">-- as before</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true"></a>          <span class="fu">return</span> <span class="op">$</span> <span class="st">&quot;done leaf &quot;</span> <span class="op">&lt;&gt;</span> lb</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true"></a>      fn (<span class="dt">BranchesF</span> _ lb ixs) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true"></a>           xs <span class="ot">&lt;-</span> <span class="fu">sequence</span> ixs</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true"></a>           <span class="fu">print</span> <span class="op">$</span> <span class="st">&quot;Processed so far: &quot;</span> <span class="op">++</span> <span class="fu">show</span> xs</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true"></a>           <span class="fu">return</span> <span class="op">$</span> <span class="st">&quot;done branch &quot;</span> <span class="op">&lt;&gt;</span> lb</span></code></pre></div>
<p>This will print content of leaves, when processing branches will print what it processed before.</p>
<p>It produces this output:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="op">*</span><span class="dt">Schemes</span><span class="op">&gt;</span> tstPrintIO</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a>(<span class="fl">0.5</span>,<span class="st">&quot;111&quot;</span>,())</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a>(<span class="fl">0.5</span>,<span class="st">&quot;112&quot;</span>,())</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a><span class="st">&quot;Processed so far: [\&quot;done leaf 111\&quot;,\&quot;done leaf 112\&quot;]&quot;</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a>(<span class="fl">1.0</span>,<span class="st">&quot;121&quot;</span>,())</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true"></a><span class="st">&quot;Processed so far: [\&quot;done leaf 121\&quot;]&quot;</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true"></a><span class="st">&quot;Processed so far: [\&quot;done branch 11\&quot;,\&quot;done branch 12\&quot;]&quot;</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true"></a>(<span class="fl">0.2</span>,<span class="st">&quot;21&quot;</span>,())</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true"></a>(<span class="fl">0.4</span>,<span class="st">&quot;22&quot;</span>,())</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true"></a>(<span class="fl">0.5</span>,<span class="st">&quot;231&quot;</span>,())</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true"></a>(<span class="fl">0.5</span>,<span class="st">&quot;232&quot;</span>,())</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true"></a><span class="st">&quot;Processed so far: [\&quot;done leaf 231\&quot;,\&quot;done leaf 232\&quot;]&quot;</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true"></a><span class="st">&quot;Processed so far: [\&quot;done leaf 21\&quot;,\&quot;done leaf 22\&quot;,\&quot;done branch 23\&quot;]&quot;</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true"></a><span class="st">&quot;Processed so far: [\&quot;done branch 1\&quot;,\&quot;done branch 2\&quot;]&quot;</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true"></a><span class="st">&quot;done branch R&quot;</span></span></code></pre></div>
<h4 id="solution-using-anamorphism">Solution using Anamorphism</h4>
<p>Instead of using <code>fold</code> / <code>cata</code>-morphism, I will first use its opposite: <code>unfold</code> / <code>ana</code>-morphism to solve the problem of computing the commutative probabilities.<br />
We will solve the problem by unfolding the tree onto itself (I will be constructing <code>ProbTreeF</code>).<br />
<em>recusion-schemes</em> provides a convenient <code>project</code> function that typically can be used to implement all the uninteresting cases when unfolding the structure onto itself:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt; printLeaves . computeProb $ exTree</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a><span class="co">-- &quot;(0.125,\&quot;111\&quot;,()),(0.125,\&quot;112\&quot;,()),(0.25,\&quot;121\&quot;,()),(0.1,\&quot;21\&quot;,()),(0.2,\&quot;22\&quot;,()),(0.1,\&quot;231\&quot;,()),(0.1,\&quot;232\&quot;,())&quot;</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a><span class="ot">computeProb ::</span> <span class="dt">ProbTree</span> <span class="dt">NodeProb</span> a <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">CumulativeProb</span> a</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a>computeProb <span class="ot">=</span> compWithFloats (unfold fn)</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true"></a><span class="ot">    fn ::</span> <span class="dt">ProbTree</span> <span class="dt">Float</span> a <span class="ot">-&gt;</span> <span class="dt">ProbTreeF</span> <span class="dt">Float</span> a (<span class="dt">ProbTree</span> <span class="dt">Float</span> a)</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true"></a>    fn (<span class="dt">Branches</span> n l xs) <span class="ot">=</span> <span class="dt">BranchesF</span> n l (L.map (over probability (<span class="op">*</span> n)) xs)</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true"></a>    fn x <span class="ot">=</span> project x</span></code></pre></div>
<p>the only interesting case is unfolding the <code>Branches n l xs</code> constructor. It is unfolded into <code>BranchesF n l xs'</code> where <code>xs'</code> is a list of children with probability modified by the current value on the branch. This line makes the computation flow towards the leaves. Thus, we can assume that the current probability value <code>n</code> has been already computed.</p>
<p>Note that to test print the outcome, we have unfolded the tree in <code>computeProb</code> and then folded it using <code>printLeaves</code> there is a convenience function <code>hylo</code> or <code>refold</code> included in <em>recursion-schemes</em> package that does exactly that.</p>
<h4 id="back-to-catamorphism.">Back to Catamorphism.</h4>
<p>(EDITED, previous version of this post had it wrong, thanks <a href="https://www.reddit.com/r/haskell/comments/onrhtw/probability_tree_diagrams_recursion_schemes_why/h684cpr?utm_source=share&amp;utm_medium=web2x&amp;context=3" target="_blank">r/Tarmen</a>)</p>
<p>In the previous section, I have unfolded the tree onto itself. That did not really unfold or construct much as the unfolding type was the tree itself. We can as well try the same trick using <code>cata</code> or <code>fold</code>, since we will not be destroying / folding much either.</p>
<p><em>recusion-schemes</em> provides a convenient <code>embed</code> function that typically can be used to implement all the uninteresting cases:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="co">-- |</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt; printLeaves . computeProbBad $ exTree</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a><span class="co">-- &quot;(0.25,\&quot;111\&quot;,()),(0.25,\&quot;112\&quot;,()),(0.5,\&quot;121\&quot;,()),(0.1,\&quot;21\&quot;,()),(0.2,\&quot;22\&quot;,()),(0.2,\&quot;231\&quot;,()),(0.2,\&quot;232\&quot;,())&quot;</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a><span class="ot">computeProbBad ::</span> <span class="dt">ProbTree</span> <span class="dt">NodeProb</span> a <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">CumulativeProb</span> a</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a>computeProbBad <span class="ot">=</span> compWithFloats (cata fn)</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true"></a><span class="ot">      fn ::</span> <span class="dt">ProbTreeF</span> <span class="dt">Float</span> a (<span class="dt">ProbTree</span> <span class="dt">Float</span> a) <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">Float</span> a</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true"></a>      fn (<span class="dt">BranchesF</span> n l xs) <span class="ot">=</span> <span class="dt">Branches</span> n l (L.map (over probability (<span class="op">*</span> n)) xs)</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true"></a>      fn x <span class="ot">=</span> embed x</span></code></pre></div>
<p>notice there is a problem, the numbers are off. The problem is subtle. The <em>lens</em> over just modifies the current node, what we want is to apply the probability modification to the whole subtree:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt; printLeaves . computeProbCata $ exTree</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a><span class="co">-- &quot;(0.125,\&quot;111\&quot;,()),(0.125,\&quot;112\&quot;,()),(0.25,\&quot;121\&quot;,()),(0.1,\&quot;21\&quot;,()),(0.2,\&quot;22\&quot;,()),(0.1,\&quot;231\&quot;,()),(0.1,\&quot;232\&quot;,())&quot;</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a><span class="ot">computeProbCata ::</span> <span class="dt">ProbTree</span> <span class="dt">NodeProb</span> a <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">CumulativeProb</span> a</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a>computeProbCata <span class="ot">=</span> compWithFloats (cata fn)</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true"></a><span class="ot">      fn ::</span> <span class="dt">ProbTreeF</span> <span class="dt">Float</span> a (<span class="dt">ProbTree</span> <span class="dt">Float</span> a) <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">Float</span> a</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true"></a>      fn (<span class="dt">BranchesF</span> n l xs) <span class="ot">=</span> <span class="dt">Branches</span> n l (L.map (probMap (<span class="op">*</span> n)) xs)</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true"></a>      fn x <span class="ot">=</span> embed x</span></code></pre></div>
<p>This works, but it is interesting to play little more with folding just to see how else I can get in trouble.</p>
<h4 id="st-example">ST Example</h4>
<p><strong>Bad attempt:</strong></p>
<p>If you looked closely at the <code>printIO</code> example in the <a href="#catamorphism">Catamorphism</a> section, you may have noticed that that the fold of <code>Branches</code> was able to do effecty things on the children. We can use the same approach to our advantage.<br />
We will go into a mutating franzy and fold <code>ProbTree</code> into just <code>MutableFloat s</code>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="ot">computeSTBad ::</span> <span class="kw">forall</span> s a <span class="op">.</span> <span class="dt">ProbTree</span> (<span class="dt">ST</span> s (<span class="dt">MutableFloat</span> s)) a <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">MutableFloat</span> s)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a>computeSTBad <span class="ot">=</span> fold fn</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a><span class="ot">      fn ::</span> <span class="dt">ProbTreeF</span> (<span class="dt">ST</span> s (<span class="dt">MutableFloat</span> s)) a (<span class="dt">ST</span> s (<span class="dt">MutableFloat</span> s)) <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">MutableFloat</span> s)</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a>      fn (<span class="dt">LeafF</span> n _ _) <span class="ot">=</span> n</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true"></a></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true"></a>      fn (<span class="dt">BranchesF</span> stmn lb ixs) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true"></a><span class="ot">           mn ::</span> <span class="dt">MutableFloat</span> s <span class="ot">&lt;-</span> stmn</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true"></a><span class="ot">           n ::</span> <span class="dt">Float</span> <span class="ot">&lt;-</span> readSTRef mn <span class="co">-- read branch proability</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true"></a><span class="ot">           mxs ::</span> [<span class="dt">MutableFloat</span> s] <span class="ot">&lt;-</span> <span class="fu">sequence</span> ixs <span class="co">-- get access to mutable probablities for direct children </span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true"></a>           <span class="fu">mapM_</span> (<span class="ot">`modifySTRef`</span> (n <span class="op">*</span>)) mxs <span class="co">-- mutate the children's probabilities (This even sounds wrong!)</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true"></a>           stmn <span class="co">-- return back the untouched branch probability</span></span></code></pre></div>
<p>Making this into a pure function requires even crazier mutations (this reuses previously defined <code>makeMutable</code> and <code>makeNonMutable</code>):</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="ot">computeProbMutableBad ::</span> <span class="kw">forall</span> a <span class="op">.</span> <span class="dt">ProbTree</span> <span class="dt">NodeProb</span> a <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">CumulativeProb</span> a</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a>computeProbMutableBad <span class="ot">=</span> compWithFloats (</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a>    \t <span class="ot">-&gt;</span> runST <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a>        mutable <span class="ot">&lt;-</span> makeMutable t</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a>        mutable' <span class="ot">&lt;-</span> traverseOf probabilityT (<span class="fu">pure</span> <span class="op">.</span> <span class="fu">pure</span>) mutable</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true"></a>        computeSTBad mutable'</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true"></a>        makeNonMutable mutable</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true"></a>    )</span></code></pre></div>
<p>the result of <code>computeST mutable</code> is discarded, and I use <code>pure . pure</code> (double effectful?), how crazy is that!</p>
<p>But, we see exactly the same issue as with our naive <code>cata</code> attempt in the previous section:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a><span class="co">-- |</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt; tstMutableBad</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a><span class="co">-- &quot;(0.25,\&quot;111\&quot;,()),(0.25,\&quot;112\&quot;,()),(0.5,\&quot;121\&quot;,()),(0.1,\&quot;21\&quot;,()),(0.2,\&quot;22\&quot;,()),(0.2,\&quot;231\&quot;,()),(0.2,\&quot;232\&quot;,())&quot;</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true"></a><span class="ot">tstMutableBad ::</span> <span class="dt">String</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true"></a>tstMutableBad <span class="ot">=</span> printLeaves <span class="op">$</span> computeProbMutableBad exTree</span></code></pre></div>
<p>This approach applies the correction to probabilities of the node children. We need to apply the correction all the way down the child subtree!</p>
<p><strong>So let’s fix it:</strong></p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a><span class="ot">computeST ::</span> <span class="kw">forall</span> s a <span class="op">.</span> <span class="dt">ProbTree</span> (<span class="dt">ST</span> s (<span class="dt">MutableFloat</span> s)) a <span class="ot">-&gt;</span> <span class="dt">ST</span> s [<span class="dt">MutableFloat</span> s]</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a>computeST <span class="ot">=</span> fold fn</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true"></a><span class="ot">      fn ::</span> <span class="dt">ProbTreeF</span> (<span class="dt">ST</span> s (<span class="dt">MutableFloat</span> s)) a (<span class="dt">ST</span> s [<span class="dt">MutableFloat</span> s]) <span class="ot">-&gt;</span> <span class="dt">ST</span> s [<span class="dt">MutableFloat</span> s]</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true"></a>      fn (<span class="dt">LeafF</span> n _ _) <span class="ot">=</span>  (<span class="op">:</span>[]) <span class="op">&lt;$&gt;</span> n</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true"></a>      </span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true"></a>      fn (<span class="dt">BranchesF</span> stmn lb ixs) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true"></a><span class="ot">        mn ::</span> <span class="dt">MutableFloat</span> s <span class="ot">&lt;-</span> stmn</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true"></a><span class="ot">        n ::</span> <span class="dt">Float</span> <span class="ot">&lt;-</span> readSTRef mn <span class="co">-- read branch proability</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true"></a><span class="ot">        mxs ::</span> [<span class="dt">MutableFloat</span> s] <span class="ot">&lt;-</span> <span class="fu">concat</span> <span class="op">&lt;$&gt;</span> <span class="fu">sequence</span> ixs <span class="co">-- get access to mutable probablities for children </span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true"></a>        <span class="fu">mapM_</span> (<span class="ot">`modifySTRef`</span> (n <span class="op">*</span>)) mxs <span class="co">-- mutate the subtree's probabilities </span></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true"></a>        <span class="fu">pure</span> <span class="op">$</span> mn <span class="op">:</span> mxs <span class="co">--return all mutable floats, including the current node</span></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true"></a></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true"></a><span class="ot">computeProbMutable ::</span> <span class="kw">forall</span> a <span class="op">.</span> <span class="dt">ProbTree</span> <span class="dt">NodeProb</span> a <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">CumulativeProb</span> a</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true"></a>computeProbMutable <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true"></a></span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true"></a><span class="co">-- |</span></span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt; tstMutable</span></span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true"></a><span class="co">-- &quot;(0.125,\&quot;111\&quot;,()),(0.125,\&quot;112\&quot;,()),(0.25,\&quot;121\&quot;,()),(0.1,\&quot;21\&quot;,()),(0.2,\&quot;22\&quot;,()),(0.1,\&quot;231\&quot;,()),(0.1,\&quot;232\&quot;,())&quot;</span></span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true"></a><span class="ot">tstMutable ::</span> <span class="dt">String</span></span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true"></a>tstMutable <span class="ot">=</span> printLeaves <span class="op">$</span> computeProbMutable exTree</span></code></pre></div>
<p>It works! The trick was to change to folding structure to accumulate all mutable floats for the whole subtree and keep mutating them.<br />
The key is to find the correct structure to fold onto.</p>
<p>I do not like code like this type of code, but, I think, it does provide interesting imperative intuitions about the recursive fold.</p>
<h4 id="catamorphism.-reader-example.">Catamorphism. Reader Example.</h4>
<p>But there is a nice solution that learns from the previous <code>ST</code> example and is very close to the idea of folding the tree onto itself:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">Control.Monad.Reader</span> </span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt; printLeaves . computeProbRdr $ exTree</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true"></a><span class="co">-- &quot;(0.125,\&quot;111\&quot;,()),(0.125,\&quot;112\&quot;,()),(0.25,\&quot;121\&quot;,()),(0.1,\&quot;21\&quot;,()),(0.2,\&quot;22\&quot;,()),(0.1,\&quot;231\&quot;,()),(0.1,\&quot;232\&quot;,())&quot;</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true"></a><span class="ot">computeProbRdr ::</span> <span class="dt">ProbTree</span> <span class="dt">NodeProb</span> a <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">CumulativeProb</span> a</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true"></a>computeProbRdr <span class="ot">=</span> compWithFloats (\t <span class="ot">-&gt;</span> runReader (computePropRdr t) <span class="dv">1</span>)</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true"></a></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true"></a><span class="ot">computePropRdr ::</span> <span class="dt">ProbTree</span> <span class="dt">Float</span> a <span class="ot">-&gt;</span> <span class="dt">Reader</span> <span class="dt">Float</span> (<span class="dt">ProbTree</span> <span class="dt">Float</span> a)</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true"></a>computePropRdr <span class="ot">=</span> cata fn</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true"></a><span class="ot">    fn ::</span> <span class="dt">ProbTreeF</span> <span class="dt">Float</span> a (<span class="dt">Reader</span> <span class="dt">Float</span> (<span class="dt">ProbTree</span> <span class="dt">Float</span> a)) <span class="ot">-&gt;</span> <span class="dt">Reader</span> <span class="dt">Float</span> (<span class="dt">ProbTree</span> <span class="dt">Float</span> a)</span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true"></a>    fn (<span class="dt">BranchesF</span> n l xs) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true"></a>      p <span class="ot">&lt;-</span> ask</span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true"></a>      xss <span class="ot">&lt;-</span> <span class="fu">mapM</span> (local (<span class="op">*</span>n)) xs</span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true"></a>      <span class="fu">pure</span> <span class="op">$</span> <span class="dt">Branches</span> (p <span class="op">*</span> n) l xss</span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true"></a>    fn (<span class="dt">LeafF</span> n l a) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true"></a>      p <span class="ot">&lt;-</span> ask</span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true"></a>      <span class="fu">pure</span> <span class="op">$</span> <span class="dt">Leaf</span> (p <span class="op">*</span> n) l a  </span></code></pre></div>
<p>If you are not using <code>Reader</code> a lot it may be easier to look at this, more explicit solution:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a><span class="ot">computeProbFn ::</span> <span class="dt">ProbTree</span> <span class="dt">Float</span> a <span class="ot">-&gt;</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">Float</span> a</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true"></a>computeProbFn <span class="ot">=</span> cata fn</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true"></a><span class="ot">    fn ::</span> <span class="dt">ProbTreeF</span> <span class="dt">Float</span> a (<span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">Float</span> a) <span class="ot">-&gt;</span> (<span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">Float</span> a)</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true"></a>    fn (<span class="dt">BranchesF</span> n l xs) p <span class="ot">=</span> <span class="dt">Branches</span> (p <span class="op">*</span> n) l <span class="op">$</span> L.map (\fn <span class="ot">-&gt;</span> fn <span class="op">.</span> ( <span class="op">*</span>n ) <span class="op">$</span> p ) xs</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true"></a>    fn (<span class="dt">LeafF</span> n l a) p <span class="ot">=</span> <span class="dt">Leaf</span> (p <span class="op">*</span> n) l a</span></code></pre></div>
<p>What we are accumulating, is the ability to conjure a descendant tree at any point from the current probability <code>Float</code>.<br />
We “conjure” the tree by modifying how the children are being “conjured”: we pre-compose <code>(* n)</code> (<code>n</code> is current node probability) to each of the functions that “conjure” the children. This forces recomputation of the probabilities all the way down to the leaves.<br />
This, no longer stops at depth 2.</p>
<h4 id="summary">Summary</h4>
<p>I have shown a few ways to compute <code>ProbTree CumulativeProb a</code>. I ended up getting in trouble a couple of times. <em>In fact, the original version of this post had bugs in it!</em> Recursion is dangerous, recursion has gotcha’s, it has to! Recursion is power with a price tag. Types is not very helpful when we recurse:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a><span class="ot">myUndefined ::</span> a</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true"></a>myUndefined <span class="ot">=</span> myUndefined</span></code></pre></div>
<p>It is easy to get in trouble!</p>
<h2 id="why-finding-the-right-solution-is-sometimes-hard">Why Finding the Right Solution is Sometimes Hard?</h2>
<p><strong>Rant Alert.</strong> This is about the cases where we know or knew how to do thing well but we get stuck anyway. Obviously, finding better and even better ways for writing code is a subject of a never ending research, I am not going to discuss that.</p>
<p>Haskell is an amazingly efficient tool for writing new code when our fingertips know what to do.<br />
Sometimes they do not, and then it is not much better than other languages. It lets us brute-force the code to satisfy the requirements. It is Turing complete, meaning that you can write as much nonsense as you want.</p>
<p>What bit me is:</p>
<ul>
<li>Short amount of time (few hours)</li>
<li>Difficulty in identifying a nice abstraction to solve the problem</li>
<li>The abstractions I ended up wanting to use were not in my short memory</li>
</ul>
<p>So instead I went pushing a brute-force solution…</p>
<p>This experience put me in a philosophical mood of trying to pin-point the reasons why sometimes the code just writes itself and sometimes we get stuck.</p>
<h3 id="human-condition">Human condition</h3>
<p>The underlying reason for why I do something wrong is typically me.<br />
We are not perfect, probably nothing shows it better than the software we write.</p>
<blockquote>
<p>“The universal aptitude for ineptitude makes any human accomplishment an incredible miracle”</p>
</blockquote>
<p>Stapp’s Law</p>
<p>Stapp and Murphy (his coworker) laws are not about giving up, these statements are about understanding our limitations and acting on this understanding.</p>
<h3 id="time-pressure">Time Pressure</h3>
<p>A hard deadline of a few hours does not (typically) happen in software engineering when writing a new code. It does for some data scientist. It also happens in competitive programming. I am not a competitive programmer and I believe very few programmers are.</p>
<p>Software engineers have to (sometimes) work with a short hard timeline when troubleshooting critical application errors. I believe, seasoned developers get years of conditioning that puts them into a troubleshooting mindset when under stress. This is not a creative mindset effective in designing a new code.</p>
<p>For code that is not a cookie-cutter, I believe I write the best code at night, when I sleep. Sometimes I need a few nights. It took two nights (no involvement otherwise) and then &lt; 1 hour of coding for the core examples presented here. It is not just about the time spend on the task, it is often about the latency.</p>
<p>Time pressure can be very destructive. It can reduce both the development speed and the code quality.<br />
That applies to longer time scales as well. Software industry, in my experience, is focused on short term goals. Quality is a long term goal.<br />
No project can afford to have no time constraints, so a balance needs to be struck. I believe the trade-offs are not well understood by the decision makers. … But this is well beyond what this post is about.</p>
<p>‘Uncle Bob’ (Robert C. Martin) likes to talk about a process in which you are not done when you finish writing the code and it works. It is the sweat time for making the code nice.</p>
<h3 id="large-bag-of-tricks">Large Bag of Tricks</h3>
<p>In this analogy a programmer is a magician with a bag of tricks. The bigger the bag the better the programmer. It takes more effort to sort through a bigger bag. There are some interesting indexers in that solution space allowing really good programmers to find a trick faster. One such indexer is the Category Theory. In general, any conceptual understanding of something is a record in some imaginary index.</p>
<p>The index record does not contain all the details, it is just a pointer, it takes time to load the actual details into short memory. That could involve looking up some stuff in the code or re-reading an article… Developer is a magician that needs time to prepare before he pulls out an <strong>old</strong> trick.</p>
<h3 id="not-exactly-muscle-memory">Not exactly Muscle Memory</h3>
<p><em>Muscle Memory</em> is a sports term. You train muscle memory so the movements happen on an auto-pilot.<br />
Muscle memory tends to be a long term memory (“it is like riding a bike”), it is also hard to change. This resistance to change could manifest itself as ‘bad muscle habits’ (e.g. a ski instructor skiing with a slight wedge, static body when making a shot in tennis…). Muscle memory is a long term memory, however athletes still require a warm-up lap / game / run…</p>
<p>For a long time, I have observed something very similar in programmers. Programming work is surprisingly repetitive, we develop something that resembles ‘muscle memory’ without even realizing it. We can do things much faster when we work on familiar problems. We are expert cookie-cutters.</p>
<p>Programmers tend to repeat the previously used patterns, even if these patterns are inferior to other methods (“bad muscle habits”).</p>
<p>Mainstream resistance to FP can be viewed as an example of resistance to change the “muscle memory”.</p>
<p>The analogy is not perfect. We do not need to do a warm-up typing when we start work, instead, we do need longer warm-up period when switching to a programming area we neglected for months or years. For me, that applies especially to the ability to translate ‘real world requirements’ to code design. I will just not think in terms that are not in my short memory, especially when under time pressure.</p>
<h3 id="cookie-cutters">Cookie cutters</h3>
<p>Cookie cutting is not just about repeating ingrained habits. I believe there is some project to project, program to program inertia which makes us want to repeat the same approach. This is not necessarily a bad thing if we are aware of it and if we are not afraid to explore other options.</p>
<p>Even looking at the job interview process, notice the focus on finding someone with a very closely fitting background.<br />
Have you ever seen a job posting asking for someone with a significantly different skill set from what the group already has? Hiring managers want to find cookie-cutters that can make cookies of a very similar shape that their team bakes.<br />
I think this is not optimal in long term. This bias creates groups with a narrow pool of experience and expertise.</p>
<p>I have to consider myself a cookie cutter too. The choices I made in the code I design are be biased by my other work.</p>
<h3 id="summary-1">Summary</h3>
<p>We can’t change who we are, we are unlikely to change the industry.</p>
<p>Instead, we can try to train “good movements” into our “muscle memory” and grow our bag of tricks.</p>
<blockquote>
<p>“In short, I suggest that the programmer should continue to understand what he is doing, that his growing product remains firmly within his intellectual grip.”</p>
</blockquote>
<p>Edsger W. Dijkstra</p>
<p>My conclusion is this: it does not really matter if I get stuck and can’t figure it out for a few days. For some problems I will be stuck for much longer.<br />
I am talking about pursuit of a well designed code, not finding a brute-force kludge.<br />
What really matters is not giving up and eventually figuring it out.</p>
<blockquote>
<p>“You must understand, young Hobbit, it takes a long time to say anything in Old Entish. And we never say anything unless it is worth taking a long time to say.”</p>
</blockquote>
<p>J.R.R Tolkien and Treebeard</p>
<p>The original version of this post had bugs.<br />
Yeah, what really matters is not giving up and eventually figuring it out;) I this post I ate my own dog food.</p>

    </section>
</article>

        </main>

        <footer>
             <span><a href="../atom.xml">Atom</a></span>
             <span><a href="../RSS.xml">RSS</a></span>
             <span>Site generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a></span>
        </footer>
    </body>
</html>
