<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Infrequent, Pragmatic, Lambda Blog - Type Enthusiast's Notes about TypeScript. Part 3. TS Complexity</title>
        <link rel="alternate" type="application/atom+xml" href="https://rpeszek.github.io/atom.xml" title="atom" />
        <link rel="alternate" type="application/rss+xml" href="https://rpeszek.github.io/RSS.xml" title="rss" />
        <!-- <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="atom"/>
        <link rel="alternate" type="application/rss+xml" href="/RSS.xml" title="rss"/> -->
        <link rel="stylesheet" href="../css/reset.css" />
        <link rel="stylesheet" href="../css/predefault.css" />
        <link rel="stylesheet" href="../css/default.css" />
        
        <link rel="stylesheet" href="../css/ts.css" />
        
        
    </head>
    <body>
        <header>
            <div class="motto">
                <a href="../">hmm >>= oh!</a>
            </div>
            <div class="logo">
                <a href="../">Infrequent, Pragmatic, Lambda Blog</a>
            </div>
            <nav>
                <!-- <a href="/">Home</a> -->
                <a href="../thoughts.html">Semiserious</a>
                <a href="../about.html">About</a>
                <!-- <a href="/contact.html">Contact</a> -->
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>Type Enthusiast's Notes about TypeScript. Part 3. TS Complexity</h1>
            <article>
    <section class="header">
        Posted on January  3, 2022
        
            by Robert Peszek
        
        
        
        <div class="changelog"> <div>Revision History: <ul> <li> (2022.01.03 - Present) Changes are documented in <a href="#summary-of-final-edits">Summary of final edits</a>. </ul> </div></div>
        
        
        <div class="info">Tags: <a title="All pages tagged 'TypeScript-Notes'." href="../tags/TypeScript-Notes.html">TypeScript-Notes</a></div>
        
    </section>
    <section>

    </section>
    <section>
        <div class="toc"><div class="header">Table of Contents</div>
<ul>
<li><a href="#nutshell">Nutshell</a></li>
<li><a href="#interesting-safety">Interesting safety</a>
<ul>
<li><a href="#apple-orange-type-safety"><code>apple !== orange</code> type safety</a></li>
<li><a href="#switch-exhaustive-check"><code>switch</code> exhaustive check</a></li>
<li><a href="#null-undefined-safety"><code>null</code> / <code>undefined</code> safety</a></li>
</ul></li>
<li><a href="#complexity-of-ts-types">Complexity of TS types</a>
<ul>
<li><a href="#semantics-rejected-overlap"><code>===</code> semantics, rejected overlap</a></li>
<li><a href="#semantics-whats-an-overlap"><code>===</code> semantics, what’s an overlap?</a></li>
<li><a href="#hidden-blooper-side-note">Hidden blooper (side note)</a></li>
<li><a href="#diy-equality">DIY equality</a></li>
<li><a href="#subtyping">Subtyping</a></li>
<li><a href="#comparative-complexity-rant">Comparative complexity rant</a></li>
<li><a href="#variance-problems">Variance problems</a></li>
<li><a href="#summary">Summary</a></li>
</ul></li>
<li><a href="#next-chapter">Next Chapter</a></li>
<li><a href="#summary-of-final-edits">Summary of final edits</a></li>
</ul>
</div>
<p><em>Please Leave Feedback in: <a href="https://github.com/rpeszek/rpeszek.github.io/discussions/1" target="_blank">git discussions</a></em></p>
<p>Previous post: <a href="2021-12-24-ts-types-part2.html" target="_blank">Part 2. Typing Honestly</a>.</p>
<p><strong>DRAFT version</strong> <em>(I am sorry about any misprints. It seems I have goblins in my laptop that toy with me, remove or change words. When this note disappears, you will know that I gave up.)</em></p>
<p><strong>Disclaimers:</strong> (imagine this is a very small font, read it very fast in a half whisper)<br />
<em>I assume strict compiler flags are on, something you get by default with scaffolding, e.g. using <code>create-react-app my-project --template typescript</code> is close enough.<br />
The code examples have been tested with TypeScript v4.5.2.<br />
This post is a pandoc output of a markdown document and code examples are not interactive.<br />
Most of the code examples are published in <a href="https://github.com/rpeszek/ts-experiments/tree/master/ts-notes" target="_blank">ts-notes</a> folder in this github repo: <a href="https://github.com/rpeszek/ts-experiments" target="_blank">ts-experiments</a>.</em></p>
<p><strong>Motivating Quote for the series:</strong></p>
<blockquote>
<p>“TypeScript began its life as an attempt to bring traditional object-oriented types to JavaScript so that the programmers at Microsoft could bring traditional object-oriented programs to the web. As it has developed, TypeScript’s type system has evolved to model code written by native JavaScripters. The resulting system is <em>powerful, interesting and messy.</em>”</p>
</blockquote>
<p><em>From typescriptlang <a href="https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html" target="_blank">TypeScript for Functional Programmers</a></em></p>
<h2 id="nutshell">Nutshell</h2>
<p>Happy New Year! Let’s hope 2022 it will be way better than 2021. It has to be.</p>
<p>This is the third post in the series devoted to types in TypeScript. In this series, I explore type-centric approaches to writing code and push TS to its limits in doing so. I am writing these posts for like minded developers who are interested in types and either use or consider using TypeScript.</p>
<p>In this post we will see TS struggle. We will see compilation inconsistencies and surprising type checker behavior.<br />
My main goal is to point out the complexity of what TS is trying to accomplish and share my understanding of it.<br />
On a positive note, I will introduce additional tools for asking TS type questions.<br />
Also, I promise, the next installment will be about good things in TS. It will be about programming with type variables.</p>
<p>Before we discuss the messy bits, let’s briefly talk about some cool type safety features.</p>
<h2 id="interesting-safety">Interesting safety</h2>
<p>TypeScript implements special <a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html" target="_blank">narrowing</a> semantics when processing parts of JS code. These semantic rules provide very surprising and useful type safety features. TS can effectively narrow types used in a number of JS operators such as <code>typeof</code>, <code>===</code>, <code>==</code> and apply this information to <code>if-else</code>, <code>switch</code> statements. This post has already shown a few examples where this, almost magically, prevents placing code in a wrong branch of conditional if-else blocks.</p>
<p>Here are some of my favorites with IMO on their use.</p>
<h3 id="apple-orange-type-safety"><code>apple !== orange</code> type safety</h3>
<p>This JavaScript code (I keep reusing <code>type Person = {firstNm: string, lastNm: string}</code> from the first post):</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="co">//Bad code</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="kw">function</span> <span class="fu">blah</span>(lhs<span class="op">:</span> string<span class="op">,</span> rhs<span class="op">:</span> Person) {</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>  <span class="cf">if</span> (lhs <span class="op">===</span> rhs) {</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>    <span class="co">//Do something</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>  } <span class="cf">else</span> {</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>    <span class="co">//Do something else</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>  }</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>}</span></code></pre></div>
<p>is a programming bug and will not type-check in TypeScript. You can just replace it with:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="co">//Actual equivalent</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="kw">function</span> <span class="fu">blah</span>(lhs<span class="op">:</span> string<span class="op">,</span> rhs<span class="op">:</span> Person) {</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>  <span class="co">//Do something else</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>}</span></code></pre></div>
<p>TypeScript prevents from using <code>===</code> if it can guess<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>, by looking at the types, that <code>===</code> will always be <code>false</code>. This is true in general, not just inside <code>if-else</code>, but the <code>if-else</code> use is the killer app IMO.<br />
One cool example of <code>===</code> type safety combines type narrowing with literal types: <code>1 === 2</code> will not compile!</p>
<p>This is a big deal. <code>===</code> is often used to compare things like <code>string</code> or <code>number</code> <em>id</em>-s or <em>hashes</em> and it is not that uncommon to accidentally try to compare something like an <em>id</em> with something completely different.<br />
I have seen analogous issues in many programming languages including even <em>Scala</em>.</p>
<h3 id="switch-exhaustive-check"><code>switch</code> exhaustive check</h3>
<p><code>if-else</code> does not provide any mechanism for the type checker to verify that the program checked all possible conditions.<br />
Interestingly, we can use the <code>switch</code> statement in TS to solve this problem:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="co">//This compiles!</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a><span class="kw">const</span> contrived_better <span class="op">=</span> (n<span class="op">:</span> <span class="dv">1</span> <span class="op">|</span> <span class="dv">2</span>)<span class="op">:</span> number <span class="kw">=&gt;</span> {</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>    <span class="cf">switch</span>(n) {</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>       <span class="cf">case</span> <span class="dv">1</span><span class="op">:</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>       <span class="cf">case</span> <span class="dv">2</span><span class="op">:</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>        <span class="cf">return</span> <span class="dv">2</span> </span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>    } </span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="co">//Compilation error</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="co">//Function lacks ending return statement and return type does not include 'undefined'.ts(</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>export <span class="dt">const</span> contrived_better_ = (n: <span class="dv">1</span> | <span class="dv">2</span> | <span class="dv">3</span>): number =&gt; {</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>    <span class="kw">switch</span>(n) {</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>       <span class="kw">case</span> <span class="dv">1</span>:</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>        <span class="kw">return</span> n</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>       <span class="kw">case</span> <span class="dv">2</span>:</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>        <span class="kw">return</span> n </span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>    } </span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>}</span></code></pre></div>
<p>That is another nice example of TS enhancing JS with a nice type safety feature.</p>
<p>IMO an even better solution is provided by the <em>ts-pattern</em> library. See this blog post: <a href="https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k" target="_blank">Introducing ts-pattern v3.0</a></p>
<h3 id="null-undefined-safety"><code>null</code> / <code>undefined</code> safety</h3>
<p>We have seen <code>null</code> safety already. There is a semantic difference between <code>null</code> and <code>undefined</code> but most code does not care. My personal preference is to unify these two.</p>
<p>In my very first example in the series, <a href="2021-12-12-ts-types-part1.html#typescript-is-great" target="_blank"><code>getName(p: NullablePerson)</code></a>, was not <code>undefined</code> safe, only <code>null</code> safe. Using it with <code>undefined</code> (e.g. on expressions typed as <code>any</code>) will cause an error.</p>
<p>My coding preference would be to rewrite my first example like this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="co">//Reusable utility type</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="im">export</span> type Undefined <span class="op">=</span> <span class="kw">null</span> <span class="op">|</span> <span class="kw">undefined</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a><span class="im">export</span> <span class="kw">const</span> isUndefined <span class="op">=</span> (d<span class="op">:</span> unknown)<span class="op">:</span> d is Undefined <span class="kw">=&gt;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>   (d <span class="op">===</span> <span class="kw">null</span>) <span class="op">||</span> (d <span class="op">===</span> <span class="kw">undefined</span>) <span class="co">//I prefer not to use '=='</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a><span class="kw">const</span> getName2 <span class="op">=</span> (p<span class="op">:</span>Person <span class="op">|</span> Undefined)<span class="op">:</span> string <span class="kw">=&gt;</span> {</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>    <span class="co">//const tst1 = p.firstNm //will not compile</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>    <span class="cf">if</span>(<span class="fu">isUndefined</span>(p)){</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a>        <span class="co">//const tst2 = p.firstNm //will not compile</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a>        <span class="cf">return</span> <span class="st">&quot;John Smith&quot;</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a>    } <span class="cf">else</span> {</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true"></a>        <span class="cf">return</span> p<span class="op">.</span><span class="at">firstNm</span> <span class="op">+</span> <span class="st">&quot; &quot;</span> <span class="op">+</span> p<span class="op">.</span><span class="at">lastNm</span> <span class="co">//compiles</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true"></a>    }</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true"></a>}</span></code></pre></div>
<p>This is just my personal preference, I also use this approach when typing optional <code>?</code> object properties. E.g.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>type Person2 <span class="op">=</span> {<span class="dt">firstNm</span><span class="op">:</span> string<span class="op">;</span> middleNm<span class="op">?:</span> string <span class="op">|</span> Undefined<span class="op">;</span> <span class="dt">lastNm</span><span class="op">:</span> string}</span></code></pre></div>
<p>The extra safety features are what surprised and excited me about TS. They reminded me of a functional programming language.</p>
<h2 id="complexity-of-ts-types">Complexity of TS types</h2>
<p>Throughout the series, we encountered a few examples where the TS type checker did not work as expected, we will encounter more of TS quirkiness in this section. This note suggests a reason for this: type complexity.</p>
<p>My original plan was to write about TS needing to implement a separate ad-hoc semantics for various JS operators. I was not able to present anything very insightful and I have abandoned that idea, e.g. these <a href="2021-12-12-ts-types-part1.html#type-holes" target="_blank">type hole</a> expressions do not even compile:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="co">//Compiliation errors: Object is of type 'unknown'</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="fu">_</span>() + <span class="fu">_</span>()</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a><span class="fu">_</span>() * <span class="fu">_</span>()</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a><span class="fu">_</span>() / <span class="fu">_</span>()</span></code></pre></div>
<p>Taking the quote from the top of this post to heart, I concluded that TS is about providing support for OO and other idiomatic uses of JS. I decided to narrow the focus of this note to subtyping and the <code>===</code> operator semantics.</p>
<h3 id="semantics-rejected-overlap"><code>===</code> semantics, rejected overlap</h3>
<p>I have picked <code>===</code> because we discussed it already in my previous note about the <a href="2021-12-24-ts-types-part2.html#note-about-the-unknown-type" target="_blank"><code>unknown</code> type</a>. Selecting <code>==</code> would produce a very similar presentation.</p>
<p>Here is an example of safety around the <code>===</code> operator:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="co">//This condition will always return 'false' since the types '&quot;world!&quot;' and '&quot;Dolly!&quot;' have no overlap.ts(2367)</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="st">&quot;world!&quot;</span> === <span class="st">&quot;Dolly!&quot;</span> <span class="co">//does not compile</span></span></code></pre></div>
<p>Let’s try to figure out the semantic rules around <code>===</code>. What does “not having an overlap” mean?<br />
I have not seen a formal (or even a somewhat precise) definition of the semantic rules for the <code>===</code>.<br />
(Please comment in git discussions if you know about any place that defines these.)<br />
The informal definition (from typescriptlang documentation) points to a “common type that both <code>x</code> and <code>y</code> could take on” but this statement clearly has some loose ends.</p>
<p>The first part of the error message “This condition will always return ‘false’” suggests a way to start:</p>
<p><strong>(EQ-SAFETY attempt 1):</strong> <em>TypeScript prevents using <code>===</code> if it can prove, by looking at the types, that the result of <code>===</code> would always be <code>false</code>.</em></p>
<p>This is a very high level and does not explain how TS does it. But is this even true?</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>function <span class="fu">testEqSemantics</span>(a: {bye: string}, b: {hello: string): <span class="dt">boolean</span> {</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>   <span class="co">//This condition will always return 'false' since the types '{ bye: string; }' and '{ hello: string; }' have no overlap.</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>   <span class="kw">return</span> a === b <span class="co">//does not compile</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>}</span></code></pre></div>
<p>Let me temporarily comment the not compiling code:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="kw">function</span> <span class="fu">testEqSemantics</span>(a<span class="op">:</span> {<span class="dt">bye</span><span class="op">:</span> string}<span class="op">,</span> b<span class="op">:</span> {<span class="dt">hello</span><span class="op">:</span> string})<span class="op">:</span> boolean {</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>   <span class="co">//This condition will always return 'false' since the types '{ bye: string; }' and '{ hello: string; }' have no overlap.</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>   <span class="co">//return a === b</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>   <span class="cf">return</span> <span class="kw">true</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>}</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a><span class="kw">const</span> helloBye <span class="op">=</span> {<span class="dt">bye</span><span class="op">:</span><span class="st">&quot;world!&quot;</span><span class="op">,</span> <span class="dt">hello</span><span class="op">:</span><span class="st">&quot;world!&quot;</span>}</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a><span class="fu">testEqSemantics</span>(helloBye<span class="op">,</span> helloBye)  <span class="co">//compiles, here is the overlap!</span></span></code></pre></div>
<p>TS has effectively prevented me from using <code>===</code> even though there are legitimate cases where the <code>===</code> would have returned <code>true</code>! This seems like a major blooper.</p>
<p><strong><em>We have falsified the error message from TS.</em></strong></p>
<p>OO is complex and type design issues are not uncommon among OO languages, this could be one of them.<br />
On the other hand, preventing <code>{bye: "world!"} === {hello: "world!"}</code> from compiling seems useful from a pragmatic point of view. It is possible that this behavior is intentional.</p>
<p>I see 2 possible conclusions</p>
<ol type="1">
<li>This is a bug caused by a complexity of TS’s semantic rules</li>
<li>This is a feature indicating that the rules are indeed complex</li>
</ol>
<p>This appears to be one of the “Working as Intended” or at least known issues (see <a href="#fn4">footnote 4</a>).</p>
<h3 id="semantics-whats-an-overlap"><code>===</code> semantics, what’s an overlap?</h3>
<p>Let’s focus on this part of the error message: “types … and … have no overlap”.</p>
<p><strong>(EQ-SAFETY attempt 2):</strong> <em><code>x === y</code> compiles if <code>x: X</code> and <code>y: Y</code> and the compiler successfully computes some special non-<code>never</code> <code>Overlap</code> type that widens to both <code>X</code> and <code>Y</code></em></p>
<p><code>X</code> is the computed type for <code>x</code>, <code>Y</code> is the computed type for <code>y</code>, how do we compute <code>Overlap</code> type for both? I think we can assume that <em>widens</em> simply means <code>extends</code>.<br />
The 64K dollar question is how is the <code>Overlap</code> computed? It is clearly not the same as intersection (the type operator <code>&amp;</code>), we have falsified that hypothesis in the previous section. Let’s try to look at some patterns:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="kw">const</span> helloDolly<span class="op">:</span> {<span class="dt">hello</span><span class="op">:</span> string} <span class="op">=</span> {<span class="dt">hello</span><span class="op">:</span> <span class="st">&quot;Dolly!&quot;</span>}</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a><span class="kw">const</span> datedHello<span class="op">:</span> {<span class="dt">hello</span><span class="op">:</span> string<span class="op">,</span> <span class="dt">since</span><span class="op">:</span> number} <span class="op">=</span> {<span class="dt">hello</span><span class="op">:</span> <span class="st">&quot;world!&quot;</span><span class="op">,</span> <span class="dt">since</span><span class="op">:</span><span class="dv">2022</span>}</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a><span class="kw">const</span> one <span class="op">=</span> <span class="dv">1</span> <span class="co">//const one: 1</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a><span class="kw">const</span> two <span class="op">=</span> <span class="dv">2</span> <span class="co">//const two: 2</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a><span class="kw">const</span> onenum<span class="op">:</span> number  <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a><span class="kw">const</span> twonum<span class="op">:</span> number  <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a><span class="kw">const</span> world<span class="op">:</span> string <span class="op">=</span> <span class="st">&quot;world&quot;</span></span></code></pre></div>
<div class="sourceCode" id="cb12"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="co">//fails, different literal types do not overlap</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a><span class="st">&quot;Dolly!&quot;</span> ===  <span class="st">&quot;world!&quot;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a><span class="co">//fails, different literal types do not overlap</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>one === two</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a><span class="co">//fails, string and number do not overlap</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a>one === world</span></code></pre></div>
<div class="sourceCode" id="cb13"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="co">//compilies, note both have the same type</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>onenum <span class="op">===</span> twonum</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a><span class="co">//compiles, note 'typeof datedHello' extends 'typeof helloDolly' </span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>helloDolly <span class="op">===</span> datedHello</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a><span class="co">//compiles, the overlap seems to be the 'Person' type</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a><span class="kw">function</span> <span class="fu">tst</span> (x<span class="op">:</span> number <span class="op">|</span> Person<span class="op">,</span> y<span class="op">:</span> string <span class="op">|</span> Person) {</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a>    <span class="cf">return</span> x <span class="op">===</span> y</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a>}</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true"></a><span class="co">//compiles, the overlap seems to be `{hello: string, since: number}` </span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true"></a><span class="kw">function</span> <span class="fu">testEqSemantics2</span>(a<span class="op">:</span> {<span class="dt">hello</span><span class="op">:</span> string} <span class="op">|</span> <span class="dv">1</span><span class="op">,</span> b<span class="op">:</span> <span class="st">&quot;boo&quot;</span> <span class="op">|</span> {<span class="dt">hello</span><span class="op">:</span> string<span class="op">,</span> <span class="dt">since</span><span class="op">:</span> number})<span class="op">:</span> boolean {</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true"></a>    <span class="cf">return</span> a <span class="op">===</span> b</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true"></a>}</span></code></pre></div>
<p>A possible rule for calculating <code>Overlap</code> could be (this is just a rough, high level heuristics, <em>please comment if you know a better definition</em>):</p>
<ul>
<li>for intersection types <code>X</code> and <code>Y</code>, if <code>X extends Y</code> take <code>X</code> else if <code>Y extends X</code> take <code>Y</code> otherwise reject</li>
<li>for union types <code>X = X1 | X2 | ...</code> and <code>Y = Y1 | Y2 | ...</code> recursively check if any <code>Xi</code> and <code>Yj</code> overlaps (this heuristics ignores performance cost)</li>
<li>for complex combinations of union and intersection types? I DUNNO, I have not tested it enough.</li>
</ul>
<p>I have not played with this assumption for a very long time, but so far these rules seem to hold with these exceptions:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="co">//All compile</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a><span class="dv">1</span> <span class="op">===</span> <span class="kw">null</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a><span class="dv">1</span> <span class="op">===</span> <span class="kw">undefined</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a><span class="kw">function</span> <span class="fu">tst2</span> (x<span class="op">:</span> <span class="dv">1</span><span class="op">,</span> y<span class="op">:</span> <span class="kw">null</span>) {</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a>    <span class="cf">return</span> x <span class="op">===</span> y</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true"></a>}</span></code></pre></div>
<p>Does <code>1</code> have an overlap with <code>null</code> and <code>undefined</code>? What does that even mean? With the <em>strictNullChecks</em> compiler flag, <code>null</code> should be well separated from other types.<br />
This particular quirkiness is actually useful, it allows for a program to do conservative null checks even if the type indicates that it is not needed.</p>
<p>I hope you agree. This is complicated.<br />
I will hopefully bring this point even closer to home by the end of this post.</p>
<h3 id="hidden-blooper-side-note">Hidden blooper (side note)</h3>
<p>If you remove type annotations from the above definitions, the <code>helloDolly === datedHello</code> still compiles:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="kw">const</span> helloDolly <span class="op">=</span> {<span class="dt">hello</span><span class="op">:</span> <span class="st">&quot;Dolly!&quot;</span>}</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a><span class="kw">const</span> datedHello <span class="op">=</span> {<span class="dt">hello</span><span class="op">:</span> <span class="st">&quot;world!&quot;</span><span class="op">,</span> <span class="dt">since</span><span class="op">:</span><span class="dv">2022</span>}</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a>helloDolly <span class="op">===</span> datedHello <span class="co">//still compiles</span></span></code></pre></div>
<p>From a pragmatic standpoint this is very strange. <code>"Dolly!" ===  "world!"</code> is statically rejected, but <code>{hello: "Dolly!"} === {hello: "world!", since:"2022"}</code> is not.</p>
<p>This surprising situation is caused by the type inference widening the types. The types inferred in the expression <code>"world!" === "Dolly!"</code> are the literal types <code>"world!": "world!"</code> and <code>"Dolly!": "Dolly!"</code>, while the <code>helloDolly</code> and <code>datedHello</code> infer a <code>string</code> and <code>number</code> for their properties:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="co">//IntelliSense view of helloDolly</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a><span class="kw">const</span> helloDolly<span class="op">:</span> {</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>    <span class="dt">hello</span><span class="op">:</span> string<span class="op">;</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>}</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a><span class="co">//IntelliSense view of datedHello</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a><span class="kw">const</span> datedHello<span class="op">:</span> {</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true"></a>    <span class="dt">hello</span><span class="op">:</span> string<span class="op">;</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true"></a>    <span class="dt">since</span><span class="op">:</span> number<span class="op">;</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true"></a>}</span></code></pre></div>
<p>TS allows to define the above object types using <code>as const</code>, e.g. <code>const helloDolly = {hello: "Dolly!"} as const</code> and <code>const datedHello = {hello: "world!", since:2022} as const</code>. It this is done <code>helloDolly === datedHello</code> will no longer compile but IMO, widening object property types is an arbitrary complexity.</p>
<h3 id="diy-equality">DIY equality</h3>
<p>The question is how far can I get by trying to reproduce safety around the <code>===</code> on my own.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>declare <span class="kw">function</span> eq<span class="op">&lt;</span>T<span class="op">&gt;</span>(t1<span class="op">:</span> T<span class="op">,</span> t2<span class="op">:</span> T)<span class="op">:</span> boolean</span></code></pre></div>
<p>This generic function (it could be implemented by simply using <code>===</code>) forces both arguments to have the same type. That should give me at least some level of extra safety and prevent from comparing apples and oranges.<br />
Let’s see, starting with these type holes:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="co">//type holes shows a string, not bad, I would prefer the literal &quot;foo&quot;.</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a><span class="fu">eq</span>(<span class="st">&quot;foo&quot;</span><span class="op">,</span> <span class="fu">_</span>())</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a><span class="co">//type holes shows unknown, Another unexpected 'uknown' widening issue? </span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a><span class="fu">eq</span>(<span class="fu">_</span>()<span class="op">,</span> <span class="st">&quot;foo&quot;</span>)</span></code></pre></div>
<p>Let’s ignore the second type hole disappointing quirkiness and move on.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="co">//These all compile</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a><span class="fu">eq</span>(<span class="dv">1</span> <span class="im">as</span> <span class="dv">1</span><span class="op">,</span> <span class="kw">null</span>)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a><span class="fu">eq</span>(<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span>)              <span class="co">//</span><span class="al">NOTE</span><span class="co"> we lost the type safety of ===</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a><span class="fu">eq</span>(<span class="dv">1</span> <span class="im">as</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span> <span class="im">as</span> <span class="dv">2</span>)    <span class="co">//</span><span class="al">NOTE</span><span class="co"> we lost the type safety of ===</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a><span class="fu">eq</span>({<span class="dt">bye</span><span class="op">:</span> <span class="st">&quot;world&quot;</span>}<span class="op">,</span> {<span class="dt">hello</span><span class="op">:</span> <span class="st">&quot;world&quot;</span>})  <span class="co">//</span><span class="al">NOTE</span><span class="co"> we lost the (possibly erroneous) type safety preventing {bye: &quot;world&quot;} === {hello: &quot;world&quot;}</span></span></code></pre></div>
<p>How come these compile? These are all different types but TS can unify them into a supertype (next section will discuss it). These are all legitimate statements. Unfortunately, the type safety has been lost. This explains why the semantic narrowing around the <code>===</code> operator is needed. It is needed because structural subtyping can unify types even if types are very different.</p>
<p>However, quirkiness alert, these do not compile:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="co">//Argument of type '&quot;boo&quot;' is not assignable to parameter of type '1'.ts(2345)</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a><span class="fu">eq</span>(<span class="dv">1</span>, <span class="st">&quot;boo&quot;</span>)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a><span class="co">//Argument of type '1' is not assignable to parameter of type '&quot;boo&quot;'.ts(2345)</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a><span class="fu">eq</span>(<span class="st">&quot;boo&quot;</span>, <span class="dv">1</span>)</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a><span class="co">//Argument of type '{ hello: string; }' is not assignable to parameter of type '1'.ts(2345)</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true"></a><span class="fu">eq</span>(<span class="dv">1</span>, {hello: <span class="st">&quot;world&quot;</span>})</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true"></a><span class="co">//Argument of type '{ hello: string; }' is not assignable to parameter of type '&quot;boo&quot;'.ts(2345)</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true"></a><span class="fu">eq</span>(<span class="st">&quot;boo&quot;</span>, {hello: <span class="st">&quot;world&quot;</span>})</span></code></pre></div>
<p><em>This is very unfortunate</em>, you want generic functions to work <em>consistently</em> across types. IMO this is a bug or an arbitrary complexity.<br />
The quirkiness seems to be related to the type inference working inconsistently and failing to widen the types if a string literal type is involved (next section will discussed it).</p>
<p>The narrative has run away from me, but the point should be somewhat clear: Generics provide only limited type safety in TS.<br />
E.g. enhanced safety semantics around <code>===</code> does not transfer to a DIY safety that a library solution could expose.</p>
<h3 id="subtyping">Subtyping</h3>
<p>How come this compiles?</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="fu">eq</span>(<span class="dv">1</span> <span class="im">as</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span> <span class="im">as</span> <span class="dv">2</span>) </span></code></pre></div>
<p>The type checker widens the types of both arguments to <code>1 | 2</code>. This is because of a subtyping rule that says that <code>1 extends (1 | 2)</code> and <code>2 extends (1 | 2)</code>.<br />
Here is a somewhat clever trick to see that:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="im">export</span> declare <span class="kw">function</span> unify<span class="op">&lt;</span>T<span class="op">&gt;</span>(t1<span class="op">:</span> T<span class="op">,</span> t2<span class="op">:</span> T) <span class="op">:</span> T</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a><span class="co">//hovering over unify shows me:</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a><span class="co">//(alias) unify&lt;1 | 2&gt;(t1: 1 | 2, t2: 1 | 2): 1 | 2</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a><span class="fu">unify</span>(<span class="dv">1</span> <span class="im">as</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span> <span class="im">as</span> <span class="dv">2</span>)</span></code></pre></div>
<p>if you do not believe me that <code>1 extends (1 | 2)</code> you can check it for yourself with another trick:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="im">export</span> <span class="kw">function</span> verifyExtends<span class="op">&lt;</span>T2 <span class="kw">extends</span> T1<span class="op">,</span> T1<span class="op">&gt;</span>() {}</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a>verifyExtends<span class="op">&lt;</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span> <span class="op">|</span> <span class="dv">2</span><span class="op">&gt;</span>()</span></code></pre></div>
<p>However, TS appears to be not consistently good about inferring these subtyping rules. TS apparently did not notice that <code>1 extends (1 | "boo")</code> and <code>"boo" extends (1 | "boo")</code>. Hence the blooper</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a>verifyExtends<span class="op">&lt;</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span> <span class="op">|</span> <span class="st">&quot;boo&quot;</span><span class="op">&gt;</span>()</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a>verifyExtends<span class="op">&lt;</span><span class="st">&quot;boo&quot;</span><span class="op">,</span> <span class="dv">1</span> <span class="op">|</span> <span class="st">&quot;boo&quot;</span><span class="op">&gt;</span>()</span></code></pre></div>
<div class="sourceCode" id="cb25"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a><span class="co">//Argument of type '&quot;boo&quot;' is not assignable to parameter of type '1'.ts(2345)</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a><span class="fu">eq</span>(<span class="dv">1</span>, <span class="st">&quot;boo&quot;</span>)</span></code></pre></div>
<p>Let’s try to force TS into compliance by type annotating everything:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a><span class="kw">const</span> booone <span class="op">:</span> <span class="dv">1</span> <span class="op">|</span> <span class="st">&quot;boo&quot;</span> <span class="op">=</span> <span class="st">&quot;boo&quot;</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a><span class="kw">const</span> oneboo <span class="op">:</span> <span class="dv">1</span> <span class="op">|</span> <span class="st">&quot;boo&quot;</span> <span class="op">=</span> <span class="dv">1</span></span></code></pre></div>
<div class="sourceCode" id="cb27"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a><span class="co">//Argument of type '1' is not assignable to parameter of type '&quot;boo&quot;'.ts(2345)</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true"></a><span class="fu">eq</span>(booone, oneboo) </span></code></pre></div>
<div class="sourceCode" id="cb28"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a><span class="co">//finally compiles with type application on 'eq'</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true"></a>eq<span class="op">&lt;</span>(<span class="dv">1</span> <span class="op">|</span> <span class="st">&quot;boo&quot;</span>)<span class="op">&gt;</span>(booone<span class="op">,</span> oneboo)</span></code></pre></div>
<p>We have seen that <code>===</code> narrowing is partially consistent with the intersection (<code>&amp;</code> operator).<br />
Let’s look at <code>&amp;</code> semantics a little closer.</p>
<p>We can try to double check how the <code>&amp;</code> intersection works by doing this:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a><span class="co">//both compile suggesting that Person is equivalent to the intersection  (number | Person) &amp; (string | Person)</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true"></a>verifyExtends<span class="op">&lt;</span>Person<span class="op">,</span> (number <span class="op">|</span> Person) <span class="op">&amp;</span> (string <span class="op">|</span> Person)<span class="op">&gt;</span>()</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true"></a>verifyExtends<span class="op">&lt;</span>(number <span class="op">|</span> Person) <span class="op">&amp;</span> (string <span class="op">|</span> Person)<span class="op">,</span> Person<span class="op">&gt;</span>()</span></code></pre></div>
<p>However this does not compile, and it does look like a bug (see second line of the error message):</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a><span class="co">//Type '(1 | &quot;boo&quot;) &amp; (&quot;boo&quot; | Person)' does not satisfy the constraint '&quot;boo&quot;'.</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true"></a><span class="co">//  Type '1 &amp; Person' is not assignable to type '&quot;boo&quot;'.ts(2344)</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true"></a>verifyExtends&lt;(<span class="dv">1</span> | <span class="st">&quot;boo&quot;</span>) &amp; (<span class="st">&quot;boo&quot;</span> | Person), <span class="st">&quot;boo&quot;</span>&gt;()</span></code></pre></div>
<p><em>Complexity is a super food for bugs.</em></p>
<p>Here is my quick summary: subtyping is complex and it weakens type safety. TS tries to recover the safety by building complex narrowing semantics around a selected set of JS operators. There are many inconsistencies in both the implementation of subtyping and the implementation of narrowing semantics.</p>
<p> <div class="side-note"><strong>Side Note about Arity</strong>: In TypeScript, functions are also subject to subtyping rules.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true"></a>verifyExtends<span class="op">&lt;</span>() <span class="kw">=&gt;</span> number<span class="op">,</span> (_<span class="op">:</span>string) <span class="kw">=&gt;</span> number<span class="op">&gt;</span>()</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true"></a>verifyExtends<span class="op">&lt;</span>(_<span class="op">:</span>string) <span class="kw">=&gt;</span> number<span class="op">,</span> (_1<span class="op">:</span>string<span class="op">,</span>_2<span class="op">:</span>boolean) <span class="kw">=&gt;</span> number<span class="op">&gt;</span>()<span class="op">&gt;</span></span></code></pre></div>
<p>see also <a href="https://github.com/Microsoft/TypeScript/wiki/FAQ#why-are-functions-with-fewer-parameters-assignable-to-functions-that-take-more-parameters" target="_blank">functions with fewer parameters are assignable to functions that take more parameters</a>. We have seen this leading to surprising behavior in <a href="2021-12-12-ts-types-part1.html#compilation-bloopers" target="_blank">Part 1, Compilation bloopers</a> section.  </div></p>
<h3 id="comparative-complexity-rant">Comparative complexity rant</h3>
<p>A “type enthusiast” will associate types with correctness, even formal verification. To me, the words “messy” and “type” are self contradictory. TS “types” support some interesting features but are a mess.</p>
<p>I want to contrast the above <code>===</code> and <code>eq</code> examples against a programming language that has been designed around types from the beginning. An example could be an FP language like Elm, PureScript, or Haskell (I am not that familiar with ReasonML or OCaml)<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.<br />
These languages have much simpler types. The safety around equality does not require any special narrowing semantics. You get it for free in any DIY function that has 2 arguments sharing the same generic type (only they call it polymorphic not generic).</p>
<p>One underlying reason for this is the lack of complex subtyping and OO features. <code>eq(x,y)</code> will not compile if <code>x</code> and <code>y</code> have different types. There is no way to unify <code>x</code> and <code>y</code> to some supertype because there are no subtypes or supertypes.<br />
But, you may say, JS object polymorphism is very useful. All the 3 languages listed above provide support for polymorphic record types<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>, only they use much simpler techniques than subtyping to achieve it.<br />
These languages also come with well thought out semantic rules that are often formalized and come with soundness proofs.<br />
The types in these languages are much simpler (not necessarily easier but simpler).</p>
<p>Type complexity translates to a confused type checker and to a confused developer.<br />
<em>Programming in a language in which I do not fully understand the types equates to me writing programs I do not fully understand.</em></p>
<p>I expect that to become a seasoned TS developer, one needs to remember a big dictionary of idiosyncratic compiler behaviors. <a href="https://github.com/Microsoft/TypeScript/wiki/FAQ#common-bugs-that-arent-bugs" target="_blank">Common Bugs that aren’t bugs</a> is, I think, just a warm up reading to achieve such mastery.<br />
Were you surprised about the gotchas we have uncovered in <a href="2021-12-12-ts-types-part1.html" target="_blank">Part 1</a>? Is the above <a href="#semantics-rejected-overlap">overlap issue</a> a well known problem<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>? Call me weird, but I would rather be learning PLT or Type Theory than these gotchas.</p>
<p>It is worth noting that TypeScript has over a million users. FP languages have tens of thousands of users (if combined). TypeScript has more resources to improve. What makes for fewer bugs, lots of dollars or clean types?<br />
I do not think there is a clear answer to this question. However, resources can’t solve all the problems. Programming languages are almost paranoid about backward compatibility and backward compatibility does not like changing things, even if the change is fixing bugs.<br />
So I am afraid, a simple language like Elm will always be cleaner and more robust.</p>
<p>Forgetting about the popularity context, I view it as a trade-off: suffer because of the type complexity and reduced type safety but see a readable JavaScript and trivially integrate with the rest of JS ecosystem <em>vs</em> introduce a language that has nicer types, greater type safety, predictable compiler, but lose generated JS code clarity and suffer when integrating JS libraries.<br />
This trade-off is IMO not trivial and very project dependent. Clean types vs clean JS, I typically select the clean types. The ecosystem compatibility issue is a little harder to ignore and the main reason I am writing code in TS. Projects with a high correctness requirement, IMO, should select an FP language, the optimal choice for other projects is less clear.</p>
<h3 id="variance-problems">Variance problems</h3>
<p>I will finish with some examples that may feel even more surprising.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true"></a><span class="kw">const</span> bye <span class="op">=</span> {<span class="dt">bye</span><span class="op">:</span> <span class="st">&quot;world&quot;</span>}</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true"></a><span class="kw">const</span> hello <span class="op">=</span> {<span class="dt">hello</span><span class="op">:</span> <span class="st">&quot;world&quot;</span>}</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true"></a></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true"></a>declare <span class="kw">function</span> eqArrays<span class="op">&lt;</span>T<span class="op">&gt;</span>(t1<span class="op">:</span> T[]<span class="op">,</span> t2<span class="op">:</span> T[])<span class="op">:</span> boolean</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true"></a></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true"></a><span class="fu">eqArrays</span>([{<span class="dt">bye</span><span class="op">:</span> <span class="st">&quot;world&quot;</span>}]<span class="op">,</span> [{<span class="dt">hello</span><span class="op">:</span> <span class="st">&quot;world&quot;</span>}]) <span class="co">//compiles</span></span></code></pre></div>
<div class="sourceCode" id="cb33"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true"></a><span class="co">//Compilation error</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true"></a><span class="co">//Property 'bye' is missing in type '{ hello: string; }' but required in type '{ bye: string; }'.ts(2741)</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true"></a><span class="fu">eqArrays</span>([bye], [hello])</span></code></pre></div>
<p>Here is another example:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a><span class="kw">interface</span> Payload<span class="op">&lt;</span>T<span class="op">&gt;</span> {<span class="dt">payload</span><span class="op">:</span> T}</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true"></a></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true"></a><span class="co">// ... we would see the same behavior for:</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true"></a><span class="co">//type Payload1&lt;T&gt; = {payload: T} </span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true"></a></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true"></a>declare <span class="kw">function</span> eqPayloads<span class="op">&lt;</span>T<span class="op">&gt;</span>(t1<span class="op">:</span> Payload<span class="op">&lt;</span>T<span class="op">&gt;,</span> t2<span class="op">:</span> Payload<span class="op">&lt;</span>T<span class="op">&gt;</span>)<span class="op">:</span> boolean</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true"></a></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true"></a><span class="fu">eqPayloads</span>({<span class="dt">payload</span><span class="op">:</span> {<span class="dt">bye</span><span class="op">:</span> <span class="st">&quot;world&quot;</span>}}<span class="op">,</span> {<span class="dt">payload</span><span class="op">:</span> {<span class="dt">hello</span><span class="op">:</span> <span class="st">&quot;world&quot;</span>}})  <span class="co">//compilies</span></span></code></pre></div>
<div class="sourceCode" id="cb35"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true"></a><span class="co">// Compilation error:</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true"></a><span class="co">// Property 'bye' is missing in type '{ hello: string; }' but required in type '{ bye: string; }'.ts(2741)</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true"></a><span class="fu">eqPayloads</span>({payload: bye}, {payload: hello})</span></code></pre></div>
<p>My first instinct was to assume that this weird behavior is caused by TS treating <code>T[]</code> and <code>Payload&lt;T&gt;</code> conservatively as invariant. Unfortunately, this is not the case. The above quirkiness looks to be just another type inference issue and there is a deeper safety problem.</p>
<p>TS implements variance incorrectly and makes both <code>T[]</code> and <code>Payload&lt;T&gt;</code> covariant (e.g. TS assumes that <code>P extends T</code> implies <code>Payload&lt;P&gt; extends Payload&lt;T&gt;</code>). Here is a well known Java language bug reimplemented in TS:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true"></a><span class="co">//how to put a string into a list of numbers</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true"></a><span class="kw">const</span> intlist<span class="op">:</span> number[] <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>]</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true"></a><span class="kw">const</span> list<span class="op">:</span> unknown[] <span class="op">=</span> intlist</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true"></a>list<span class="op">.</span><span class="fu">push</span>(<span class="st">&quot;not a number&quot;</span>) <span class="co">//compiles</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true"></a></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true"></a><span class="co">//array is incorrectly covariant</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true"></a>verifyExtends<span class="op">&lt;</span><span class="kw">typeof</span> datedHello[]<span class="op">,</span> <span class="kw">typeof</span> helloDolly[]<span class="op">&gt;</span>() <span class="co">//datedHello extends helloDolly type</span></span></code></pre></div>
<p>I see the same incorrect subtyping on the <code>Payload</code> interface:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true"></a><span class="co">//interface Payload is incorrectly covariant</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true"></a>verifyExtends<span class="op">&lt;</span>Payload<span class="op">&lt;</span><span class="kw">typeof</span> datedHello<span class="op">&gt;,</span> Payload<span class="op">&lt;</span><span class="kw">typeof</span> helloDolly<span class="op">&gt;&gt;</span>()</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true"></a>verifyExtends<span class="op">&lt;</span>Payload<span class="op">&lt;</span><span class="kw">typeof</span> datedHello<span class="op">&gt;,</span> Payload<span class="op">&lt;</span>object<span class="op">&gt;&gt;</span>()</span></code></pre></div>
<p>Implementations of <code>interface Payload&lt;T&gt;</code> do not need to behave in a covariant way.<br />
An example in the linked github repo exploits <code>interface Payload&lt;T&gt;</code> covariance and ends up passing a <code>number</code> to a function that accepts <code>string</code> input.</p>
<p>Invariance would have been a better (a more conservative) choice for both <code>interface Payload&lt;T&gt;</code> and the array.<br />
A careful reader may notice that the structurally typed <code>type Payload1&lt;T&gt; = {payload: T}</code> should also be invariant since the <code>payload</code> property is mutable (getters are covariant, setters are contravariant). TS incorrectly makes it covariant.</p>
<p>I will sound like a broken record now, subtyping is clearly very complex.</p>
<p>I did more digging into it after writing this note. It appears that the intention was to keep TS conceptually easy (<a href="https://github.com/microsoft/TypeScript/issues/1394" target="_blank">issue #1394</a>).<br />
The result may be easy but is definitely not simple.</p>
<p><em>Incorrect is never simple.</em></p>
<p> <div class="side-note"><strong>Observation (Rant Alert)</strong>: There is a tendency to focus on common cases and ignore corner cases. This tendency has a broad scope, broader than TS. What has (typically) a lower cost: resolving a problem that every user observes when opening the app or resolving a problem that affects 1% of users once a month? Are less frequently observed defects assigned a lower priority? Not really.<br />
Common approach to software and language design and the economics of software maintenance are an ill matched couple.  </div></p>
<h3 id="summary">Summary</h3>
<p>This was a very hard note to write. I rewrote it several times. How do I write about complexity and make it simple to read?<br />
Seems like a catch-22 problem.</p>
<blockquote>
<p>“One does not simply explain TS types”</p>
</blockquote>
<p><em>Boromir about TypeScript</em></p>
<p>Again, my main claims are:</p>
<ul>
<li>subtyping adds significant complexity and lowers type safety</li>
<li>ad-hoc semantic narrowing around JS operators partially recovers safety, but is complex by itself and scope limited</li>
</ul>
<p>Languages with simpler and more reliable type systems are not a superset of JS syntax and are idiomatically far from JS<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>.</p>
<p>We have observed some compilation issues and irregularities. To summarize these:</p>
<ul>
<li>issues inferring literal types widened to a union (<a href="#subtyping"><code>eq(1, "boo")</code></a>)</li>
<li>issues preventing intersecting unions involving literal types (<a href="#subtyping"><code>(1 | "boo") &amp; ("boo" | Person)</code></a>)</li>
<li>unexpected widening of literal object property types (<a href="#hidden-blooper-side-note">hidden blooper</a>)</li>
<li>inconsistent widening of function arguments (top of <a href="#variance-problems">variance problems</a>)</li>
<li>incorrect handling of variance (<a href="#variance-problems">variance problems</a>)</li>
<li><code>===</code> rejects the <code>&amp;</code> overlap of intersection types, while claiming the opposite in the error message (<a href="#semantics-rejected-overlap">rejected overlap</a>)</li>
</ul>
<p>I cannot identify TypeScript documentation or tickets relevant to these bullets. The subset I have checked against <a href="https://github.com/microsoft/TypeScript/issues" target="_blank">TS issue board</a> is either in the known issues and / or “Working as Intended” category. My question about known issues is: known by whom?</p>
<p>Introduced tools</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true"></a>declare <span class="kw">function</span> unify<span class="op">&lt;</span>T<span class="op">&gt;</span>(t1<span class="op">:</span> T<span class="op">,</span> t2<span class="op">:</span> T) <span class="op">:</span> T</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true"></a><span class="kw">function</span> verifyExtends<span class="op">&lt;</span>T2 <span class="kw">extends</span> T1<span class="op">,</span> T1<span class="op">&gt;</span>() {}</span></code></pre></div>
<p>can be used to ask TS subtyping questions.</p>
<h2 id="next-chapter">Next Chapter</h2>
<p>This post has been about the “messy” in TS. The next installment will focus on programming with type variables and will present TS in a better light. I decided to split advanced topics into 2 smaller posts. I plan to discuss phantom types, type variable scoping, a pattern emulating existential types, and rank 2 types. I consider these to be quite useful typing approaches. I will also show a trick that prevents <code>unknown</code> and supertype widening.</p>
<p>Here is the link: <a href="2022-01-09-ts-types-part4.html" target="_blank">Part 4</a>.</p>
<p>Happy New Year to all of my readers. Thank you for reading.</p>
<h2 id="summary-of-final-edits">Summary of final edits</h2>
<ul>
<li>Added information about <code>as const</code> in <a href="#hidden-blooper-side-note">Hidden blooper note</a></li>
<li>Added note about tickets relevant to the <a href="#semantics-rejected-overlap">overlap issue</a> (see footnote <a href="#fn4">4</a>)</li>
<li>Added side note about arity in <a href="#subtyping">Subtyping</a>.</li>
</ul>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p><a href="#semantics-rejected-overlap">rejected overlap</a> section explains why I call it a guess.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>All can be used for frontend development and can be compiled to JS.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>Haskell is still improving on this aspect. IMO, the need for polymorphic access to record fields is overrated. I would trade it for a capable compiler any time.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>See <a href="https://github.com/microsoft/TypeScript/issues/27910" target="_blank">#27910</a> I created <a href="https://github.com/microsoft/TypeScript/issues/48628" target="_blank">#48628</a> which was originally marked as “Working as Intended” and then moved to “Duplicate” status.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>I have not used <em>flow</em> recently, and I cannot compare TS to it. However <em>flow</em> has subtyping which I do not consider simple. Indeed, some level of subtyping support is needed to support commonly used JS idioms.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

    </section>
</article>

        </main>

        <footer>
             <span><a href="../atom.xml">Atom</a></span>
             <span><a href="../RSS.xml">RSS</a></span>
             <span>Site generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a></span>
        </footer>
    </body>
</html>
