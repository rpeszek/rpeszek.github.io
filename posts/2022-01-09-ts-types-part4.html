<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Infrequent, Pragmatic, Lambda Blog - Type Enthusiast's Notes about TypeScript. Part 4. Programming with Type Variables</title>
        <link rel="alternate" type="application/atom+xml" href="https://rpeszek.github.io/atom.xml" title="atom" />
        <link rel="alternate" type="application/rss+xml" href="https://rpeszek.github.io/RSS.xml" title="rss" />
        <!-- <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="atom"/>
        <link rel="alternate" type="application/rss+xml" href="/RSS.xml" title="rss"/> -->
        <link rel="stylesheet" href="../css/reset.css" />
        <link rel="stylesheet" href="../css/predefault.css" />
        <link rel="stylesheet" href="../css/default.css" />
        
        <link rel="stylesheet" href="../css/ts.css" />
        
        
    </head>
    <body>
        <header>
            <div class="motto">
                <a href="../">hmm >>= oh!</a>
            </div>
            <div class="logo">
                <a href="../">Infrequent, Pragmatic, Lambda Blog</a>
            </div>
            <nav>
                <!-- <a href="/">Home</a> -->
                <a href="../thoughts.html">Semiserious</a>
                <a href="../about.html">About</a>
                <!-- <a href="/contact.html">Contact</a> -->
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>Type Enthusiast's Notes about TypeScript. Part 4. Programming with Type Variables</h1>
            <article>
    <section class="header">
        Posted on January  9, 2022
        
            by Robert Peszek
        
        
        
        <div class="changelog"> <div>Revision History: <ul> <li> (2022.05.10 - 2022.05.29) Minor edits </li> <li> (2022.05.29) Draft warning removed </li> </ul> </div></div>
        
        
        <div class="info">Tags: <a title="All pages tagged 'TypeScript-Notes'." href="../tags/TypeScript-Notes.html">TypeScript-Notes</a></div>
        
    </section>
    <section>

    </section>
    <section>
        <div class="toc"><div class="header">Table of Contents</div>
<ul>
<li><a href="#nutshell">Nutshell</a></li>
<li><a href="#safety-preventing-unknown">Safety preventing <code>unknown</code></a></li>
<li><a href="#type-variable-scoping">Type variable scoping</a></li>
<li><a href="#higher-rank-types">Higher Rank types</a></li>
<li><a href="#existential-types">Existential types</a>
<ul>
<li><a href="#replacing-factory-pattern">Replacing factory pattern</a></li>
<li><a href="#preventing-information-escape">Preventing information escape</a></li>
</ul></li>
<li><a href="#safety-preventing-subtyping">Safety preventing subtyping</a></li>
<li><a href="#phantom-types">Phantom types</a></li>
<li><a href="#next-chapter">Next Chapter</a></li>
</ul>
</div>
<p><em>Please Leave Feedback in: <a href="https://github.com/rpeszek/rpeszek.github.io/discussions/1" target="_blank">git discussions</a></em></p>
<p>Previous post: <a href="2022-01-03-ts-types-part3.html" target="_blank">Part 3. TS Complexity</a>.</p>
<p><strong>Disclaimers:</strong> (imagine this is a very small font, read it very fast in a half whisper)<br />
<em>I assume strict compiler flags are on, something you get by default with scaffolding, e.g. using <code>create-react-app my-project --template typescript</code> is close enough.<br />
The code examples have been tested with TypeScript v4.5.2.<br />
This post is a pandoc output of a markdown document and code examples are not interactive.<br />
Most of the code examples are published in <a href="https://github.com/rpeszek/ts-experiments/tree/master/ts-notes" target="_blank">ts-notes</a> folder in this github repo: <a href="https://github.com/rpeszek/ts-experiments" target="_blank">ts-experiments</a>.</em></p>
<p><strong>Motivating Quote for the series:</strong></p>
<blockquote>
<p>“TypeScript began its life as an attempt to bring traditional object-oriented types to JavaScript so that the programmers at Microsoft could bring traditional object-oriented programs to the web. As it has developed, TypeScript’s type system has evolved to model code written by native JavaScripters. The resulting system is <em>powerful, interesting and messy.</em>”</p>
</blockquote>
<p><em>From typescriptlang <a href="https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html" target="_blank">TypeScript for Functional Programmers</a></em></p>
<h2 id="nutshell">Nutshell</h2>
<p>This is the fourth post in the series devoted to types in TypeScript. In this series, I explore type-centric approaches to writing code and push TS to its limits in doing so. I am writing these posts for like minded developers who are interested in types and either use or consider using TypeScript.</p>
<p>This post will be a little more advanced and will focus on programming with type variables.</p>
<p><a href="https://www.goodreads.com/book/show/112252.Types_and_Programming_Languages" target="_blank">Types and Programming Languages</a> is the book about types I recommend to everyone (… even if not very successfully). Reading TAPL will be a big eye opener for many developers. The good news is that types dramatically increase programming efficiency so learning them is a good investment.<br />
This section of the post will be a little more TAPL-ish with some more advanced CS. The topics I am about to present are IMO very useful and I will try my best to present them in a digestible way.</p>
<p>I will discuss type variable scoping, rank-2 types, and existential types. Some examples show a level of safety that I did not expect to be able to pull off! As it turns out, we can even prevent subtyping in TS.</p>
<p>Before we start I need to build up some tooling. I will start with a tiny bit of type level programming.</p>
<h2 id="safety-preventing-unknown">Safety preventing <code>unknown</code></h2>
<p>In previous posts, we have seen examples where TS decided to widen types to <code>unknown</code> rather than report a compilation error.<br />
Interestingly, TS allows enough type level programming so we can try to fix such issues ourselves.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>type IsUnknown<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">=</span> unknown <span class="kw">extends</span> T<span class="op">?</span> <span class="kw">true</span><span class="op">:</span> <span class="kw">false</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="kw">function</span> verifyUnknown<span class="op">&lt;</span>T<span class="op">&gt;</span>(p<span class="op">:</span> IsUnknown<span class="op">&lt;</span>T<span class="op">&gt;,</span> t<span class="op">:</span> T)<span class="op">:</span> T {</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>    <span class="cf">return</span> t</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>}</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a><span class="fu">verifyUnknown</span>(<span class="kw">false</span><span class="op">,</span> <span class="st">&quot;test&quot;</span>)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a><span class="kw">const</span> unk<span class="op">:</span> unknown <span class="op">=</span> {}</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a><span class="fu">verifyUnknown</span>(<span class="kw">true</span><span class="op">,</span> unk)</span></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="co">//Compilation Error</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="co">//Argument of type 'false' is not assignable to parameter of type 'true'.ts(2345)</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="fu">verifyUnknown</span>(<span class="kw">false</span>, unk)</span></code></pre></div>
<p>In my first post, I had an example of incorrect code <a href="2021-12-12-ts-types-part1.html#bumps-on-the-path" target="_blank"><code>body4</code></a> inferred as <code>unknown</code> instead of a <code>string</code>. Wrapping such code in <code>verifyUnknown(false, body4)</code> would have alerted me with a compilation error.<br />
You may point out that a much simpler solution is to just type annotate: <code>const body4: string</code>.<br />
I agree. However, having a more generic solution at our disposal is also useful. We will see shortly why.</p>
<p>Here is a short TAPL-ish explanation of what just happened. TS allows me to use type level ternaries. <code>IsUnknown&lt;T&gt;</code> is a type level function (TAPL’sh term for this is <em>Type Family</em>) that maps types <code>T</code> to literal boolean types <code>true</code> or <code>false</code>. These types have only a single (a <em>singleton</em>) value: <code>true: true</code> and <code>false: false</code>. If I write <code>verifyUnknown(false, someExpression)</code>, TS will figure out that it has to use <code>false</code> as the type. <code>false</code> matches the second part of the type level ternary and, thus, implies that the ternary predicate <code>unknown extends T</code> is not true. Hence <code>T</code> is not <code>unknown</code>.</p>
<p>I will use <code>verifyUnknown</code> to do some type level trickery. You may wonder if we can extend this approach to other types, not just to <code>unknown</code>. I will get there in this post as well.</p>
<h2 id="type-variable-scoping">Type variable scoping</h2>
<p>Type variable scoping has two aspects. Let’s start with the most obvious one. The type variable being visible inside of the implementation body. This is simple stuff, I just want to share an obvious gotcha that got me at some point:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="im">export</span> <span class="kw">const</span> bodyScopeExample1 <span class="op">=</span> <span class="op">&lt;</span>T<span class="op">&gt;</span>(value<span class="op">:</span> T <span class="op">|</span> <span class="kw">undefined</span> <span class="op">|</span> <span class="kw">null</span>)<span class="op">:</span> <span class="kw">void</span> <span class="kw">=&gt;</span> {</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>    <span class="cf">if</span>(value) {</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>        <span class="kw">const</span> <span class="dt">t</span><span class="op">:</span> T <span class="op">=</span> value <span class="co">//you can access type variables in function body</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>    }</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>}</span></code></pre></div>
<p>This approach to defining type signatures (actually my preferred way to write function type signatures) puts <code>T</code> out of scope:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>export <span class="dt">const</span> bodyScopeExample2: &lt;T&gt;(_: T | undefined | <span class="kw">null</span>) =&gt; <span class="dt">void</span> = value =&gt; {</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>    <span class="kw">if</span>(value) {</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>        <span class="dt">const</span> t: T = value  <span class="co">//Cannot find name 'T'.ts(2304)</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>    }</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>}</span></code></pre></div>
<p>For the type variables to be visible in the implementation they need to be on the <em>RHS</em> of <code>=</code>.</p>
<p>The other aspect of type variable scoping is much more interesting:</p>
<h2 id="higher-rank-types">Higher Rank types</h2>
<p>Consider these 2 function declarations:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>declare <span class="kw">function</span> fn1<span class="op">&lt;</span>T<span class="op">&gt;</span> (f<span class="op">:</span>(t<span class="op">:</span>T)<span class="kw">=&gt;</span> <span class="kw">void</span>)<span class="op">:</span> <span class="kw">void</span> </span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>declare <span class="kw">function</span> <span class="fu">fn2</span>(f<span class="op">:</span> <span class="op">&lt;</span>T<span class="op">&gt;</span>(t<span class="op">:</span>T)<span class="kw">=&gt;</span> <span class="kw">void</span>)<span class="op">:</span> <span class="kw">void</span> </span></code></pre></div>
<p>In <code>fn2</code> the scope of <code>T</code> is much narrower. In TAPL-ish this would be called a rank-2 type.<br />
So what is the difference? Let’s try to use both:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="kw">const</span> useStr <span class="op">=</span> (s<span class="op">:</span>string)<span class="op">:</span> <span class="kw">void</span> <span class="kw">=&gt;</span> {}</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="fu">fn1</span>(useStr)</span></code></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="co">//Compilation Error:</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="co">//const useStr: (s: string) =&gt; void</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a><span class="co">//Argument of type '(s: string) =&gt; void' is not assignable to parameter of type '&lt;T&gt;(t: T) =&gt; void'.</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a><span class="co">//  Types of parameters 's' and 't' are incompatible.</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a><span class="co">//    Type 'T' is not assignable to type 'string'.ts(2345)</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a><span class="fu">fn2</span>(useStr)</span></code></pre></div>
<p>Basically <code>fn2</code> requires the argument to be fully generic and <code>useStr</code> is not.</p>
<p>I can play the same games with generic arguments that return <code>T</code></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>declare <span class="kw">function</span> <span class="fu">fn4</span>(f<span class="op">:</span> <span class="op">&lt;</span>T<span class="op">&gt;</span>() <span class="kw">=&gt;</span> T)<span class="op">:</span> <span class="kw">void</span></span></code></pre></div>
<p>but will not do that here as these tend to be less practically useful.</p>
<p>Here is how I think about it:</p>
<p><em>Higher rank means generics are first class</em></p>
<h2 id="existential-types">Existential types</h2>
<p>In TAPL-ish this is called <em>existential quantification</em> and it has to do with the ownership of definitions. In OO you would say “code to interfaces, not implementation”, it is also related to the OO concepts of <em>inversion of control</em> and <em>dependency injection</em>. Here is how the story goes:</p>
<h3 id="replacing-factory-pattern">Replacing factory pattern</h3>
<div class="sourceCode" id="cb9"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">interface</span> Foo {</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>    <span class="dt">foo</span><span class="op">:</span> string</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>}</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a><span class="kw">class</span> MyFoo <span class="kw">implements</span> Foo{</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>    <span class="dt">foo</span><span class="op">:</span> string</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>    <span class="fu">constructor</span>() {</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>        <span class="kw">this</span><span class="op">.</span><span class="at">foo</span> <span class="op">=</span> <span class="st">&quot;bar&quot;</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a>    }</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a>}</span></code></pre></div>
<p>We want to be able to hide which implementation of <code>Foo</code> we are passing to a callback.<br />
Our first approach tries to use a vanilla TS generic function with a callback argument.<br />
The input function parameter uses some <code>&lt;T extends Foo&gt;</code> of an unknown exact implementation type:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>function factoryWithCallback&lt;T <span class="kw">extends</span> Foo&gt; (f:(_:T) =&gt; <span class="dt">void</span>): <span class="dt">void</span> {</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>    <span class="co">//Argument of type 'MyFoo' is not assignable to parameter of type 'T'.</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>    <span class="co">// 'MyFoo' is assignable to the constraint of type 'T', but 'T' could be instantiated with a different subtype of constraint 'Foo'.ts(2345)</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>    <span class="fu">f</span>(<span class="kw">new</span> <span class="fu">MyFoo</span>()) <span class="co">//Compilation Error</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>}</span></code></pre></div>
<p>It does not work and it should not work! We need to use a rank-2 definition:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="co">//Compiles!</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a><span class="kw">function</span> <span class="fu">existencialFactory</span>(f<span class="op">:</span> <span class="op">&lt;</span>T <span class="kw">extends</span> Foo<span class="op">&gt;</span>(_<span class="op">:</span>T) <span class="kw">=&gt;</span> <span class="kw">void</span>)<span class="op">:</span> <span class="kw">void</span> {</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>    <span class="fu">f</span>(<span class="kw">new</span> <span class="fu">MyFoo</span>())</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>}</span></code></pre></div>
<p>This simulates what is called an existential type. The function that accepts a callback owns the definition of the exact type that is passed to the callback. The callback itself needs to be generic and accept any possible implementation.<br />
Note the scoping of <code>T</code> inside the type defining the function parameter.</p>
<p>This <em>inverts the control</em> from the implementation of the callback to the caller.</p>
<p> <div class="side-note"><strong>Note on terminology:</strong> Repeating the above definitions</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a>declare <span class="kw">function</span> fn1<span class="op">&lt;</span>T<span class="op">&gt;</span> (f<span class="op">:</span>(t<span class="op">:</span>T)<span class="kw">=&gt;</span> <span class="kw">void</span>)<span class="op">:</span> <span class="kw">void</span> </span></code></pre></div>
<p>The <code>fn1</code> needs to be defined for all possible types <code>T</code>. The name for it is <em>universal quantification</em>. Some languages even use the <code>forall</code> keyword to describe it.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a>declare <span class="kw">function</span> <span class="fu">fn2</span>(f<span class="op">:</span> <span class="op">&lt;</span>T<span class="op">&gt;</span>(t<span class="op">:</span>T)<span class="kw">=&gt;</span> <span class="kw">void</span>)<span class="op">:</span> <span class="kw">void</span> </span></code></pre></div>
<p><code>fn2</code> function parameter <code>f</code> needs to be defined for all possible types <code>T</code>. However, <code>fn2</code> can pick whatever type it wants for <code>T</code> and use <code>f</code> with it.<br />
In other words, there exists some type <code>T</code> that will be used but <code>f</code> has no way of knowing which. The name for it is <em>existential quantification</em>. Some languages even use the <code>exists</code> keyword to describe it.</p>
<p>The general concept of existentials is broader than what I am describing here and what TS supports. However, this by itself is plenty powerful.  </div></p>
<h3 id="preventing-information-escape">Preventing information escape</h3>
<p>I am drawing a blank trying to think about an OO analogy for this. It is somewhat related to friend classes in C++, package-private scope in Java … only not exactly.<br />
This example will accomplish more than the above ‘factory’ pattern and will not use any interfaces or classes:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="co">// Using higher rank to protect data</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a><span class="co">// Imaginary world without debuggers, JSON.stringify, etc</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>type Api <span class="op">=</span> {<span class="dt">getGoodies</span><span class="op">:</span> string[]}</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a><span class="co">//provides access to API, password needs to be protected</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a>declare <span class="kw">function</span> login<span class="op">&lt;</span>Password<span class="op">&gt;</span>(p<span class="op">:</span> Password)<span class="op">:</span> Api </span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true"></a><span class="co">//provide password to a computation, that computation should be able to use the password but shouldn't return it</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true"></a><span class="kw">const</span> secretive <span class="op">=</span> <span class="op">&lt;</span>R<span class="op">&gt;</span> (fn<span class="op">:</span> <span class="op">&lt;</span>Password<span class="op">&gt;</span> (p<span class="op">:</span> Password) <span class="kw">=&gt;</span> R)<span class="op">:</span> R  <span class="kw">=&gt;</span> {</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true"></a>   <span class="kw">const</span> <span class="dt">s</span> <span class="op">:</span> any <span class="op">=</span> <span class="st">&quot;topsecret&quot;</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true"></a>   <span class="cf">return</span> <span class="fu">fn</span> (s)</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true"></a>}</span></code></pre></div>
<p>The example is somewhat contrived with the main goal of illustrating the point.<br />
This code exposes building blocks that work together. To get the access to the <code>Api</code> type, you have to use <code>login</code> and you have to use it inside the provided <code>secretive</code> function. Working with an API like this is like assembling a jigsaw puzzle. Types prevent from jamming a square peg into a round hole.<br />
Note, <code>Password</code> is a type variable and we have used the existential type trick.</p>
<p>This code uses the building blocks:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="kw">const</span> goodProgram <span class="op">=</span> <span class="op">&lt;</span>Password<span class="op">&gt;</span>(p<span class="op">:</span> Password)<span class="op">:</span> string[] <span class="kw">=&gt;</span> {</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>    <span class="kw">const</span> api <span class="op">=</span> <span class="fu">login</span>(p)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>    <span class="cf">return</span> api<span class="op">.</span><span class="at">getGoodies</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a>}</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a><span class="kw">const</span> stealPassword <span class="op">=</span> <span class="op">&lt;</span>Password<span class="op">&gt;</span>(p<span class="op">:</span> Password)<span class="op">:</span> Password <span class="kw">=&gt;</span> p</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true"></a><span class="fu">secretive</span>(goodProgram)</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true"></a><span class="fu">secretive</span>(stealPassword)</span></code></pre></div>
<p>Unfortunately, <code>secretive(stealPassword)</code> compiles. Somewhat typical of TS, instead of providing robust type safety, the compiler infers <code>unknown</code> and accepts my questionable code. Hovering over <code>secretive</code> shows me this:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="co">//const secretive: &lt;string[]&gt;(fn: &lt;Password&gt;(p: Password) =&gt; string[]) =&gt; string[]</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a><span class="fu">secretive</span>(goodProgram)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a><span class="co">//const secretive: &lt;unknown&gt;(fn: &lt;Password&gt;(p: Password) =&gt; unknown) =&gt; unknown</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a><span class="fu">secretive</span>(stealPassword)</span></code></pre></div>
<p>That is why I have created the <code>verifyUnknown</code> safety in the previous section:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="kw">const</span> valid <span class="op">=</span> <span class="fu">verifyUnknown</span>(<span class="kw">false</span><span class="op">,</span> <span class="fu">secretive</span>(goodProgram)) <span class="co">//valid: string[]</span></span></code></pre></div>
<div class="sourceCode" id="cb18"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="co">//Argument of type 'false' is not assignable to parameter of type 'true'.ts(2345)</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a><span class="dt">const</span> invalid = <span class="fu">verifyUnknown</span>(<span class="kw">false</span>, <span class="fu">secretive</span>(stealPassword)) <span class="co">//does not compile!</span></span></code></pre></div>
<p>To make it a bit nicer we can package <code>verifyUnknown</code> and <code>secretive</code> into one function:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="kw">const</span> verySecretive <span class="op">=</span> <span class="op">&lt;</span>R<span class="op">&gt;</span> (_<span class="op">:</span> IsUnknown<span class="op">&lt;</span>R<span class="op">&gt;,</span> fn<span class="op">:</span> <span class="op">&lt;</span>Password<span class="op">&gt;</span> (p<span class="op">:</span> Password) <span class="kw">=&gt;</span> R)<span class="op">:</span> R  <span class="kw">=&gt;</span> {</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a>    <span class="kw">const</span> <span class="dt">s</span> <span class="op">:</span> any <span class="op">=</span> <span class="st">&quot;topsecret&quot;</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a>    <span class="cf">return</span> <span class="fu">fn</span> (s)</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a> }</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true"></a><span class="kw">const</span> valid <span class="op">=</span> <span class="fu">verySecretive</span>(<span class="kw">false</span><span class="op">,</span> goodProgram) <span class="co">//valid: string[]</span></span></code></pre></div>
<div class="sourceCode" id="cb20"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="dt">const</span> invalid = <span class="fu">verySecretive</span>(<span class="kw">false</span>, stealPassword) </span></code></pre></div>
<p>This creates some interesting safety. Obviously you could still do a lot of mischief if you wanted to. There is a need for some ‘gentlemen’s agreements’ to not use casting, <code>JSON.stringify</code>, to not use <code>true</code> in <code>verySecretive</code> etc. However, if you think about creating clear contract APIs, this approach could be very powerful.</p>
<p>Existentials are not exactly equivalent to OO. However, using existential types can often accomplish a lot of the same things and often in a cleaner way. Using existentials and disabling OO features like <code>unknown</code> feels a bit contrived, but IMO is still useful. It would be nice if TS provided a cleaner way to disable the use of <code>unknown</code>.<br />
I do not know how robust this type of coding is. I have not played enough with this approach in TS to give you a list of gotchas. In my very limited experience, this seems similar to the rest of TS, TS stops working if I start pushing harder.</p>
<p> <div class="side-note"><strong>Existentials and higher rank at large:</strong> These concepts have lead to some amazing programming.<br />
For example, existentials are related to dependent pairs (dependent sums) in depenently typed programming languages. Dependent typing provides some very strong types. One example could be lists with a type checked length. You want to be able to use such lists when processing runtime data that can have arbitrary size. That size ‘exists’ but cannot be known statically at the compile time. This is in essence an existential construction.</p>
<p>Another amazing example is an old (1993) code called <em>State Threads (ST)</em> (currently part of std base library in Haskell). It allows to use a local mutable state to define computations that have to be <em>referentially transparent</em> (I have discussed referential transparency in <a href="2021-12-24-ts-types-part2.html#referential-transparency" target="_blank">Part 2</a>). This is possible because the access to mutate the state cannot escape outside of these computations. ST API remains unchanged since it was created 30 year ago, you can’t improve on perfection!</p>
<p>I see higher rank types, mostly rank-2 being used a lot. Having ability to pass generic (polymorphic) functions around is very useful. In my non-TS projects, the problem of ‘separating interface from implementation’ is typically solved by defining an EDSL (Embedded Domain Specific Language) and an interpreter. Interpreters are polymorphic (generic in TS lingo). Rank-2 types have to be used to make them first class and pass them around.  </div></p>
<h2 id="safety-preventing-subtyping">Safety preventing subtyping</h2>
<p>Many TS users have observed the need for this. The term <em>exact type</em> is floating around, I believe <em>flow</em> introduced this name. I have seen solutions like this one being proposed:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="kw">function</span> exact<span class="op">&lt;</span>T<span class="op">&gt;</span>(item<span class="op">:</span>T)<span class="op">:</span> T {</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a>    <span class="cf">return</span> item</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a>}</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a>type Hello <span class="op">=</span> {<span class="dt">hello</span><span class="op">:</span> string}</span></code></pre></div>
<div class="sourceCode" id="cb22"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="co">//Argument of type '{ hello: string; since: number; }' is not assignable to parameter of type 'Hello'.</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a><span class="co">//  Object literal may only specify known properties, and 'since' does not exist in type 'Hello'.ts(2345)</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a>exact&lt;Hello&gt;({hello: <span class="st">&quot;world&quot;</span>, since:<span class="dv">2002</span>})</span></code></pre></div>
<p>This safety is fragile (and a TS design inconsistency IMO) as the following example shows:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="kw">const</span> helloSince <span class="op">=</span> {<span class="dt">hello</span><span class="op">:</span> <span class="st">&quot;world&quot;</span><span class="op">,</span> <span class="dt">since</span><span class="op">:</span><span class="dv">2002</span>}</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a>exact<span class="op">&lt;</span>Hello<span class="op">&gt;</span>(helloSince) <span class="co">//complies</span></span></code></pre></div>
<p>To create something more robust, here is a code that combines the above <code>unknown</code> verification idea with existentials:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a>type Same<span class="op">&lt;</span>P<span class="op">,</span>T<span class="op">&gt;</span> <span class="op">=</span> P <span class="kw">extends</span> T<span class="op">?</span> (T <span class="kw">extends</span> P<span class="op">?</span> <span class="kw">true</span><span class="op">:</span> <span class="kw">false</span>)<span class="op">:</span> <span class="kw">false</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a><span class="kw">const</span> verifySame <span class="op">=</span> <span class="op">&lt;</span>P<span class="op">&gt;</span> () <span class="kw">=&gt;</span> <span class="op">&lt;</span>T<span class="op">&gt;</span> (_<span class="op">:</span> Same<span class="op">&lt;</span>P<span class="op">,</span>T<span class="op">&gt;,</span> t<span class="op">:</span>T)<span class="op">:</span> T <span class="kw">=&gt;</span> t</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a>verifySame<span class="op">&lt;</span>Hello<span class="op">&gt;</span>()(<span class="kw">true</span><span class="op">,</span> {<span class="dt">hello</span><span class="op">:</span> <span class="st">&quot;world&quot;</span>}) <span class="co">//'true' indicates that type matches</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true"></a>verifySame<span class="op">&lt;</span>Hello<span class="op">&gt;</span>()(<span class="kw">false</span><span class="op">,</span> {<span class="dt">hello</span><span class="op">:</span> <span class="st">&quot;world&quot;</span><span class="op">,</span> <span class="dt">since</span> <span class="op">:</span> <span class="dv">2020</span>}) <span class="co">//'false' is needed to acknowledge types are different </span></span></code></pre></div>
<div class="sourceCode" id="cb25"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a><span class="co">//Argument of type 'true' is not assignable to parameter of type 'false'.ts(2345)</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a>verifySame&lt;Hello&gt;()(<span class="kw">true</span>, {hello: <span class="st">&quot;world&quot;</span>, since : <span class="dv">2020</span>})</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a>verifySame&lt;Hello&gt;()(<span class="kw">true</span>, helloSince)</span></code></pre></div>
<p>You may have noticed a case of typing euphoria here. I used rank-2 construction because it allows me to type annotate with only one type variable. This is nice but often not essential.</p>
<p>Here is an implementation of <code>safePush</code> that acts invariant, it does not use any existential tricks:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a><span class="co">//Note to get 'safePush' I ended up with casting, this is a quick and dirty example and can be done slightly better</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a><span class="co">// However, this cast could be an indication that we are changing how TS compiler works</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true"></a><span class="co">// Kinda makes sense, to overrule the compiler I may need to cast</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true"></a><span class="kw">const</span> safePush <span class="op">=</span> <span class="op">&lt;</span>P<span class="op">,</span> T<span class="op">&gt;</span> (_<span class="op">:</span> Same<span class="op">&lt;</span>P<span class="op">,</span>T<span class="op">&gt;,</span> ps<span class="op">:</span> P[]<span class="op">,</span> t<span class="op">:</span> T)<span class="op">:</span> number <span class="kw">=&gt;</span> ps<span class="op">.</span><span class="fu">push</span>(t <span class="im">as</span> any)</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true"></a></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true"></a><span class="kw">const</span> intlist<span class="op">:</span> number[] <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>]</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true"></a><span class="kw">const</span> unklist<span class="op">:</span> unknown[] <span class="op">=</span> intlist  <span class="co">//exploits array covariance</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true"></a>unklist<span class="op">.</span><span class="fu">push</span>(<span class="st">&quot;not a number&quot;</span>) <span class="co">//unsafe 'push' adds a 'string' to 'intlist'</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true"></a></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true"></a><span class="fu">safePush</span>(<span class="kw">true</span><span class="op">,</span> intlist<span class="op">,</span> <span class="dv">1</span>) <span class="co">//this is safe</span></span></code></pre></div>
<div class="sourceCode" id="cb27"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a><span class="fu">safePush</span>(<span class="kw">true</span>, unklist, <span class="dv">1</span>)    <span class="co">//this is risky and will not compile </span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true"></a><span class="fu">safePush</span>(<span class="kw">true</span>, unklist, <span class="st">&quot;not a number&quot;</span>) <span class="co">//this is risky (here wrong) and will not compile </span></span></code></pre></div>
<p>Note, to be even safer I would need to prevent <code>unknown</code> as well:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a><span class="kw">const</span> unkstr<span class="op">:</span> unknown <span class="op">=</span> <span class="st">&quot;not a number&quot;</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true"></a><span class="fu">safePush</span>(<span class="kw">true</span><span class="op">,</span> unklist<span class="op">,</span> unkstr)  <span class="co">//unfortunately compiles</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true"></a></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true"></a><span class="co">//An even safer version of 'Same'</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true"></a>type SameAndKnown<span class="op">&lt;</span>P<span class="op">,</span>T<span class="op">&gt;</span> <span class="op">=</span> P <span class="kw">extends</span> T<span class="op">?</span> (T <span class="kw">extends</span> P<span class="op">?</span> (unknown <span class="kw">extends</span> T<span class="op">?</span> <span class="kw">false</span><span class="op">:</span> <span class="kw">true</span>)<span class="op">:</span> <span class="kw">false</span>)<span class="op">:</span> <span class="kw">false</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true"></a></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true"></a><span class="kw">const</span> verySafePush <span class="op">=</span> <span class="op">&lt;</span>P<span class="op">,</span> T<span class="op">&gt;</span> (_<span class="op">:</span> SameAndKnown<span class="op">&lt;</span>P<span class="op">,</span>T<span class="op">&gt;,</span> ps<span class="op">:</span> P[]<span class="op">,</span> t<span class="op">:</span> T)<span class="op">:</span> number <span class="kw">=&gt;</span> ps<span class="op">.</span><span class="fu">push</span>(t <span class="im">as</span> any)</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true"></a></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true"></a><span class="fu">verySafePush</span>(<span class="kw">true</span><span class="op">,</span> intlist<span class="op">,</span> <span class="dv">1</span>)  <span class="co">//this is safe</span></span></code></pre></div>
<div class="sourceCode" id="cb29"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a><span class="fu">verySafePush</span>(<span class="kw">true</span>, unklist, unkstr) <span class="co">//this is risky and will not compile!</span></span></code></pre></div>
<p>We have discussed problems with the TS approach to variance in the <a href="2022-01-03-ts-types-part3.html#variance-problems" target="_blank">previous installment</a>. We have a DIY approach to fight back!</p>
<p>Side Note: The linked github repo has an existentially typed version of <code>safePush</code> (<code>safePush2</code>) that has just one top level type variable. That version is more cumbersome to use. TS ends up not working well with it.</p>
<p>Another fun exercise:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a><span class="kw">const</span> safeEq <span class="op">=</span> <span class="op">&lt;</span>P<span class="op">,</span> T<span class="op">&gt;</span> (_<span class="op">:</span> Same<span class="op">&lt;</span>P<span class="op">,</span>T<span class="op">&gt;,</span> a<span class="op">:</span> P<span class="op">,</span> b<span class="op">:</span> T)<span class="op">:</span> boolean <span class="kw">=&gt;</span> a <span class="op">===</span> (b <span class="im">as</span> unknown)</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true"></a></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true"></a><span class="fu">safeEq</span>(<span class="kw">true</span><span class="op">,</span> {<span class="dt">hello</span><span class="op">:</span> <span class="st">&quot;word&quot;</span>}<span class="op">,</span> {<span class="dt">hello</span><span class="op">:</span><span class="st">&quot;dolly&quot;</span>})</span></code></pre></div>
<div class="sourceCode" id="cb31"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true"></a><span class="fu">safeEq</span>(<span class="kw">true</span>, {hello: <span class="st">&quot;word&quot;</span>}, {hello:<span class="st">&quot;word&quot;</span>, since:<span class="dv">2022</span>}))</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true"></a><span class="fu">safeEq</span>(<span class="kw">true</span>, <span class="dv">1</span>, <span class="st">&quot;str&quot;</span>)</span></code></pre></div>
<p>We have discussed problems with TS approach to <code>===</code> narrowing in the <a href="2022-01-03-ts-types-part3.html#complexity-of-ts-types" target="_blank">previous installment</a>. Again, we have a DIY approach to fight back.</p>
<p>This section is related to a number of feature requests: <a href="https://github.com/microsoft/TypeScript/issues/12936" target="_blank">TypeScript issue 12936</a> and <a href="https://github.com/microsoft/TypeScript/issues/7481" target="_blank">TypeScript issue 7481</a>. Hopefully a future version of TS will provide a simpler way to achieve invariance and disable subtyping.</p>
<h2 id="phantom-types">Phantom types</h2>
<p>TypeScript is somewhat unique in supporting <em>Structural Types</em>. Types like <code>type Person = {firstNm: string, lastNm: string}</code> are structural. That means the name <code>Person</code> is only an alias, what defines the type is the RHS of the definition, not the LHS. Contrast this with an OO class definition in a language like Java. Two structurally identical classes are still considered different types (this is called <em>nominal typing</em>).</p>
<p>It is sometimes convenient to be able to define different types that share the same structure. <em>Phantom types</em> are a way to do that. We say <em>phantom</em> because these types have no impact on runtime values.</p>
<p>Somewhere around 2006, haskell wiki published a write-up about <a href="https://wiki.haskell.org/Phantom_type" target="_blank">phantom types</a>. The write-up was expanded in 2010 to include a form validation example. Since then all blogs (in any programming language) about phantoms show a validation example. I decided to be as unoriginal as everyone else. This will allow me to better focus on how it is done in TS.</p>
<p>My first attempt at phantom types in TS will fail. But this code should make the idea behind phantoms clear:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true"></a><span class="co">//Marker type</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true"></a>type Validated <span class="op">=</span> {<span class="dt">type</span><span class="op">:</span> <span class="st">&quot;validated&quot;</span>}</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true"></a></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true"></a><span class="co">//For simplicity this is just a string</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true"></a>type ValidationError <span class="op">=</span> string</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true"></a></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true"></a><span class="co">//Extra phantom type variable 'T' </span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true"></a>type Person<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">=</span> {<span class="dt">firstNm</span><span class="op">:</span> string<span class="op">,</span> <span class="dt">lastNm</span><span class="op">:</span> string}</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true"></a></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true"></a></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true"></a><span class="co">//Validate person in some way returning 'Validated' phantom marker</span></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true"></a>declare <span class="kw">function</span> validate<span class="op">&lt;</span>T<span class="op">&gt;</span>(p<span class="op">:</span> Person<span class="op">&lt;</span>T<span class="op">&gt;</span>)<span class="op">:</span>  ValidationError <span class="op">|</span> Person<span class="op">&lt;</span>Validated<span class="op">&gt;</span> </span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true"></a></span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true"></a><span class="co">//Function to be used only if phantom 'T' is the 'Validated' type </span></span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true"></a>declare <span class="kw">function</span> <span class="fu">doSomethingValidated</span>(p<span class="op">:</span> Person<span class="op">&lt;</span>Validated<span class="op">&gt;</span>)<span class="op">:</span> <span class="kw">void</span></span></code></pre></div>
<p>Again, these types are trying to create a jigsaw puzzle. One I can assemble in a specific way only.<br />
If the puzzle machinery works, I will have to call <code>validate</code> first to be able to use <code>doSomethingValidated</code>.</p>
<p>Only, this machinery does not work. The following code compiles:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true"></a><span class="kw">function</span> validatedOrNot<span class="op">&lt;</span>T<span class="op">&gt;</span>(p<span class="op">:</span> Person<span class="op">&lt;</span>T<span class="op">&gt;</span>)<span class="op">:</span> <span class="kw">void</span> {</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true"></a>    <span class="fu">doSomethingValidated</span>(p)</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true"></a>}</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true"></a></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true"></a>type ClearlyNotValidated <span class="op">=</span> {<span class="dt">type</span><span class="op">:</span> <span class="st">&quot;notvalidated&quot;</span>}</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true"></a></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true"></a><span class="kw">function</span> <span class="fu">notValidated</span> (p<span class="op">:</span> Person<span class="op">&lt;</span>ClearlyNotValidated<span class="op">&gt;</span>)<span class="op">:</span> <span class="kw">void</span> {</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true"></a>    <span class="fu">doSomethingValidated</span>(p)</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true"></a>}</span></code></pre></div>
<p>The fix is to provide a value level information about <code>T</code> in an optional property.<br />
This type definition replaces the one above:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a><span class="co">//Modified definition adds value level representation `phantom?: T` </span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true"></a>type Person<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">=</span> {<span class="dt">firstNm</span><span class="op">:</span> string<span class="op">,</span> <span class="dt">lastNm</span><span class="op">:</span> string<span class="op">,</span> phantom<span class="op">?:</span> T}  </span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true"></a></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true"></a><span class="co">//provide a way to create person that ignores the additional 'phantom' property:</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true"></a><span class="kw">const</span> createPerson <span class="op">:</span> <span class="op">&lt;</span>T<span class="op">&gt;</span>(fst<span class="op">:</span> string<span class="op">,</span> lst<span class="op">:</span> string) <span class="kw">=&gt;</span> Person<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">=</span> (fst<span class="op">,</span> lst) <span class="kw">=&gt;</span> {</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true"></a>    <span class="cf">return</span> {<span class="dt">firstNm</span><span class="op">:</span> fst<span class="op">,</span> <span class="dt">lastNm</span><span class="op">:</span> lst}</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true"></a>} </span></code></pre></div>
<p>Now this compiles:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true"></a><span class="kw">function</span> <span class="fu">validated</span>(p<span class="op">:</span> Person<span class="op">&lt;</span>Validated<span class="op">&gt;</span>)<span class="op">:</span> <span class="kw">void</span> {</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true"></a>    <span class="fu">doSomethingValidated</span>(p)</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true"></a>}</span></code></pre></div>
<p>But these no longer do:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true"></a><span class="co">// Compilation Error</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true"></a><span class="co">// Argument of type 'Person&lt;T&gt;' is not assignable to parameter of type 'Person&lt;Validated&gt;'.</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true"></a><span class="co">//   Type 'T' is not assignable to type 'Validated'.ts(2345)</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true"></a>function validatedOrNot&lt;T&gt;(p: Person&lt;T&gt;): <span class="dt">void</span>{</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true"></a>    <span class="fu">doSomethingValidated</span>(p)</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true"></a>}</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true"></a></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true"></a><span class="co">// Compilation Error</span></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true"></a><span class="co">// Argument of type 'Person&lt;ClearlyNotValidated&gt;' is not assignable to parameter of type 'Person&lt;Validated&gt;'.</span></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true"></a><span class="co">//   Type 'ClearlyNotValidated' is not assignable to type 'Validated'.</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true"></a><span class="co">//     Types of property 'type' are incompatible.</span></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true"></a><span class="co">//       Type '&quot;notvalidated&quot;' is not assignable to type '&quot;validated&quot;'.ts(2345)</span></span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true"></a>function <span class="fu">notValidated</span> (p: Person&lt;ClearlyNotValidated&gt;): <span class="dt">void</span> {</span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true"></a>    <span class="fu">doSomethingValidated</span>(p)</span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true"></a>}</span></code></pre></div>
<p>I believe phantom types are used by some FP libraries in TS, e.g. <em>fp-ts</em>, these libraries use somewhat different techniques to get phantoms. There may be advantages to doing phantom types differently than what I have presented. The above approach is the simplest I can think of.</p>
<p> <div class="side-note"><strong>Phantom types at large:</strong> Phantom types can be used to do a lot of crazy type level stuff. The most wild use I have seen is <a href="https://iohk.io/en/research/library/papers/ghosts-of-departed-proofsfunctional-pearls/" target="_blank">Ghosts of Departed Proofs</a> (this uses Haskell).<br />
Here is a simplified and easy to understand example in TS. Think about a non-mutable list, your function accepts a list and does something with it, your code needs the list to be sorted to work. You can encapsulate this and conservatively sort it just in case (this approach seems not performance optimal), you can document your function by saying that it is the caller responsibility to sort (do developers read documentation?), … or you can introduce a phantom type:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true"></a><span class="co">//Sort status as a phantom type,  'List' has type level information about its sort status.</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true"></a>type List<span class="op">&lt;</span>T<span class="op">,</span> SortStatus<span class="op">&gt;</span> <span class="op">=</span> <span class="op">...</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true"></a></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true"></a><span class="kw">interface</span> Comparator<span class="op">&lt;</span>T<span class="op">&gt;</span> {</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true"></a>    <span class="fu">compare</span> (<span class="dt">o1</span><span class="op">:</span> T<span class="op">,</span> <span class="dt">o2</span><span class="op">:</span> T)<span class="op">:</span> number</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true"></a>}</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true"></a></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true"></a>declare <span class="kw">function</span> sortAscending <span class="op">&lt;</span>T <span class="kw">extends</span> Comparator<span class="op">&lt;</span>T<span class="op">&gt;,</span> AnyStatus<span class="op">&gt;</span> (list<span class="op">:</span> List<span class="op">&lt;</span>T<span class="op">,</span> AnyStatus<span class="op">&gt;</span>)<span class="op">:</span>  List<span class="op">&lt;</span>T<span class="op">,</span> <span class="st">&quot;ascending&quot;</span><span class="op">&gt;</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true"></a></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true"></a>declare <span class="kw">function</span> doSomethingWithSortedList <span class="op">&lt;</span>T <span class="kw">extends</span> Comparator<span class="op">&lt;</span>T<span class="op">&gt;&gt;</span> (list<span class="op">:</span> List<span class="op">&lt;</span>T<span class="op">,</span> <span class="st">&quot;ascending&quot;</span><span class="op">&gt;</span>)<span class="op">:</span> <span class="kw">void</span></span></code></pre></div>
<p>Again, notice the types form pieces of a puzzle and can be fitted only in a specific way.<br />
You can think about a <code>sort</code> as something that not only does what it says, but also provides a <em>token</em> to use later to prove that the sort was done. This <em>token</em> is a phantom type. You can think about creating a library that helps orchestrate a similar approach to programming and this is what the linked article talks about.<br />
Many FP programming languages support GADTs, these are very powerful types and limit the popularity of (subsume) phantom typing.<br />
 </div></p>
<p>Phantom types could be a very powerful API building tool.<br />
I am sure you can think about many other interesting use cases, … like state machines<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p>
<h2 id="next-chapter">Next Chapter</h2>
<p>I want to talk about recursive types and type level programming. It will be more of a review of TS capabilities in these areas.</p>
<p>I need to take a break from writing posts. The next installment will take me longer, maybe a month or a little more, to finish.<br />
Thank you for reading. Happy New Year!</p>
<p>Here is the link: <a href="2022-02-13-ts-types-part5.html" target="_blank">Part 5</a>.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>As an example, office.js is very stateful. It has <em>uninitialized</em> state known to cause problems, there is the application state (e.g. user is writing new email), and much more. My experience with office.js is that the code I write is very sensitive to where is placed and can be very brittle. API like this could be made both safe and self-documenting by using phantom types.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

    </section>
</article>

        </main>

        <footer>
             <span><a href="../atom.xml">Atom</a></span>
             <span><a href="../RSS.xml">RSS</a></span>
             <span>Site generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a></span>
        </footer>
    </body>
</html>
