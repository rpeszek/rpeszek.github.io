<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Infrequent, Pragmatic, Lambda Blog - Maybe Overuse, Stories About Error Information Loss</title>
        <link rel="alternate" type="application/atom+xml" href="https://rpeszek.github.io/atom.xml" title="atom" />
        <link rel="alternate" type="application/rss+xml" href="https://rpeszek.github.io/RSS.xml" title="rss" />
        <!-- <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="atom"/>
        <link rel="alternate" type="application/rss+xml" href="/RSS.xml" title="rss"/> -->
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/syntax.css" /> 
        
    </head>
    <body>
        <header>
            <div class="motto">
                <a href="../">hmm >>= oh!</a>
            </div>
            <div class="logo">
                <a href="../">Infrequent, Pragmatic, Lambda Blog</a>
            </div>
            <nav>
                <!-- <a href="/">Home</a> -->
                <a href="../thoughts.html">Semiserious</a>
                <a href="../about.html">About</a>
                <!-- <a href="/contact.html">Contact</a> -->
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>Maybe Overuse, Stories About Error Information Loss</h1>
            <article>
    <section class="header">
        Posted on January 17, 2021
        
            by Robert Peszek
        
        
          <br /> Last Modified on February 17, 2021
        
        
        <div class="changelog"> <div>Revision History: <ul> <li> (2021.01.18) Added <a href="#monadfail-and-maybe">MonadFail</a> subsection to <a href="#maybe-on-hackage">Maybe on Hackage</a> </li> <li> (2021.02.17-now) <a href="#more-links">More Links</a> (list of related links)</li> </ul> </div></div>
        
        
        <div class="info">Tags: <a title="All pages tagged 'Haskell'." href="../tags/Haskell.html">Haskell</a>, <a title="All pages tagged 'error-messages'." href="../tags/error-messages.html">error-messages</a>, <a title="All pages tagged 'maintainability'." href="../tags/maintainability.html">maintainability</a></div>
        
    </section>
    <section>

    </section>
    <section>
        <div class="toc"><div class="header">Table of Contents</div>
<ul>
<li><a href="#nutshell">Nutshell</a></li>
<li><a href="#error-clarity-rule">Error Clarity Rule</a></li>
<li><a href="#harmful-real-world-examples">Harmful Real-World Examples</a>
<ul>
<li><a href="#maybe-on-hackage"><code>Maybe</code> on Hackage</a></li>
<li><a href="#cut-catmaybes">Cut <code>catMaybes</code></a></li>
<li><a href="#hkd-pattern">HKD pattern</a></li>
<li><a href="#traversable-with-maybe"><code>Traversable</code> with <code>Maybe</code></a></li>
</ul></li>
<li><a href="#questioning-record-types-with-all-maybe-fields">Questioning Record Types with all <code>Maybe</code> Fields</a>
<ul>
<li><a href="#recreating-java-beans-with-maybe">Recreating <em>Java Beans</em> with <code>Maybe</code> ;)</a></li>
<li><a href="#maybe-first-monoid-fields"><em>Maybe-First</em> <code>Monoid</code> fields</a></li>
</ul></li>
<li><a href="#alternative-typeclass"><code>Alternative</code> typeclass</a></li>
<li><a href="#good-uses-of-maybe">Good uses of Maybe</a></li>
<li><a href="#why-maybe-is-overused-possible-explanations">Why <code>Maybe</code> is Overused? Possible Explanations</a></li>
<li><a href="#more-links">More Links</a></li>
</ul>
</div>
<h4 id="motivating-references">Motivating References:</h4>
<p>I was very happy to find Michael Snoyman’s <a href="https://www.snoyman.com/blog/2020/10/haskell-bad-parts-1/" target="_blank">Haskell The Bad Parts</a> series.<br />
I was also motivated by <a href="https://www.michaelpj.com/blog/2021/01/02/elementary-programming.html" target="_blank">Elementary Programming</a> post (<a href="https://www.reddit.com/r/haskell/comments/kst0d3/elementary_programming/" target="_blank">reddit</a>).</p>
<p><strong>Similar:</strong> <a href="https://www.reddit.com/r/haskell/comments/jxj8i/data_maybe_harmful/" target="_blank">reddit data_maybe_harmful</a></p>
<p>This post is Haskell specific.<br />
This post treats the term error colloquially, it does not distinguish between <a href="https://wiki.haskell.org/Error_vs._Exception" target="_blank"><em>exceptions</em> and <em>errors</em></a>. In particular, <em>error information loss</em> refers to exceptions not errors.</p>
<h2 id="nutshell">Nutshell</h2>
<p><code>Maybe</code> is the functional answer to <code>null</code> - the <a href="https://en.wikipedia.org/wiki/Tony_Hoare" target="_blank">billion dollar mistake</a>. I claim that using <code>Maybe</code> can still be problematic.</p>
<p>IMO <code>Maybe</code> is often overused. I have started to question the use of <code>Maybe</code> every time I see it in the code base I maintain. The result is either accepting its usage or rewriting the code to use <code>Either</code>. This approach has been effective in creating more robust code. I am not claiming that <code>Maybe</code> has no place in a well written code, only that its use should be closely examined. I have seen brilliant code that has been hard to maintain because of its overuse of <code>Maybe</code>. This post shares a perspective of someone who maintains a complex Haskell code base.</p>
<p><code>Maybe</code> improves over <code>null</code>. But it does not supersede it. Languages that have <code>null</code> also have easy access to logging, stack traces etc.</p>
<p><code>Maybe</code> typically represents data that can be <em>missing</em> or a computation that can result in an <em>unknown error</em>.<br />
What you typically care about is <em>what data is missing</em> and <em>what is the error</em>.</p>
<p><em>Code correctness</em>, <em>reasoning about code</em> are, arguably, the defining aspects of FP. <em>Reasoning about code</em> typically refers to some advanced use of the type system or formal methods. IMO “reasoning about code” should start with reasoning about errors and corner cases (like missing data). This is why the use of <code>Maybe</code> needs to be examined and questioned. In my experience this aspect of reasoning about code is often overlooked.</p>
<p>Reasoning about errors is not easy: The type system can’t help with errors that bypass it (e.g. <code>error :: String -&gt; a</code>). It can’t help with exceptions which were intentionally suppressed into <code>Nothing</code> <em>(the focus of this post)</em>. And, the list goes on…</p>
<p>My points / pleas are:</p>
<ul>
<li>The ecosystem would be better off without offering convenience combinators that return <code>Maybe</code> if an equivalent returning <code>Either</code> exists</li>
<li>Examples, tutorials, and blog posts should favor <code>Either</code> over <code>Maybe</code></li>
<li>Developers should be careful about not overusing <code>Maybe</code></li>
</ul>
<h2 id="error-clarity-rule">Error Clarity Rule</h2>
<p><em>What does <code>Nothing</code> mean? If the reason behind it can be disambiguated to one root cause, then I consider the use of <code>Maybe</code> justified. Otherwise, I question its use.</em></p>
<p>Consider this code:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Data.Map</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Key</span> <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Value</span> <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a><span class="co">-- OK</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a><span class="ot">phone ::</span> <span class="dt">Map</span> <span class="dt">Key</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Value</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>phone <span class="ot">=</span> <span class="fu">lookup</span> <span class="st">&quot;phone&quot;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a><span class="co">-- OK</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a><span class="ot">email ::</span> <span class="dt">Map</span> <span class="dt">Key</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Value</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a>email <span class="ot">=</span> <span class="fu">lookup</span> <span class="st">&quot;email&quot;</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true"></a><span class="co">-- OK</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true"></a><span class="ot">creditCardNum ::</span> <span class="dt">Map</span> <span class="dt">Key</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Value</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true"></a>creditCardNum <span class="ot">=</span> <span class="fu">lookup</span> <span class="st">&quot;card-number&quot;</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">FormData</span> <span class="ot">=</span> <span class="dt">FormData</span> {</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true"></a><span class="ot">   fdPhone ::</span> <span class="dt">Value</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true"></a>   ,<span class="ot"> fdEmail ::</span> <span class="dt">Value</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true"></a>   ,<span class="ot"> fdCardNum ::</span> <span class="dt">Value</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true"></a>   }</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true"></a><span class="co">-- less OK</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true"></a><span class="ot">formData ::</span> <span class="dt">Map</span> <span class="dt">Key</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">FormData</span>  </span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true"></a>formData <span class="fu">map</span> <span class="ot">=</span> <span class="dt">FormData</span> <span class="op">&lt;$&gt;</span> phone <span class="fu">map</span> <span class="op">&lt;*&gt;</span> email <span class="fu">map</span> <span class="op">&lt;*&gt;</span> creditCardNum <span class="fu">map</span> </span></code></pre></div>
<p>you can clearly explain the first 3 functions:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="ot">explain ::</span> err <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Either</span> err a</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>explain <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Err</span> <span class="ot">=</span> <span class="dt">MissingEmail</span> <span class="op">|</span> <span class="dt">MissingPhone</span> <span class="op">|</span> <span class="dt">MissingCardNum</span> </span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a><span class="ot">email' ::</span> <span class="dt">Map</span> <span class="dt">Key</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">Err</span> <span class="dt">Value</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>email' <span class="ot">=</span> explain <span class="dt">MissingEmail</span> <span class="op">.</span> email</span></code></pre></div>
<p>How do I explain <code>formData</code>? I am stuck with:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">UnknownFieldMissing</span> <span class="ot">=</span> <span class="dt">UnknownFieldMissing</span> </span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a><span class="ot">formData' ::</span> <span class="dt">Map</span> <span class="dt">Key</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">Err</span> <span class="dt">Value</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>formData' <span class="ot">=</span> explain <span class="dt">UnknownFieldMissing</span> <span class="op">.</span> formData</span></code></pre></div>
<p>and that “Unknown” is not a field name.<br />
The bigger the record, the bigger the problem.</p>
<h2 id="harmful-real-world-examples">Harmful Real-World Examples</h2>
<p>These are in no particular order, other than this presentation reuses types defined earlier.</p>
<h3 id="maybe-on-hackage"><code>Maybe</code> on Hackage</h3>
<h4 id="servant-multipart-example"><em>servant-multipart</em> example:</h4>
<p>If you used older versions of <a href="https://hackage.haskell.org/package/servant-multipart" target="_blank">servant-multipart</a> you are familiar with</p>
<p><em>status code 400, message “fromMultipart returned Nothing”</em>.</p>
<p>You must have noticed that your logs have been silent as well.<br />
The fix was implemented in 0.11.6</p>
<p>New version (much better):</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="co">-- version 0.11.6</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">FromMultipart</span> tag a <span class="kw">where</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a><span class="ot">   fromMultipart ::</span> <span class="dt">MultipartData</span> tag <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> a</span></code></pre></div>
<p>Old version:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="co">-- version 0.11.5</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">FromMultipart</span> tag a <span class="kw">where</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a><span class="ot">  fromMultipart ::</span> <span class="dt">MultipartData</span> tag <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span></code></pre></div>
<p>Any typo, missed form field, wrong form field type submitted from the calling program resulted in a meaningless 400 error.<br />
To work around this issue I ended up implementing <code>fromMultipart</code> in <code>Either MultiformError</code> monad and converting it to <code>Maybe</code> with something like that:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="ot">loggedMultipartMaybe ::</span>  <span class="dt">Either</span> <span class="dt">MultipartException</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>loggedMultipartMaybe (<span class="dt">Left</span> err) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>    <span class="kw">let</span> logDetails <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>    <span class="fu">seq</span> </span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>      (debugLogger logDetails) <span class="co">-- uses unsafePeformIO to match your logging style</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>      <span class="dt">Nothing</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>loggedMultipartMaybe (<span class="dt">Right</span> r) <span class="ot">=</span> <span class="dt">Just</span> r </span></code></pre></div>
<p>to, at least, get some logs.</p>
<p>In just one project, that saved me hours in both new development and troubleshooting cost.<br />
For a more complex multipart form that implements both <code>FromMultipart</code> and <code>ToMultipart</code> by hand, verifying that <code>fromMultipart . toMultipart</code> is the identity would have been very hard without some information about errors. If the multipart is called from a different program, different language …</p>
<h4 id="convenience-combinators">Convenience Combinators:</h4>
<p>It should be noted that many popular packages offer convenience <code>Maybe</code> functions even though it is very easy to write this natural transformation:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="ot">unExplain ::</span> <span class="dt">Either</span> err a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span></code></pre></div>
<p>Why is that? Why not just provide <code>Either</code> versions? Looking at <em>aeson</em> as an example:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="ot">decode ::</span> <span class="dt">FromJSON</span> a <span class="ot">=&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="ot">eitherDecode ::</span> <span class="dt">FromJSON</span> a <span class="ot">=&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> a </span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a><span class="ot">parseEither ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Parser</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> b </span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a><span class="ot">parseMaybe ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Parser</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b </span></code></pre></div>
<p>the name <code>decode</code> is suggestive of being the one commonly used.</p>
<p>Having <code>aeason</code> in the spotlight, I like this part of their <a href="https://hackage.haskell.org/package/aeson-1.5.5.1/docs/Data-Aeson-Types.html##v:parse" target="_blank">documentation</a>:</p>
<blockquote>
<p><em>The basic ways to signal a failed conversion are as follows:</em></p>
<ul>
<li><em>fail yields a custom error message: it is the recommended way of reporting a failure;</em></li>
<li><em>empty (or mzero) is uninformative: use it when the error is meant to be caught by some (&lt;|&gt;);</em></li>
</ul>
</blockquote>
<p>Overuse of <code>mzero</code> in parsing code is as bad as the overuse of <code>Maybe</code>.</p>
<h4 id="monadfail-and-maybe"><code>MonadFail</code> and <code>Maybe</code>:</h4>
<p>Number of packages try to be polymorphic and use <code>MonadFail</code> constraint to provide information about unexpected errors (e.g. <em>time</em>, <em>mongoDB</em>). Sadly <em>base</em> provides no standard way to retrieve this information. The <a href="https://gitlab.haskell.org/ghc/ghc/-/issues/12160" target="_blank">ticket</a> to add <code>Either String</code> instance is a no-go for now.</p>
<p>The packages which use <code>MonadFail</code> do not offer convenience <code>MonadFail</code> monads either. It seems wrong and asymmetric to force the caller to define their type for retrieving error information.</p>
<p>But <code>MonadFail</code> has <code>Maybe</code> instance! I strongly believe in <em>make writing good code easy, bad code hard</em> design principle. This is clearly violated here.</p>
<p>Also, notice this part of documentation (in <em>base</em> Control.Monad.Fail):</p>
<blockquote>
<p>If your Monad is also MonadPlus, a popular definition is</p>
<p><code>fail _ = mzero</code></p>
</blockquote>
<p><em>(quiet sob)</em></p>
<h3 id="cut-catmaybes">Cut <code>catMaybes</code></h3>
<p>Replacing</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="ot">catMaybes ::</span> [<span class="dt">Maybe</span> a] <span class="ot">-&gt;</span> [a]</span></code></pre></div>
<p>with</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="ot">partitionEithers ::</span> [<span class="dt">Either</span> e a] <span class="ot">-&gt;</span> ([e], [a])</span></code></pre></div>
<p>very often improves the robustness of code.</p>
<p>Consider <code>Contact</code> record type with <code>cEmail :: Maybe Email</code> field. We can get</p>
<ul>
<li>lists of emails by using <code>catMaybes</code></li>
<li>list of emails and the information which <code>Contact</code>-s do not have an email using <code>partitionEithers</code>.</li>
</ul>
<p>The <code>Contact</code> list could come from a parsed JSON and could contain a list of company employees or is a parsed mail-mime <em>CC:</em> header. Missing email should be rare.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Control.Arrow</span> ((&amp;&amp;&amp;))</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a><span class="co">-- maybe version</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a><span class="ot">getEmails ::</span> [<span class="dt">Contact</span>] <span class="ot">-&gt;</span> [<span class="dt">Email</span>]</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>getEmails <span class="ot">=</span> catMaybes <span class="op">.</span> <span class="fu">map</span> cEmail</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a><span class="co">-- either version</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">MissingData</span> a <span class="ot">=</span> <span class="dt">MissingEmailData</span> a <span class="op">|</span> <span class="op">...</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true"></a><span class="ot">getEmails' ::</span> [<span class="dt">Contact</span>] <span class="ot">-&gt;</span> ([<span class="dt">MissingData</span> <span class="dt">Contact</span>], [<span class="dt">Email</span>])</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true"></a>getEmails' <span class="ot">=</span> partitionEithers <span class="op">.</span> <span class="fu">map</span> (<span class="fu">uncurry</span> explain <span class="op">.</span> (<span class="dt">MissingEmailData</span> <span class="op">&amp;&amp;&amp;</span> cEmail))</span></code></pre></div>
<p>These are “it is rare, therefore can be ignored” vs “it is rare and therefore cannot be ignored” approaches.<br />
I do not know what is the proper name for software that does not handle corner cases. I call it <em>expensive</em> ;)<br />
I question the use of <code>catMaybes</code> every time I see it.</p>
<p>I try to be terse in the above example, but it is clear that <code>Either</code> is more work. Terseness and ease of programming are IMO some of the reasons for <code>Maybe</code> overuse.</p>
<h3 id="hkd-pattern">HKD pattern</h3>
<p>Higher-Kinded Data pattern is super cool and can be very useful. This post explains what it is: <a href="https://reasonablypolymorphic.com/blog/higher-kinded-data/" target="_blank">reasonablypolymorphic on HKD pattern</a>. My example follows <em>reasonablypolymorphic</em> blog closely.</p>
<p>In nutshell, we can create a record type like</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Person</span> f <span class="ot">=</span> <span class="dt">Person</span> { </span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a><span class="ot">    pName ::</span> f <span class="dt">String</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>  ,<span class="ot"> pAge  ::</span> f <span class="dt">Int</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>  <span class="co">-- imagine a lot more fields here</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a>  } </span></code></pre></div>
<p>parametrized by a type of kind <code>* -&gt; *</code> e.g. <code>Maybe</code> or <code>Identity</code>. All or some of the fields in that record type have an <code>f</code> in front of them.<br />
<em>HKD Patter</em> is about using generic programming to transform that record based on operations that work on the fields.<br />
For example, we can hoist <code>forall a . f a -&gt; g a</code> functions to <code>hkd f -&gt; hkd g</code> (here <code>Person f -&gt; Person g</code>).</p>
<p>Imagine that <code>Person</code> has a long list of fields and there is a web form for entering them.<br />
The post descibes a completely generic validation function that, when restricted to our <code>Person</code> type, looks like this:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="ot">validate ::</span> <span class="dt">Person</span> <span class="dt">Maybe</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Person</span> <span class="dt">Identity</span>)</span></code></pre></div>
<p>I hate when this is done to me: it took 5 minutes to enter the information, the submit button is grayed out, and I see no way to move forward. Typically, when that happens, it is caused by a JavaScript error.</p>
<p>In this example it is not a programming bug, it is a design decision: a very sophisticated way to check that user entered all fields that does not provide information about which fields they missed.<br />
Web form data entry aside, I challenge you to find one meaningful example where the above <code>validate</code> is useful. A one off data science code that processes massive amount of data and requires all fields to be present to be useful? All examples I can come up with seem far-fetched and still would benefit from having <code>Either</code>.</p>
<p>Questions I am asking:</p>
<ul>
<li>Would you expect a production code somewhere out there that validates user input using HKD pattern and actually uses <code>Maybe</code>?</li>
<li>Did <em>reasonablypolymorphic</em> confuse or simplify things by using <code>Maybe</code> in its example?</li>
</ul>
<p>In <em>reasonablypolymorphic</em> post <code>Maybe</code> is not just in the <code>validate</code> function. The post defines the whole <code>GValidate</code> boilerplate that assumes <code>Maybe</code>.</p>
<p>Fortunately, the approach can be generalized to other <code>f</code> types.<br />
A meaningful validation would have a type</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">FieldInfo</span> <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a><span class="ot">validate ::</span> <span class="dt">Person</span> <span class="dt">Maybe</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> [<span class="dt">FieldInfo</span>] (<span class="dt">Person</span> <span class="dt">Identity</span>)</span></code></pre></div>
<p>This is arguably more work to do and beyond what <em>HKD pattern</em> can offer. However, it is quite possible to do something like this generically:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">FieldInfo</span> <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a><span class="ot">validate ::</span> <span class="dt">Person</span> (<span class="dt">Either</span> <span class="dt">FieldInfo</span>) <span class="ot">-&gt;</span> <span class="dt">Either</span> [<span class="dt">FieldInfo</span>] (<span class="dt">Person</span> <span class="dt">Identity</span>)</span></code></pre></div>
<p>Check out the documentation for the <a href="https://hackage.haskell.org/package/barbies" target="_blank">barbies</a> package, it comes with exactly this example! Notice, some boilerplate work is still needed to annotate missing values with field information:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="ot">addFieldInfo ::</span>  <span class="dt">Person</span> <span class="dt">Maybe</span> <span class="ot">-&gt;</span> <span class="dt">Person</span> (<span class="dt">Either</span> <span class="dt">FieldInfo</span>) </span></code></pre></div>
<p><code>addFieldInfo</code> would need to happen outside of the <em>HKD pattern</em>.<br />
One can argue that a better solution would be not to use <code>Person Maybe</code> and convert user form data entry directly to <code>Person (Either FieldInfo)</code>.</p>
<h3 id="traversable-with-maybe"><code>Traversable</code> with <code>Maybe</code></h3>
<p><em>barbies</em> validation of <code>Person</code> required a traversal of the <em>HKD</em> type. So, maybe, we should consider a somewhat simpler design where fields are unified into one type. Keeping up with the <em>reasonablypolymorphic</em> example:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="ot">{-## LANGUAGE DeriveFunctor ##-}</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a><span class="ot">{-## LANGUAGE DeriveFoldable ##-}</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a><span class="ot">{-## LANGUAGE DeriveTraversable ##-}</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Person'</span> a <span class="ot">=</span> <span class="dt">Person'</span> { </span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a><span class="ot">    pName' ::</span> a</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true"></a>  ,<span class="ot"> pAge'  ::</span> a</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true"></a>  <span class="co">-- imagine a lot more fields here</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true"></a>  } <span class="kw">deriving</span> (<span class="op">...</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Traversable</span>)</span></code></pre></div>
<p>And “now we are cooking with gas”!</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">FieldData</span> <span class="ot">=</span> <span class="op">...</span> <span class="co">-- unifying type for Person' fields</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a><span class="ot">validateMaybe ::</span> <span class="dt">Person'</span> (<span class="dt">Maybe</span> <span class="dt">FieldData</span>) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Person'</span> <span class="dt">FieldData</span>)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a>validateMaybe <span class="ot">=</span> <span class="fu">traverse</span> <span class="fu">id</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a><span class="ot">validateEither ::</span> <span class="dt">Person'</span> (<span class="dt">Either</span> <span class="dt">FieldInfo</span> <span class="dt">FieldData</span>) <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">FieldInfo</span> (<span class="dt">Person'</span> <span class="dt">FieldData</span>)</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true"></a>validateEither <span class="ot">=</span> <span class="fu">traverse</span> <span class="fu">id</span></span></code></pre></div>
<p>New <code>validateEither</code> is not as good as the <em>barbies</em> version. It gives the user only one of the fields they missed.<br />
IMO <code>validateMaybe</code> is useless for any data entry form validation.</p>
<p>The <code>validateMaybe</code> example is here for a reason. It directly mimics the example discussed in <a href="https://www.michaelpj.com/blog/2021/01/02/elementary-programming.html" target="_blank">Elementary Programming</a>, which used</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="ot">mapMaybe ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [b]</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a>mapMaybe <span class="ot">=</span> <span class="fu">traverse</span></span></code></pre></div>
<p>as its only example.</p>
<p><code>Maybe</code> is viral.</p>
<h2 id="questioning-record-types-with-all-maybe-fields">Questioning Record Types with all <code>Maybe</code> Fields</h2>
<p>Besides being a natural fit for data coming from something like a web form, there are other reasons for designing record types with many <code>Maybe</code> fields.<br />
Here is my attempt at debunking some of them.</p>
<h3 id="recreating-java-beans-with-maybe">Recreating <em>Java Beans</em> with <code>Maybe</code> ;)</h3>
<p>Defining record types with many <code>Maybe</code> fields allows to construct such records easily if you care about only some of the fields.</p>
<p>This can be done via some <code>empty</code> defaulting mechanism (I will use the <code>Person</code> type defined above to serve as an example):</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="ot">emptyPerson ::</span> <span class="dt">Person</span> <span class="dt">Maybe</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a>emptyPerson <span class="ot">=</span> <span class="dt">Person</span> <span class="dt">Nothing</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>or with a use of <code>Monoid</code> and <code>mempty</code>. <code>emptyPerson</code> could be defined in a generic way as well (see <a href="https://hackage.haskell.org/package/hkd-default" target="_blank">hkd-default</a>).</p>
<p>Say, your code cares about <code>pAge</code> only, you can just set <code>pAge</code>:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="ot">isDrinkingAge ::</span> <span class="dt">Person</span> <span class="dt">Identity</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a>isDrinkingAge p <span class="ot">=</span> runIdentity (pAge p) <span class="op">&gt;=</span> <span class="dv">21</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a>test10YearOld <span class="ot">=</span> emptyPerson {pAge <span class="ot">=</span> <span class="dt">Identity</span> <span class="dv">10</span>}</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a>test <span class="ot">=</span> isDrinkinAge test10YearOld</span></code></pre></div>
<p>I do not like this approach. It feels like a poorly typed code.</p>
<p>It also reminds me of <code>null</code> and hence the <em>Java Bean</em> reference. (<a href="https://stackoverflow.com/questions/1612334/difference-between-dto-vo-pojo-javabeans" target="_blank">Java Bean</a> was a popular pattern in the Java ecosystem. A <em>Bean</em> needs to have an empty constructor, and a <em>setter</em> / <em>getter</em> method for each field. It seems very similar to a record type with lots of <code>Maybe</code> fields.)</p>
<p>An easy improvement would be to create <code>Age</code> type</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">Age</span> <span class="ot">=</span> <span class="dt">Age</span> <span class="dt">Int</span> </span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Person''</span> f <span class="ot">=</span> <span class="dt">Person''</span> { </span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a>  <span class="op">...</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a>  ,<span class="ot"> pAge''  ::</span> f <span class="dt">Age</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true"></a>  <span class="co">-- imagine a lot more fields here</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true"></a>  } </span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true"></a></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true"></a><span class="ot">isDrinkingAge' ::</span> <span class="dt">Age</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true"></a>isDrinkingAge' (<span class="dt">Age</span> a) <span class="ot">=</span> a <span class="op">&gt;=</span> <span class="dv">21</span></span></code></pre></div>
<p>If we feel strongly about checking age on the <code>Person</code> type, we can use Haskell’s ability to program with polymorphic fields:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="ot">{-## LANGUAGE TypeApplications ##-}</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a><span class="ot">{-## LANGUAGE DataKinds ##-}</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a><span class="ot">{-## LANGUAGE FlexibleContexts ##-}</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a><span class="ot">{-## LANGUAGE DuplicateRecordFields ##-}</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">GHC.Records</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true"></a><span class="ot">isDrinkingAge ::</span> <span class="dt">HasField</span> <span class="st">&quot;pAge&quot;</span> p (<span class="dt">Identity</span> <span class="dt">Int</span>) <span class="ot">=&gt;</span> p <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true"></a>isDrinkingAge p <span class="ot">=</span> runIdentity (getField <span class="op">@</span> <span class="st">&quot;pAge&quot;</span> p) <span class="op">&gt;=</span> <span class="dv">21</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true"></a></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">AgeTest</span> <span class="ot">=</span> <span class="dt">AgeTest</span> {<span class="ot"> pAge ::</span> <span class="dt">Identity</span> <span class="dt">Int</span>}</span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true"></a></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true"></a>test40YearOld <span class="ot">=</span> isDrinkingAge <span class="op">$</span> <span class="dt">AgeTest</span> (<span class="dt">Identity</span> <span class="dv">40</span>)</span></code></pre></div>
<p>IMO creating record types with lots of <code>Maybe</code> fields for the benefit of easy construction is not a good pattern.</p>
<h3 id="maybe-first-monoid-fields"><em>Maybe-First</em> <code>Monoid</code> fields</h3>
<p><code>Maybe (First _)</code> is a valid <code>Monoid</code>.<br />
Using Maybe-First semantics, <code>mappend</code> selects the first non-<code>Nothing</code> element. Appending can be implemented as:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Data.Semigroup</span> (<span class="dt">First</span> (..))</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a>a <span class="op">&lt;&gt;</span> b <span class="ot">=</span> <span class="fu">fmap</span> getFirst <span class="op">$</span> <span class="fu">fmap</span> <span class="dt">First</span> a <span class="op">&lt;&gt;</span> <span class="fu">fmap</span> <span class="dt">First</span> b</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a><span class="co">-- or in more &quot;elemenary&quot; way as:</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true"></a></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true"></a><span class="dt">Nothing</span> <span class="op">&lt;&gt;</span> b <span class="ot">=</span> b</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true"></a>a <span class="op">&lt;&gt;</span> <span class="dt">Nothing</span> <span class="ot">=</span> a</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true"></a>a <span class="op">&lt;&gt;</span> b <span class="ot">=</span> a</span></code></pre></div>
<p>You can use this approach on each field to define <code>Monoid</code> instances for large record types that consist of <code>Maybe</code> fields.<br />
This pattern provides a convenient defaulting mechanism and allows to set groups of fields at once using <code>mappend</code>.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a>overrides <span class="op">&lt;&gt;</span> record</span></code></pre></div>
<p>This approach can also result in very weird data combinations if one is not careful:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a>gd <span class="ot">=</span> (<span class="fu">mempty</span><span class="ot"> ::</span> <span class="dt">Person</span> <span class="dt">Maybe</span>) {pName <span class="ot">=</span> <span class="st">&quot;grandpa&quot;</span>} <span class="co">-- missing age</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a>baby <span class="ot">=</span> (<span class="fu">mempty</span><span class="ot"> ::</span> <span class="dt">Person</span> <span class="dt">Maybe</span>) {pName <span class="ot">=</span> <span class="dt">Just</span> <span class="st">&quot;baby&quot;</span>, pAge <span class="ot">=</span> <span class="dt">Just</span> <span class="dv">1</span>} </span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true"></a>grampatoddler <span class="ot">=</span> gd <span class="op">&lt;&gt;</span> baby <span class="co">-- it is easy to create surprising data</span></span></code></pre></div>
<p>The reverse: <code>First (Maybe _)</code> <code>Monoid</code> instance is far less convenient to use but is much less surprising.</p>
<p>I do not think that <code>Maybe-First</code> <code>Monoid</code> is necessarily bad. There is simply a trade-off between the conveniences it offers and its gotchas. I prefer designs that provide more safety over accidental bugs.</p>
<h2 id="alternative-typeclass"><code>Alternative</code> typeclass</h2>
<p><code>Alternaive</code> <code>(&lt;|&gt;)</code> is very convenient tool often used with parsers. It can be dangerous on its own merit. It can suppress error information in questionable ways if overused (I wrote a separate <a href="https://rpeszek.github.io/posts/2021-02-13-alternative.html" target="_blank">post</a> about it).</p>
<p>There is currently no <code>Alternative</code> instance for <code>Either err</code> but there is one for <code>Maybe</code>. This creates temptation to <code>unExplain</code> the <code>err</code> …</p>
<h2 id="good-uses-of-maybe">Good uses of Maybe</h2>
<p>I think the following old design principle (Postel’s law) is still valid (on the implementation side)</p>
<p><em>Lenient input, Strict Output</em>.</p>
<p>This means <code>Maybe</code> is great as input parameter, less so in the result. The above <em>Error Clarity Rule</em> should be the overriding factor here. If the call-site can disambiguate what <code>Nothing</code> is, then <code>Maybe</code> results are fine.</p>
<p>In particular, <em>prisms</em> are typically used on not nested coproducts, thus, the call-site can disambiguate at which level the pattern match failed. <code>lookup</code> in <code>Data.Map</code>, <code>find</code> for a <code>Foldabe</code> are all perfectly good choices for a <code>Maybe</code> result type.</p>
<h2 id="why-maybe-is-overused-possible-explanations">Why <code>Maybe</code> is Overused? Possible Explanations</h2>
<p>IMO these are the main causes of the overuse:</p>
<ol type="1">
<li><p>Using <code>Maybe</code> is simpler that <code>Either</code>. If doing the right thing takes more time and effort it will often not be done.</p></li>
<li><p>Coding with <code>Maybe</code> is terser. Thus, coding with <code>Maybe</code> may seem more elegant.</p></li>
<li><p><code>Maybe</code> is more expressive. Examples: <code>Alternative</code> instance; to use <code>Monad</code>, <code>Applicative</code> with <code>Either err</code> you need to unify on the <code>err</code> type which is extra work.</p></li>
<li><p>Sophisticated abstractions can obscure common sense. <code>Maybe</code> is likely to fit the abstraction more often and easier than <code>Either</code>.</p></li>
</ol>
<p>Oversimplifications are nothing new in mathematical modeling. Anyone who studied, for example, mathematical physics has seen a lot of crazy oversimplifications. Code design appears not that different.</p>
<ol start="5" type="1">
<li>Non production code. Lots of Haskell code is about CS research. Lots of Haskell code is pet projects. Such code does not need to be maintained in production. <code>Maybe</code> is good enough.</li>
</ol>
<p>If developer can disambiguate the reason for <code>Nothing</code>, then use of <code>Either</code> is optional. This is not an overuse case and is justified.</p>
<p>I started with link to <a href="https://www.michaelpj.com/blog/2021/01/02/elementary-programming.html" target="_blank">Elementary Programming</a> post and want to end with it. Would more explicit “elementary” programs help in spotting obvious things like error information loss? I think they could. Starting from requirements and going back to most elementary solution would probably never arrive at:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a><span class="ot">mapMaybe ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [b]</span></code></pre></div>
<p>if only the requirements cared about errors.<br />
I do not advocate avoiding abstractions, just do not forget errors on the way. Don’t throw the baby out with the bathwater.</p>
<p>I am sure I do not have a full understanding of why and how <code>Maybe</code> is overused. The intent of this post is to start a discussion.</p>
<p>Discussion links:</p>
<ul>
<li>github <a href="https://github.com/rpeszek/rpeszek.github.io/discussions" target="_blank">discussions</a></li>
<li><a href="https://www.reddit.com/r/haskell/comments/kyo4xk/maybe_considered_harmful/" target="_blank">reddit</a></li>
</ul>
<h2 id="more-links">More Links</h2>
<p>(Links and information added later, after the original post)</p>
<ul>
<li><p><a href="https://www.parsonsmatt.org/2018/11/03/trouble_with_typed_errors.html" target="_blank">The Trouble with Typed Errors</a> - My post is often read as “Use Either” (I would prefer just “Do not overuse Maybe”). Matt Parsons’s great article talks about problems with monolithic error types and more. Extensible error types is important topic worth its own github awesome page.</p></li>
<li><p><a href="https://haskellweekly.news/episode/35.html" target="_blank">Haskell Weekly Podcast</a> has discussed this post. Thank you so much!</p></li>
</ul>

    </section>
</article>

        </main>

        <footer>
             <span><a href="../atom.xml">Atom</a></span>
             <span><a href="../RSS.xml">RSS</a></span>
             <span>Site generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a></span>
        </footer>
    </body>
</html>
