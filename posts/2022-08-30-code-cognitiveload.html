<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Infrequent, Pragmatic, Lambda Blog - Cognitive Loads in Programming</title>
        <link rel="alternate" type="application/atom+xml" href="https://rpeszek.github.io/atom.xml" title="atom" />
        <link rel="alternate" type="application/rss+xml" href="https://rpeszek.github.io/RSS.xml" title="rss" />
        <!-- <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="atom"/>
        <link rel="alternate" type="application/rss+xml" href="/RSS.xml" title="rss"/> -->
        <link rel="stylesheet" href="../css/reset.css" />
        <link rel="stylesheet" href="../css/predefault.css" />
        <link rel="stylesheet" href="../css/default.css" />
         
        <link rel="stylesheet" href="../css/syntax.css" /> 
        
        
    </head>
    <body>
        <header>
            <div class="motto">
                <a href="../">hmm >>= oh!</a>
            </div>
            <div class="logo">
                <a href="../">Infrequent, Pragmatic, Lambda Blog</a>
            </div>
            <nav>
                <!-- <a href="/">Home</a> -->
                <a href="../thoughts.html">Semiserious</a>
                <a href="../about.html">About</a>
                <!-- <a href="/contact.html">Contact</a> -->
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>Cognitive Loads in Programming</h1>
            <article>
    <section class="header">
        Posted on August 30, 2022
        
        
          <br /> Last Modified on Aug 30, 2022
        
        
        
        <div class="info">Tags: <a title="All pages tagged 'patterns-of-erroneous-code'." href="../tags/patterns-of-erroneous-code.html">patterns-of-erroneous-code</a></div>
        
    </section>
    <section>

    </section>
    <section>
        <div class="toc"><div class="header">Table of Contents</div>
<ul>
<li><a href="#that-dreaded-yaml">That dreaded YAML</a></li>
<li><a href="#cognitive-psychology">Cognitive psychology</a></li>
<li><a href="#easy-vs-simple">Easy vs Simple</a></li>
<li><a href="#extraneous-loads-that-grow">Extraneous loads that grow</a></li>
<li><a href="#bugs-and-metacognition">Bugs and metacognition</a></li>
<li><a href="#extraneous-nature-of-abstraction">Extraneous nature of abstraction</a></li>
<li><a href="#germane-and-intrinsic-load-of-fp">Germane and intrinsic load of FP</a></li>
<li><a href="#post-summary">Post Summary</a></li>
<li><a href="#there-is-much-more-to-it">There is much more to it</a></li>
</ul>
</div>
<blockquote>
<blockquote>
<p>‚ÄÉ <em>‚ÄúMy brain hurts‚Äù, a quote from a code review</em></p>
</blockquote>
</blockquote>
<p><strong>DRAFT version:</strong> <em>This post is a work-in-progress. I am publishing it to solicit early feedback.</em></p>
<p>This long post presents programming in a different light than what is commonly considered. We will look at cognitive aspects of interacting with code.</p>
<p>We will examine cognitive effort that goes into the implementation and cognitive loads on these poor souls who need to work on that code later. We will consider the programming language, its libraries, and implemented programs as <em>instructional materials</em>. We will view the developer as both an <em>instructional designer</em> and a <em>learner</em>. We will think about bugs as cognitive overload and a missed learning opportunity. We will discuss the cognitive impact of abstractions, types, and programming principles.</p>
<p>Cognitive load of working with code is rarely considered in actual project work. We ask ‚ÄúHow long will it take?‚Äù (in fibonacci numbers, of course), we do not ask ‚ÄúHow will it impact the overall complexity?‚Äù.<br />
I had quite a few eye opening moments when thinking about these topics. This is the main reason I decided to write and share my thoughts. This post will be a high level rant discussing programming across the industry spectrum from JavaScript to Haskell. It is written as a set of loose notes about various cognitive aspects related to working with code. The main goals are to:</p>
<ul>
<li>show how considering <em>cognitive loads</em> in context of programming projects provides valuable insights</li>
<li>present some useful terminology for reasoning about code complexity.</li>
</ul>
<p>I will try to explain psychological terminology but this post assumes readers‚Äô (high level) familiarity with concepts of FP and OOP.</p>
<p>My pet peeve is identifying specific <a href="../tags/patterns-of-erroneous-code.html" target="_blank">patterns of erroneous code</a> and what could be causing them, there is a human factor and a technical part to these patterns.<br />
Mental processes involved in writing code are such a fascinating and broad subject. I am taking only a very narrow path through it.<br />
I am planning another high level post to discuss programming from a different but relevant angle, it will be about empirical and deductive aspects of working with code. I believe these 2 aspects impact our cognitive loads in interesting ways. So, this post will focus on cognitive challenges caused by code. The next post will focus more on the human aspect.</p>
<p>This post reflects on my personal observations accumulated over 27 years of professional programming work, augmented by a few years of academic teaching.<br />
I am not a psychologist, these are observations of a coder.</p>
<h2 id="that-dreaded-yaml">That dreaded YAML</h2>
<p>I am perusing thousands of lines in Infrastructure as Code (IAC) yaml files. I am looking at an already refactored and improved version. It is a lot of templated <em>YAML</em> of k8s configuration at my work. The underlying reason for the complexity is the PL itself<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. Did the refactor break things? Of course it did. Complexity has consequences. With some effort, the issues were fixed. This is how things are, there is nothing we can do about it. There isn‚Äôt?</p>
<p>I want to contrast <em>YAML</em> with a configuration language called <a href="https://dhall-lang.org/" target="_blank">Dhall</a> (one of my favorites). To use <em>Dhall</em> you may need to adjust to a Haskell-like syntax, maybe learn a few new concepts (like ADTs), think about configuration that uses lambda expressions. The return on the investment are Dhall safety features. Dhall even makes the process of refactoring safe, you can compare the previous configuration against the new and Dhall will tell you if both are equivalent or why not.</p>
<p><em>Dhall</em> and <em>YAML</em> come with very different cognitive challenges.</p>
<h2 id="cognitive-psychology">Cognitive psychology</h2>
<p>Cognitive load theory defines cognitive load as the amount of information that working memory holds at one time. The idea is that the human brain is limited in that capacity. Psychologists have identified the load to be about 3-5<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> ‚Äúunits of information‚Äù (also called ‚Äúchunks‚Äù). This space appears to be quite limited.<br />
I imagine the magic number is small in programming. However, I expect it to vary between individuals.<br />
If we can load only a limited number of ‚Äúchunks‚Äù into working memory, how big can these chunks be? The answer is interesting: it seems that it does not matter!<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a><br />
In some situations, the magic number appears to be 3 (the concept + 2 constituent chunks)<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>.<br />
Notice, it would be hard to enumerate chunks involved in a classic imperative program, but that number will be &gt;&gt; 5.</p>
<p>The idea of decomposing the program into fewer (but bigger) ‚Äúchunks‚Äù that interact in a clear way has been around for as long as I can remember. We will examine this idea in terms of <em>Cognitive Load Theory</em>.</p>
<p>Cognitive Load Theory is concerned with <em>instructional design</em> and improving how <em>information is presented</em> to a <em>learner</em>. Controlling the learner‚Äôs cognitive loads is an essential part of this work.</p>
<p>Continuous learning is a part of what programmers do, but implementing and modifying project code is by far the biggest cognitive effort that programmers face.<br />
I look at this as: the code itself is a very important <em>instructional material</em>, programmers are <em>learners</em> and <em>instructional designers</em> at the same time.<br />
Programs are where the <em>presentation of information</em> happens. The concepts and findings of cognitive load theory seem still relevant after this adjustment.</p>
<p>Cognitive psychology considers 3 types of cognitive load: <em>Intrinsic, Extraneous, Germane</em>. All are related to <em>information presentation</em> and we will think about them in the context of code.</p>
<ul>
<li><p><em>Intrinsic cognitive load</em> is the inherent level of difficulty associated with a specific (instructional) topic. Thinking about code, requirements are a good choice for a topic. A rough moral equivalent known to software developers is <em>essential complexity</em> (things are complex because they are, to reduce this load requirements would need to change).</p></li>
<li><p><em>Extraneous cognitive load</em> is generated by the manner in which information is presented to learners and is under the control of instructional designers. This term is often used to describe unnecessary (artificially induced) cognitive load. Thinking about code, a rough moral equivalent of high extraneous load is <em>accidental complexity</em><a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> (things are complex because the program made it so).</p></li>
<li><p>Germane cognitive load refers to the work that is put into constructing a long-lasting store of knowledge or schema. Schema is a pattern of thought or behavior that organizes categories of information and the relationships among them. Psychologists also use the term <em>‚Äúchunk‚Äù</em> and schema construction is the process of creating these chunks in memory.<br />
Thinking about code, this roughly translates to using <em>abstractions</em>, higher level concepts, types, programming principles. An <em>OO</em> programmer may try to define intuitive object hierarchies, employ design patterns to model the business domain. An FP-er may use denotational<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> approach, look at how things compose (think about categories), design DSLs, blue-print the design using types‚Ä¶</p></li>
</ul>
<blockquote>
<p>‚ÄÉ <em>Cognitive load theory thesis is about reducing extraneous cognitive load redirecting it towards germane load.</em></p>
</blockquote>
<p>Cognitive theory considers intrinsic load to be not movable, obviously requirements can be changed.</p>
<p>I need to emphasize that the <em>information presentation</em> under consideration facilitates understanding of the code itself and not so much the concepts (e.g.¬†abstractions) used to create it. Knowledge of these concepts is a prerequisite. Prerequisites are an important caveat and one that ends up being contentious.</p>
<p> <div class="side-note"><strong>Prerequisites:</strong> Working on a project code will reinforce knowledge of programming concepts (psychologists call something similar a <a href="https://en.wikipedia.org/wiki/Worked-example_effect" target="_blank">worked-example effect</a>) but, for a working programmer, learning new concepts ideally needs to happen outside of project work. In reality, there is no time for this. Also, available programming concepts are limited not only by what the developer and the team know, but also by what is supported by the PL (programming language). Developer backgrounds and what is supported in a PL vary a great deal. Thus, the list of prerequisites that can go into a programming project is limited.  </div></p>
<p>This sets the stage for what I want to discuss, but before continuing let me briefly review a <strong><em>few more relevant concepts.</em></strong></p>
<p><em>Cognitive overload</em> happens when working memory is overwhelmed by the 3 cognitive loads we have described, IMO, bugs are evidence of a cognitive overload.<br />
However, psychology is not a simple arithmetic, some programmers learn how to process large cognitive loads sequentially, a few chunks of information at the time and get good at it. However, high cognitive loads will overwhelm even the most diligent among us, There is even a trivial combinatorial complexity to this (does working memory go through a binomial number reloads?).</p>
<p>I wanted to use <em>cognitive debt</em> in the title, intending it as a pun on ‚Äútechnical debt‚Äù because I am interested in discussing negative impacts on the team‚Äôs ability to understand and reason about the code. However, this term turns out to have a clinical meaning and I decided against using it.<br />
<em>Cognitive debt</em> is a psychological term associated with <em>repetitive negative thinking (RNT)</em>. <em>Cognitive debt</em> and RNT are hypothesized to have some very negative health consequences that can lead to depression or even dementia. RNT is described as</p>
<blockquote>
<p>‚ÄÉ <em>‚Äúexcessive and repetitive thinking about current concerns, problems, past experiences or worries about the future‚Äù</em></p>
</blockquote>
<p>I do not claim to know a lot about clinical psychology but the definition clearly is very relevant to programmers and could partially explain why programmers are often unhappy<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>, or why programming discussion groups are often very negative.<br />
Sadly, RNT seems to be a condition that really good programmers are likely to experience. Good programmers think about rainy day scenarios, notice design flaws, can anticipate program issues‚Ä¶ My pet peeve, <a href="../tags/patterns-of-erroneous-code.html" target="_blank">patterns of erroneous code</a>, is an RNT. It seems important that we talk about RNT.</p>
<p>You may want to think about <em>working memory</em> and <em>cognitive loads</em> as something akin to <em>RAM</em> in a computer.<br />
What is the equivalent of a CPU cost? In this post I use <em>cognitive effort</em>, the usage of this term is not very consistent<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a> in the literature.</p>
<p>These were cliff notes written by a non expert. There are many tricky and relevant bits like <em>information retrieval from long term memory</em>. Things I am progressively less and less component to describe in psychological context.</p>
<h2 id="easy-vs-simple">Easy vs Simple</h2>
<p>If you have looked at my <a href="../tags/TypeScript-Notes.html" target="_blank">TypeScript types</a> series, you have seen me <a href="2022-03-13-ts-types-part6.html#about-simplicity" target="_blank">write about it already</a>. I do not claim that my definitions are the only correct way that these terms should be interpreted. However, I have seen other programmers use a similar disambiguation so I am including it here.</p>
<p>I consider the terms simple and easy to have a different meaning.<br />
Easy: A low barrier to entry (e.g.¬†easy programming concepts). Hard is the opposite of easy and implies a high learning curve.<br />
Simple: Low effort to <em>correctly</em> reason about (e.g.¬†code written using learned concepts). Complex is the opposite of simple (e.g.¬†code that is hard to understand). The term ‚Äúarbitrary complexity‚Äù fits this definition very well.</p>
<p>Easy means fewer prerequisites and implies low germane load, hard means many prerequisites.<br />
Simple means low extraneous load, complex means high extraneous load.</p>
<p>This differentiation could also be expressed as:</p>
<blockquote>
<p>‚ÄÉ <em>Easy means low cost of creation, simple means low cost of consumption</em></p>
</blockquote>
<p>except, in this post my interest is the cognitive effort only not the total cost<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a>.</p>
<p>Achieving <em>simplicity</em> on a larger project is not <em>easy</em>. Easy does not scale well. There appears to be no free lunch, cognitive load needs to be somewhere. My big preference is trying to achieve <em>hard and simple</em> rather than <em>easy and complex</em>. In other words, I prefer to spend my cognitive bandwidth on germane load over extraneous load. This, I am pleased to note, is aligned with cognitive psychology.</p>
<p>Recall the advice from cognitive psychologists is to reduce extraneous load redirecting it towards germane load. This translates to:</p>
<blockquote>
<p>‚ÄÉ <em>Move from complex to hard</em></p>
</blockquote>
<p>An interesting way to look at easy vs simple is to think about a creative process like writing a book. Easy to write is clearly very different from simple to read. In programming these two are bundled together, a program created by one developer needs to be consumed by another dev who needs to modify it or interact with it. The term ‚Äúreadable code‚Äù comes to mind. I consider it different from simple. E.g. readable code does not mean no subtle bugs. Message is readable if you know what it conveys, but what it conveys could be complex or even misleading.</p>
<p>IMO, the popularity of easy and the unpopularity of simple are a systemic problem in today‚Äôs programming and elsewhere.</p>
<p>Next section discusses examples of code which was intended to be easy and ended up complex.</p>
<h2 id="extraneous-loads-that-grow">Extraneous loads that grow</h2>
<p>What was the most complex code you‚Äôve worked on?<br />
I can think about a number of contenders, but my answer will be very unimpressive: I had to maintain a web page (just one page), it was implemented using Java Struts 1. This code used no advanced concepts, all ingredients were easy: control statements, instance variables, lots of protected methods with typically no arguments and void returns that read and set the instance variables.<br />
The Java class behind it had about 200 mutating instance variables. Changing the order of 2 lines in this code was almost guaranteed to create an (often intermittent) bug, it was hard to even make sure that variables were set before they were read.<br />
This code became infamous for its complexity very fast. Interestingly, Struts were blamed, not the needless overuse of mutable state.<br />
<em>I want you to channel your inner psychologist and answer this question: what is going to happen when a new functionality is added to a Java class with 200 instance variables? Right, I agree, we will have 201 instance variables.</em><br />
This piece of code was eventually refactored. If I remember correctly, about 12 instance variables were kept, they were actually needed by Struts.</p>
<p>This experience seems to me a good example of a big extraneous load, I had to deal with a load of 200 coupled ‚Äúchunks‚Äù.<br />
Let‚Äôs think about such code as an instructional material. I can attest, it was virtually impossible to even know what this code is supposed to do from looking at it.<br />
Ability to program using clear inputs and outputs (rather than void methods with no input parameters) requires a learning effort, I submit to you that this prerequisite is easier than the cognitive effort of maintaining such code.<br />
Thinking about this as instructional material, clear inputs and outputs are great learning objectives. You know the app if you understand its inputs and outputs.</p>
<p> <div class="side-note">Maintaining messy code can be stressful. Fortunately, projects like these become ‚Äúinfamous‚Äù very fast and you get moral support from other team members. That really helps. Be a source of such support for your teammates as well. Few words of encouragement and acknowledgment of the hardship go a long way. Also, the information will slowly percolate up and the management may become more receptive to accept the cost of a big refactor or even a complete rewrite. This is what happened in my Java Struts example.  </div></p>
<p>My second example is something that happened more recently. I worked on reimplementing a JS application. It was one of these apps that can be described as: <em>was easy to write, is hard to maintain or understand</em>. I am sure very few readers will be surprised by the existence of a hard to maintain JS application, but let‚Äôs put talking about this aspect aside. Is writing ‚Äúeasy‚Äù code the same as generating excessive cognitive load for the maintainers? I think it typically is, it is not that hard to incrementally develop a non penetrable maze. Maintaining some code structure to manage the cognitive load is not ‚Äúeasy‚Äù.<br />
The new version is still close to JS (it uses TypeScript and vanilla React) but tries to enforce these 3 principles: <a href="2022-03-13-ts-types-part6.html#referential-transparency-purity-and-explicit-types" target="_blank">referential transparency</a>, <a href="2022-03-13-ts-types-part6.html#about-clarity" target="_blank">clear, explicit</a> types that also <a href="2021-12-24-ts-types-part2.html#types-as-documentation" target="_blank">work as documentation</a>, and <em>async/await</em> abstraction to avoid callback hell.<br />
Referential transparency is an interesting dichotomy. Experiencing different results every time the code is executed typically causes surprise, in my experience developers rarely think about this during implementation. Thus, the code may feel weird and opinionated (e.g.¬†React components avoid using hooks) but it remains accessible.</p>
<blockquote>
<p>‚ÄÉ <em>IMO, high quality code shifts cognitive load from maintainer to implementer</em></p>
</blockquote>
<p>This works great even if both are the same person.<br />
Let‚Äôs consider the new JS app as an instructional material. Referential transparency creates learning objectives (inputs and outputs can be learned if outputs are predictable) while explicit types are an instructional material in itself (a blueprint). The biggest prerequisite for the implementers was knowledge about what to avoid.</p>
<p>Besides some common sense principles (feel free to add more), what else can we do to control extraneous load? Things are about to get more tricky.<br />
Human cognitive load is limited but we can do abstract reasoning. It is simpler for us to deal with a few generalized abstractions than with a multiplicity of concretes<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a>. And, as we know, abstractions are a better use of our working memory <em>chunk</em> space.<br />
This suggests exploring the space of programming abstractions. Unfortunately, programming abstractions are nontrivial. That makes them hard to learn, but what is worse is that developers and language designers sometimes (if not often) mess them up. Instead of decreasing, this increases (or even explodes) the cognitive load. We will explore this topic in <a href="#extraneous-nature-of-abstraction">Extraneous nature of abstraction</a>.</p>
<p>Types are, obviously, an important tool in controlling cognitive load. Types <em>offload</em> many code verification tasks from the developer. This is significant, developers can ignore a potentially high extraneous load of a program by trusting its type. As I already mentioned, types can be an <em>instructional material</em>, a blueprint. Using a type checker can, in itself, be an interactive learning process (e.g.¬†using REPL to ask type questions about the code).<br />
However, types are subject to similar limitations as abstractions: a learning curve, PL limitations, correctness issues (only, we call it <em>soundness</em> if types are involved).</p>
<p>Reducing cognitive load using abstractions and types is doable but requires navigating some tricky waters.</p>
<p> <div class="side-note"><strong>In a unicorn universe,</strong> projects are not allowed to exceed certain thresholds of cognitive load. When the threshold is reached abstractions that lower the load are identified, learned, and respectfully applied. If that is not possible, requirements are reexamined. Unicorn managers are automatically beatified. ü¶Ñ  </div></p>
<h2 id="bugs-and-metacognition">Bugs and metacognition</h2>
<p>Let‚Äôs define a bug as an unintended program defect. That removes all the temporary hacks from consideration. But it is the programmer‚Äôs job to figure these things out. A bug implies some issue in the mental process.</p>
<p>I consider cognitive overload to be the main cause of bugs. <em>Metacognition</em> is an important concept in cognitive psychology. It is about knowing strengths and weaknesses in our own cognitive process.<br />
I started analyzing and recording all defects I encounter at my work. My goal is to understand better what has caused and what could have prevented each issue. My records suggest that bugs <em>uncover</em> extraneous complexity. In other words, it is a good idea to ask this question: What is the underlying complexity that caused the developer to create this bug? The idea is to learn from bugs.<br />
Types, obviously, can be very helpful in bug prevention. Programmers who start using a PL with powerful types (e.g.¬†Idris, Haskell) experience this first hand: a lot of compilation errors, many uncovering an issue in the program. Notice, this is a very interactive process and an interactive learning experience in which developers can observe how and why they failed. Developers also observe what PL features prevent the bug from escaping.</p>
<blockquote>
<p>‚ÄÉ <em>Programming is an interactive process of finding and fixing bugs.<br />
‚ÄÉ IMO, programming should be an interactive process of identifying and resolving the underlying causes of bugs.</em></p>
</blockquote>
<p>‚ÄúInsanity is doing the same thing over and over and expecting different results‚Äù. I promise you 2 things: When you start analyzing bugs, you will start seeing patterns (similar to <a href="../tags/patterns-of-erroneous-code.html" target="_blank">patterns of erroneous code</a>). Unfortunately, you will likely have problems in communicating these patterns to developers who do not go through a similar process. I found that a code review session showing the same issue in a few places works better than trying to explain this without a concrete context (oops).</p>
<p>How about typos, trivial overlooks that are sometimes so hard to spot? That mysterious brain of ours is good at creating these. A great reading on this, in the context of (non-programming) typos, is <a href="https://www.wired.com/2014/08/wuwt-typos/" target="_blank">WUWT, Why It‚Äôs So Hard to Catch Your Own Typos</a>.<br />
Human brain has an ability to fill in gaps, self-correct things. Human brain is better at focusing on high level ideas and is perfectly happy skipping over minute details. This characteristic seems even stronger if we are on board with the big idea, and it seems fair to assume that programmers are on board with the features they are implementing. The main point is that our brain is not well designed to work at the level of statements and lexical tokens, it wants to work on big picture items.</p>
<p> <div class="side-note">Side note: This line of thought could also partially explain why programmers seem to be at home in the code they wrote even if other programmers consider it a complete mess. Sometimes just changing font or background color allows us to spot issues we have overlooked before. Our perception changes if what we interact with feels foreign (interestingly this should increase the cognitive load). It appears that some mental reset is sometimes needed.  </div></p>
<p>Error proneness of programming at the level of PL statements is also consistent with the cognitive load theory. At this level a programmer needs to consider a multitude of details, most likely overwhelming the working memory limits.<br />
An interesting piece of trivia is that Turing‚Äôs original paper (the one about universal machines and halting problem) had several bugs in it. <em>If Turing could not get it right, what chance do we have?</em><a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a></p>
<p>Static compilation can prevent a lot of trivial errors and hopefully the prevented list will grow, but that list is not exhaustive.</p>
<p><strong>Section Summary</strong></p>
<p>My first point is that programmers should start considering cognitive aspects when thinking about bugs.</p>
<p>What is that we do when we discover a bug? We write a test, right? Does this reduce the cognitive load? Of course it does not. IMO, it is more important to spend time on some intro- and retrospection and look for ways to lower the extraneous load or build some type safety. If that is not possible, improving test coverage becomes important. I want to learn from bugs. <em>Fixing bugs is the least important part of the process.</em> I should also mention that this is, unfortunately, a <em>repetitive negative thinking</em> territory.</p>
<p>Here is an example that keeps popping into my mind when thinking about trivial errors. I have seen many stack overflow errors in my life, I have seen only 2 or 3 since I moved to Haskell but they were not easy to find. They all were caused by Haskell allowing this lambda expression:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">let</span> blah <span class="ot">=</span> blah </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="kw">in</span> blah</span></code></pre></div>
<p>This to me is a good example of extraneous complexity that could be prevented by the compiler. Many PLs (e.g.¬†anything in ML groups like OCaml, Reason will not allow such code). Here is a relevant discussion on reddit: <a href="https://www.reddit.com/r/haskell/comments/lxnbrl/ghc_proposal_norecursivelet_prevent_accidental/" target="_blank">NoRecursiveLet</a>. Thinking about reducing extraneous load could impact such discussion (in this case, by supporting the proposal).</p>
<p>My second point is the recurring one, types and abstractions can play a big role in reducing bugs. Hopefully types and abstractions themselves are bug free!</p>
<p> <div class="side-note"><strong>There is an alien civilization</strong> of programmers who analyze their bugs, Alien PL designers consider these analyses to decide which features are in and which are out. Their PLs do not even have strings. You can do a lot of harm with just strings.  </div></p>
<h2 id="extraneous-nature-of-abstraction">Extraneous nature of abstraction</h2>
<p>Summary of previous sections: Our cognitive load is limited but we are capable of abstract reasoning and can work with big <em>chunks</em> of knowledge. Abstractions seem like our best hope in reducing the overall code complexity. But ‚Ä¶there are a few caveats.<br />
Programming abstractions are known for their germane load (for being <em>hard</em> to learn and for being less straightforward than imperative) but not so much for their extraneous nature (for being needlessly <em>complex</em>), the second aspect is much more interesting so let‚Äôs discuss it.</p>
<p><strong>Poorly implemented abstractions</strong></p>
<p>You spotted an intermittent malfunction in a code you maintain. Luckily, you see only one commit in recent history and you have a strong hunch something is wrong with that commit. Only some 50 code changes. The one that caused the issue is: <code>var1 == var2</code> changed to <code>var2 == var1</code>. Would you be able to spot it? I call this type of issue a ‚Äúgotcha‚Äù.<br />
How about: your <em>finder</em> function seems to be not finding stuff, only that sounds too far fetched, the function looks correct, so you just ignore this as a possible explanation. The underlying issue is that sometimes <code>x =! x</code> and you have used an equality check to find things.</p>
<p>I like to think about this paraphrasing Gimli:</p>
<blockquote>
<p>‚ÄÉ <em>‚ÄúComputation Laws are upon you, whether you would risk them or not.‚Äù</em></p>
</blockquote>
<p>Equality is an example of an abstraction developers implement and use, but not think much about. However, the list of surprising behaviors like these is quite long affecting all kinds of abstractions. Gochas create chaos in the cognitive process. Gotchas often become mystery bugs and are resolved using workarounds.<br />
For abstractions to work as a cognitive load reducer, they need to be treated seriously by the implementer.</p>
<p>Developers I talked to often responded to such examples by saying something like: ‚ÄúThis is just bad code, whoever implemented it should have been more careful‚Äù. Except, I can point to examples in standard libraries of popular mainstream PLs or popular frameworks<a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a>. The issues come with no deprecation warning and, if documented, are considered a ‚Äòfeature‚Äô.<br />
Are questions like ‚Äúdoes a developer have a fighting chance of troubleshooting this feature?‚Äù even being asked?</p>
<p><strong>Abstractions themselves causing cognitive issues</strong></p>
<p>OOP creates a very high cognitive load, to a point that even compiler writers mess it up all the time<a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a>. I started my programming career as an OOP enthusiast and evangelist. OO programming has an appeal of simplicity and I was seduced by it for many years. It took me a long time to realize that OOP is not simple at all. Let‚Äôs talk OOP a little. Pick random training. You will probably learn that <em>Cat</em> <em>is a</em>n <em>Animal</em> and that everything is intuitive.<br />
You will not learn if any of these less obvious are (or should be) true:<br />
‚ÄÉ function accepting a <em>Cat</em> <em>is a</em> function accepting an <em>Animal</em><br />
‚ÄÉ array of <em>Cats</em> <em>is a</em>n array of <em>Animals</em><a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a><br />
‚ÄÉ function with no parameters <em>is a</em> function with one parameter<a href="#fn15" class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a>.<br />
You will not learn about reduced type safety that comes with widening to a superclass<a href="#fn16" class="footnote-ref" id="fnref16" role="doc-noteref"><sup>16</sup></a>. I don‚Äôt even want to start on subtyping gotchas of variant (union and sum) types. OOP is approachable only because we hide the complex bits from the learners<a href="#fn17" class="footnote-ref" id="fnref17" role="doc-noteref"><sup>17</sup></a>. A relevant psychological concept is a cognitive bias called <em>framing effect</em>.</p>
<p>The concept of exception (i.e.¬†<code>throw</code> and <code>catch</code> game) is another example of a risky complexity that impacts even Haskell<a href="#fn18" class="footnote-ref" id="fnref18" role="doc-noteref"><sup>18</sup></a>.<br />
Types can reduce cognitive load of understanding the code, except exceptions provide a very accessible and virally used way to bypass the types. Other ‚Äúbottom‚Äù types like <code>null</code> are in the same boat. In my experience, many developers turn a blind eye on error handling in general. This seems akin to <em>omission neglect</em> (psychological concept loosely described by this popular phrase: out of sight out of mind) and some <em>optimism bias</em> (focus on sunny day scenarios only).<br />
I really like what Rust has done in this regard, you can <em>panic</em> but it is hard to recover if you do, otherwise errors are handled in an <code>Either</code>-like sum type called <code>Result</code>.<br />
Hopefully we will see more of this pragmatic approach in future PLs.</p>
<p>You may notice that the examples of <em>gotchas</em> I am coming up with have something in common. These issues can be classified under: <em>not trustworthy types</em>. Misleading types will confuse any developer, that includes developers who work in dynamically typed languages and may not think about types explicitly.<br />
<em>We think in types more than we realize.</em></p>
<p>Are there any ‚Äúgotcha‚Äù free environments? Haskell comes close but is not perfect<a href="#fn19" class="footnote-ref" id="fnref19" role="doc-noteref"><sup>19</sup></a>. Proof assistants like Idris come to mind, you get very sound abstractions, and these can even verify totality. That is kinda interesting, let‚Äôs pause for a bit here‚Ä¶ Consider the levels of abstraction used in proof assistants. It appears that our brain needs something at the level of a dependently typed lambda calculus to work correctly<a href="#fn20" class="footnote-ref" id="fnref20" role="doc-noteref"><sup>20</sup></a>. That could make sense, for things to be logical you need, well you need the logic itself. Proof assistants are not ‚Äúgotcha‚Äù free though, they have different types of gotchas<a href="#fn21" class="footnote-ref" id="fnref21" role="doc-noteref"><sup>21</sup></a>.</p>
<p><strong>Wrong abstraction for the job</strong></p>
<p>Let‚Äôs talk about data structures a bit. The choice you make can impact extraneous complexity a great deal. An example which emphasizes this is <a href="https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type" target="_blank">CRDT</a>.<br />
Imagine that you are working on an app where 2 or more agents (human or not) can concurrently work on some list and your program needs to merge their work. Using a standard <em>list type</em> will be a cognitive nightmare, right? Think about one agent (R) removing items, another agent (A) adding items. How do you know if an item was removed by (R) or (A) just added it? So what do you do? You introduce some distributed locking mechanism? ‚Ä¶Things are becoming complex very fast.<br />
The choice of which data structure is used can have a big impact on extraneous complexity. This extends to other abstractions as well.</p>
<p><strong>High levels of abstraction, an extraneous aspect</strong></p>
<p>I have seen very abstract code where the abstraction was like trees preventing developers from noticing a forest. One source of such examples is error handling. Mathematics rarely concerns itself with error messages, falsehood is falsehood. I have blogged about it in my posts about <a href="2021-01-17-maybe-overuse.html" target="_blank">Maybe Overuse</a> and <a href="2021-02-13-alternative.html" target="_blank">Alternative and errors</a>.</p>
<p> <div class="side-note">Side note: Probably not surprisingly, these were rather negatively received, heavily downvoted posts. The topic itself is very much a <em>repetitive negative thinking</em>. Incidentally, the negative comments mostly belonged in the general ‚Äúwhat you are describing is just bad code, whoever wrote it should have been more careful‚Äù category. I want to understand how code abstractions could promote erroneous code, my interest is in what makes people not careful.<br />
 </div></p>
<p>Let‚Äôs focus on Haskell. One simple to explain and not very abstract example that still fits into this section is the <code>guard</code><a href="#fn22" class="footnote-ref" id="fnref22" role="doc-noteref"><sup>22</sup></a> combinator. I see it used and I also scratch my head when, say, a JSON parser error says only <code>"mempty"</code>. Possibly, some programmers think about the abstraction called <code>Alternative</code> when they should be thinking about something like <code>MonadFail</code>, an abstraction that allows to specify error messages.<br />
Abstractions seem to come with what psychologists call a <em>commitment bias</em> (hey, I am doing <code>MonadPlus</code> damn it!).<br />
It is us, not the tooling, Haskell ecosystem offers a very expressive variety of abstractions. E.g. consider the error handling blind spot we talked about earlier. You can think about <code>Either</code> as a <code>Bifunctor</code> or an <code>ArrowChoice</code> argument, what typically gets our attention is its throw and forget <code>Monad</code> semantics.<br />
Some of us really dig abstractions and are arguably very good at them. But we are kidding ourselves if we do not acknowledge that abstractions can also blind us.<br />
IMO the one thing we can do about it is to be aware. More diligence + awareness is typically all it takes.</p>
<p><strong>Section Summary</strong><br />
Some developers react to gotchas with something akin to <em>omission neglect</em>, while other developers appear to create a mental store of gotchas and their potential impacts. I am in the second group. Maintaining this store is not necessarily easy. I will also note a possible relationship to <em>repetitive negative thinking</em>.</p>
<p>Gotchas presented to us (thank you very much) by language designers or library implementers should technically be classified as <em>intrinsic</em> since a common bloke like me can‚Äôt do much about them other than look for a job that has a better tooling. If you look at programming as a whole, these are extraneous loads.</p>
<p>I have left the subject of abstraction vs imperative (abstractions being less straightforward and harder to map to actual execution) untouched. I plan to return to this and to the topic of gotchas in my next post.</p>
<p> <div class="side-note"><strong>There is a planet</strong> where PL designers treat all programming abstractions and types with respect. Only sound, correctly implemented abstractions are used.<br />
As a result, this planet has only unpopular languages, their TIOBE index starts at number 100. üå†  </div></p>
<h2 id="germane-and-intrinsic-load-of-fp">Germane and intrinsic load of FP</h2>
<p>I expect that nothing in this section will be surprising to a functional programmer, but FP has such a unique cognitive impact that it is hard for me to not talk about.</p>
<p>Functional Programming allows us to understand computations in ways that are not possible without FP. Understanding is a big cognitive simplifier<a href="#fn23" class="footnote-ref" id="fnref23" role="doc-noteref"><sup>23</sup></a>. We are more at home with things we understand than with things we just know. Realizing that computations is something I can actually study to understand has been a game changer for me as a programmer.</p>
<p>Consider the following (middle-school?) formulas and how they relate to programming:</p>
<blockquote>
<p><span class="math inline"><em>a</em><sup>(<em>b</em>‚ÄÖ+‚ÄÖ<em>c</em>)</sup>‚ÄÑ=‚ÄÑ<em>a</em><sup><em>b</em></sup>‚ÄÖ*‚ÄÖ<em>a</em><sup><em>c</em></sup></span><br />
<span class="math inline"><em>a</em><sup>(<em>b</em>‚ÄÖ*‚ÄÖ<em>c</em>)</sup>‚ÄÑ=‚ÄÑ(<em>a</em><sup><em>b</em></sup>)<sup><em>c</em></sup></span></p>
</blockquote>
<p>These, pattern match and currying formulas, suggest that computations relate to other things we already know in ways that are almost surprising<a href="#fn24" class="footnote-ref" id="fnref24" role="doc-noteref"><sup>24</sup></a>.<br />
From the cognitive load theory point of view, an ability to map to existing knowledge needs to be viewed as a big plus (and a missed opportunity in how we learn programming).</p>
<p>FP is hard and there are 2 reasons why. One: it is simply hard (has a decent surface area but is also deep), two: it is different.</p>
<p>I was learning FP while working as a Java / Groovy developer. It took me 8 years, I estimated about 7000 hours. This effort included Category Theory, Types (my main interest), PLT, and programming in a bunch of FP languages. This has been, obviously, a big personal investment. And, I still had to internalize a lot of this when I started my actual Haskell job. Please do not interpret these stats as an argument that FP cannot be learned incrementally, or that learning FP does not provide immediate benefits. I am including these personal stats as evidence of an overall effort but also as evidence of the multitude of learning opportunities. We should resist thinking about knowledge as a binary checkbox.</p>
<p>FP requires a shift in how developers think. This shift is especially hard if the developer can only practice imperative skills at work. The tools we use impact our cognitive function.</p>
<blockquote>
<p>‚ÄÉ ‚ÄúIt is not only the violin that shapes the violinist, we are all shaped by the tools we train ourselves to use, and in this respect programming languages have a devious influence: they shape our thinking habits.‚Äù</p>
</blockquote>
<p>The quote is from <a href="https://chrisdone.com/posts/dijkstra-haskell-java/" target="_blank">Dijkstra letter to The University of Texas</a> protesting their Haskell -&gt; Java curriculum change. If you are into technical sports, you may have heard the term ‚Äúmuscle memory‚Äù. It is often harder to unlearn or adjust a body movement than learn a new one from scratch. It is even harder to ‚Äúown‚Äù the old movement and the new movement at the same time. Psychologists also believe that unlearning is hard<a href="#fn25" class="footnote-ref" id="fnref25" role="doc-noteref"><sup>25</sup></a>.<br />
The required mental shift for FP is the source of all kinds of additional problems. It can form a communication barrier, it can divide the community and teams.<br />
At the same time, this cognitive shift is an opportunity to understand programs in a different way.</p>
<p>I will dig my hole a little deeper. This one line of code made a huge impact on me (it is called the <em>Free Monad</em> and is in Haskell<a href="#fn26" class="footnote-ref" id="fnref26" role="doc-noteref"><sup>26</sup></a>):</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Free</span> f a <span class="ot">=</span> <span class="dt">MkFree</span> (f (<span class="dt">Free</span> f a)) <span class="op">|</span> <span class="dt">Pure</span> a </span></code></pre></div>
<p>I decided to dedicate a full summer to learning this line and it ended up taking longer than that. There is actually quite a bit to learn and <em>understand</em> here!<br />
For example, how does it relate to this line (looks very similar, just replace <code>Free</code> with <code>Fix</code> and drop one constructor):</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">Fix</span> f a <span class="ot">=</span> <span class="dt">MkFix</span> (f (<span class="dt">Fix</span> f a))</span></code></pre></div>
<p>Or, how is this a monad? Does it satisfy monad laws? What does <em>free</em> mean? Can other things than monads be <em>free</em>? Can <code>Free</code>-s with different <code>f</code>-s be combined? If so, are there easier and harder ways of combining them? What is <em>freer</em>? How do I program with it? How does it (and should it) relate to <code>try-catch</code> games? And finally, what libraries implement and use <code>Free</code>? The point I am trying to make is that FP computations are a different breed. They actually have properties and the learner can build an understanding of these properties.<br />
Effect systems (the main application of <code>Free</code>) are a very powerful programming tool, they can add a lot of structure and cognitive simplicity<a href="#fn27" class="footnote-ref" id="fnref27" role="doc-noteref"><sup>27</sup></a>. I use 2 of them at work, one of them we maintain. Effect systems allow us to organize code into DSLs and interpreters. This approach creates a very high level of code reuse, testability, and defines very explicit, self-documenting types.<br />
Now, is it realistic to learn these concepts in a day or a week when starting a new project? Imagine a programmer who uses Java at work exploring this knowledge.</p>
<p>There has been some discussion about making Haskell itself more accessible (e.g.¬†<a href="https://www.michaelpj.com/blog/2021/01/02/elementary-programming.html" target="_blank">Elementary Programming</a>) and some library effort in this direction as well (e.g.¬†<a href="https://github.com/digitallyinduced/ihp" target="_blank">IHP</a>).<br />
Some teams separate <em>hard</em> micro services with high levels of abstraction from the rest.<br />
Some places separate a possibly very advanced implementation from a simple to use API (I believe Facebook‚Äôs Haxl does it). Creating a progression from easy to hard is less trivial.</p>
<p>FP is a niche, I think FP has a stable niche in programming. Correctness and understanding of computations are problems almost nobody in the industry cares about but they are sometimes needed. This reminds me of a Terry Pratchett Diskworld character: Esmerelda (Granny) Weatherwax</p>
<blockquote>
<p>‚ÄÉ <em>‚ÄúEsme Weatherwax hadn‚Äôt done nice. She‚Äôd done what was needed.‚Äù</em></p>
</blockquote>
<p>Wanted means popular, needed means stable. However, basic principles of FP will probably find a wider use (as discussed in <a href="#extraneous-loads-that-grow">Extraneous loads that grow</a>).<br />
I plan to return to discussion of cognitive aspects of FP in my next post.</p>
<p> <div class="side-note"><strong>In a parallel dimension</strong> Alonso Church did not take a temporary break from lambda calculus and showed it to his student, Alan Turning. The first computer hardware was based on SKI calculus. In that dimension kids learn mathematics with proofs, imperative programming is considered a great addition after programmers learn the principles. In that dimension software has very few bugs, however, this universe has fewer programs, even fewer programmers, and the error messages suck. üåå  </div></p>
<h2 id="post-summary">Post Summary</h2>
<p>My readers may get the impression that this post is a criticism of imperative programming. Applying cognitive load theory to programming does not translate to ‚Äúimperative is complex‚Äù, rather it translates to ‚Äútoo much of imperative in one place (logically coupled) is complex‚Äù. IMO, some amount of imperative is often helpful.<br />
I plan to return to this topic in my next blog.</p>
<p>I am sure you have noticed that I think a lot about code complexity. And, yes, I do not feel comfortable working in messy code. Assessing and controlling the level of code complexity is crucial to me.</p>
<p>It has dawned on me that my dislike of code complexity may not be shared by others. <em>False consensus effect</em> is assuming that everyone else thinks like me.<br />
I remain convinced that some programmers react negatively to code complexity, but now I think that many programmers feel at home in code with a high cognitive load. This motivated me to work on this and the next post. IMO it is important that we try to understand each other a little better.</p>
<p>Are we doing a good job in managing code complexity? I think this a fair question to ask even if you think that simplicity is not crucially important. This post has argued that we are mostly failing on that front. In this post, we looked at how project complexity grows unnoticed, how bugs are a missed opportunity to learn about how we fail, and how FP changes the cognitive process but can be hard to learn. As a whole this post has been a bit of <em>repetitive negative thinking</em>, but I hope you found some positives and useful ideas in it as well. The main point of this post was to advocate for including cognitive aspects of programming projects into consideration and to present some useful terminology for doing it.</p>
<h2 id="there-is-much-more-to-it">There is much more to it</h2>
<p>This post took a very narrow path through the very broad subject of cognitive aspects of programming.</p>
<p>These were observations of a programmer, this post does not try to cover research on this topic or provide a good list of reading materials. I do not feel qualified to provide either. This topic is also related to code quality and this has been vastly discussed.</p>
<p>My focus was coding rather than process. I did not discuss things like cognitive loads in pool requests, cognitive considerations during sprint planning, git hygiene, etc.</p>
<p>Size of program files is an obvious, related topic I did not discuss.</p>
<p>Monorepo vs single projects has interesting relevance. Dependency graphs of or sorts (version, library deps) are a similar interesting topic.</p>
<p>Coding efficiency and the 10X programmer in the context of cognitive loads is an interesting (but contentious) topic.</p>
<p>Low Code: The idea of distributing cognitive load across different components is not new. The terms ‚Äúdecoupling‚Äù or ‚Äúisolation of concerns‚Äù are in this space. Low code is an idea of a very lopsided distribution in which most of the complexity falls onto the infrastructure. I started writing about it but decided to remove my notes as this post feels already too long.</p>
<p>Some PLs (Haskell is a good example of this) suffer from what some people call the <em>Lisp curse</em>. Instead of using established libraries, proprietary or one-off tools are often created. It is interesting why this happens and what to do about it. Could love of abstractions be causing it (reuse abstractions, not a code)? Is writing it from scratch a lower cognitive effort than learning and applying an existing solution? The end result, obviously, increases the cognitive load.</p>
<p>Cognitive load should be viewed as a resource problem, one that does not scale very well, and one that is not well understood. Cognitive load is greatly impacted by turn over rates, switching of code ownership, and by installed processes. Context switching is very expensive, the programmer‚Äôs inability to find contiguous blocks of time to focus could be viewed as an indication of an under-resourced project.</p>
<p>Linting, formatting, aesthetics are all very interesting cognitive load topics. Most programmers seem to be very sensitive to how the code is presented, (e.g.¬†would you ever use a light background in your code editor?). Similarly, syntax vs semantics, it seems syntax has a huge cognitive role even if we think about it as bikeshed.</p>
<p>Habit formation and unlearning are a big and very interesting topic.</p>
<p>Cognitive biases in the context of coding seem like very interesting topics too. In particular <em>bandwagon effect</em> (TypeScript is popular and hence must be very good), <em>framing effect</em> (new cool technology), <em>commitment bias</em> (we done it like this before, it has been tried and tested), <em>functional fixedness</em> (we do not need another PL), <em>omission neglect</em> (things we do not know are not important), <em>groupthink</em> (we want to work with people who think like us), <em>bikeshedding</em> (possibly most of this post üôÇ).</p>
<p>Point-free code, I stayed away from discussing it.</p>
<p>Cognitive aspects of troubleshooting are something I only touched on.</p>
<p>Imperative vs denotative is something I only touched on.</p>
<p>One topic I do plan to discuss (in the next post) is a distinction between empirical and formal processes in programming and how it impacts cognitive loads and acts as a divider.</p>
<p>Cognitive loads are related to stress, I intend to return to this topic in the future as well.</p>
<p>This post did not run out of topics, rather I have run out of steam. I hope I gave you things to think about. Thank you for reading!</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>E.g. see <a href="https://solutionspace.blog/2021/12/04/every-simple-language-will-eventually-end-up-turing-complete/" target="_blank">Every Simple Language Will Eventually End Up Turing Complete</a><a href="#fnref1" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn2" role="doc-endnote"><p>Corrected from 7 to 3-5 based on feedback from <a href="https://www.reddit.com/r/haskell/comments/x2du9d/comment/imjc87f/?utm_source=share&amp;utm_medium=web2x&amp;context=3" target="_blank">u/Fereydoon37</a>. The number 7 came from earlier studies which have been observing higher levels of ‚Äúchunkability‚Äù, 3-5 seems more relevant. I have also removed my use of technical sports as an analogy (motor skills seem not very relevant to our discussion).<a href="#fnref2" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn3" role="doc-endnote"><p>See this wiki page: <a href="https://psychology.fandom.com/wiki/Chunking" target="_blank">Chunking</a>. For me, thinking about a big chunk without a context, e.g.¬†<em>OOP</em> or <em>Geometry</em> triggers some high level information plus a seemingly random example, thinking more causes my brain to wander down some path. ‚ÄúTell me everything you know about ‚Ä¶‚Äù is not something I am capable of. So I do not think we load a whole huge chunk into working memory, but we can operate using chunks of seemingly unlimited size.<a href="#fnref3" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn4" role="doc-endnote"><p>Examples of concepts in programming that come with 2 chunks: assignment statement, function (input and output), function application (function and input), function composition. This pattern allows for very big chunks, here are examples with 2 big chunks I have worked a lot with in the past: algebraic topology, compensated compactness (using measure theory to study PDEs). Moving closer to programming, good big chunk examples are: computation laws, computation properties, operational semantics rules, Curry-Howard correspondence. Mathematical theorems mostly follow this pattern (e.g.¬†in the context of programming ‚ÄúSimply typed lambda calculus is strongly normalizing‚Äù). A candy: ‚ÄúDhall is strongly normalizing‚Äù.<br />
It appears that we can, indeed, do great things focusing on 2 chunks, However, I have not found much psychological research on 3 being the magic number.<a href="#fnref4" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn5" role="doc-endnote"><p>Terms <em>accidental</em> and <em>essential complexity</em> come from <a href="https://en.wikipedia.org/wiki/No_Silver_Bullet" target="_blank">No Silver Bullet</a> paper.<a href="#fnref5" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn6" role="doc-endnote"><p>Denotational approach means mapping requirements to mathematical concepts such as monoids, identifying categorical structures (things that compose), etc.<a href="#fnref6" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn7" role="doc-endnote"><p>Interesting youtube: <a href="youtube.com/watch?v=NdA6aQR-s4U" target="_blank">Why Do So Many Programmers Lose Hope?</a><a href="#fnref7" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn8" role="doc-endnote"><p>See the discussion in <a href="https://www.researchgate.net/publication/220963754_A_Computational_Analysis_of_Cognitive_Effort" target="_blank">A Computational Analysis of Cognitive EÔ¨Äort</a>. The term <em>cognitive cost</em> is typically used to mean a negative impact on a cognitive function induced by stress and the usage is also not very consistent, I am avoiding its use.<a href="#fnref8" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn9" role="doc-endnote"><p>Note that these terms imply some context. E.g. <em>simple to reason about correctness</em> could be very different from <em>simple to reason about performance</em>. The most popular context is ‚Äúthis code needs to work‚Äù with a somewhat relaxed definition of what ‚Äúworks‚Äù means, typically implying a reasonable level of correctness. This was pointed out to me in the conversation with <a href="https://discourse.haskell.org/t/cognitive-loads-in-programming/4994/12?u=rpeszek" target="_blank">hasufell in Haskell discourse</a><a href="#fnref9" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn10" role="doc-endnote"><p>As a side note, concrete thinking is not always bad. An interesting article on this in a broader context: <a href="https://www.healthline.com/health/concrete-thinking" target="_blank">Concrete Thinking: Building Block, Stumbling Block, or Both?</a>.<a href="#fnref10" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn11" role="doc-endnote"><p>‚ÄúIf Turing could not get it right, what chance do we have?‚Äù- is a phrase I remember from a Dana Scott lecture.<br />
The bugs were only discovered during the actual implementation work (see <a href="https://blog.wolframalpha.com/2010/06/23/happy-birthday-alan-turing/" target="_blank">Alan Turing</a>). Church‚Äôs <a href="https://plato.stanford.edu/entries/church/supplementA.html" target="_blank">take on undecidability</a> followed shortly after Turing‚Äôs. As far as I know nobody found any issues with it (even if untyped lambda calculus is rather unruly and the topic itself was hotly debated).<a href="#fnref11" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn12" role="doc-endnote"><p>Example of non-symmetric equals is <code>java.sql.Timestamp</code> used with <code>java.sql.Date</code> or <code>java.util.Date</code>, these remain used as standard JDBC mappings for DB columns, the usage will show no deprecation warning. <code>[] !== []</code> and <code>[] != []</code> in JS (incidentally <code>[] == ""</code>), working in JS often feels like explosives engineering.<br />
I wrote a blog series about <a href="../tags/TypeScript-Notes.html" target="_blank">TypeScript Types</a> and ended up presenting a lot of complexities and gotchas that probably surprise any TS developer.<br />
How do Hibernate users prevent this <a href="http://rpeszek.blogspot.com/2014/08/i-dont-like-hibernategrails-part-2.html" target="_blank">concurrency issue</a>?<br />
I remember Grails as a land mine of issues, I wrote an 11 part <a href="http://rpeszek.blogspot.com/2014/10/i-dont-like-hibernategrails-part-11_31.html" target="_blank">blog series</a> about it back in 2014.<br />
Java Streams have a very interesting take on referential transparency: if you execute a stream twice the second attempt will fail. This is probably the first and only attempt at dynamically typed linear types üôÇ and is bound to create interesting intermittent issues.<a href="#fnref12" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn13" role="doc-endnote"><p>‚Äúeven compiler writers mess it up all the time‚Äù is a quote from (<a href="https://doc.rust-lang.org/nomicon/subtyping.html" target="_blank">Rust Subtyping Documentation</a>)<a href="#fnref13" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn14" role="doc-endnote"><p>Keeping things easy, arrays are mutable. Sadly, you can explore the answer on your own by asking a mainstream compiler like Java or TS and the answer will, unfortunately, be the incorrect <em>yes</em>.<a href="#fnref14" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn15" role="doc-endnote"><p>In TS and JS the answer is yes. In TS this is a subtyping rule.<a href="#fnref15" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn16" role="doc-endnote"><p>This is a gotcha generator especially in OOP languages that have some level of type inference. E.g. here are some gotchas in <a href="2021-12-12-ts-types-part1.html#compilation-bloopers" target="_blank">TS</a> that involve widening to <code>unknown</code> which is a top type in TS, here is a discussion about these in <a href="http://rpeszek.blogspot.com/2017/07/scala-whats-wrong-with-you_29.html" target="_blank">Scala</a>.<a href="#fnref16" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn17" role="doc-endnote"><p>For example, it is hard to imagine that the unsound implementation of variance in a PL like TS was accidental. It must have been a decision to keep things easy.<a href="#fnref17" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn18" role="doc-endnote"><p>I sometimes see this argument ‚ÄúIt is impossible to statically reason about termination in a Turing complete PL, thus, all hope is lost‚Äù. Firstly, this is inaccurate: it is possible to statically verify totality on a subset of programs. Secondly: if non-termination is like accidentally hurting your foot, then exception is like shooting yourself in the foot. A missing DB record should, IMO, rarely be treated as non-termination. (I use the terms <em>total</em>, <em>terminating</em> and <em>partial</em>, <em>non_terminating</em> interchangeably.)<a href="#fnref18" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn19" role="doc-endnote"><p>Haskell dedicates a significant effort to soundness. E.g. see <a href="https://www.youtube.com/watch?v=hIZxTQP1ifo">Type Classes vs.¬†the World</a>. Not everything is perfect however. Haskell allows for easy to abuse error non-termination (e.g.¬†<code>error</code>, <code>undefined</code> functions), however ability to <code>catch</code> is more limited than in most PLs. Non-termination in itself throws a wrench, one Haskell should not be blamed for, see <a href="http://math.andrej.com/2016/08/06/hask-is-not-a-category/">Hask is not a category</a> and <a href="http://blog.sigfpe.com/2009/10/what-category-do-haskell-types-and.html">What Category do Haskell Types and Functions Live In</a>. Overall Haskell language comes with much fewer surprises if compared to the mainstream.<br />
The Haskell ecosystem (including its standard library) are more lax than the language itself. Michael Snoyman‚Äôs <a href="https://www.snoyman.com/blog/2020/10/haskell-bad-parts-1/" target="_blank">Haskell Bad Parts</a> is a great series on this topic. The most recent surprise for me is how <em>Aeson</em> (the most popular Haskell library for dealing with JSON) <a href="https://github.com/haskell/aeson/issues/961" target="_blank">generic instances work</a>.<a href="#fnref19" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn20" role="doc-endnote"><p><em>Standard ML</em> is known for its soundness, I do not know <em>ML</em> family that well, but I do know it has exceptions and <code>throw/catch</code> (in this case <code>raise/handle</code>) games. Possibly a more accurate point here is that we need strict formal semantics, it does not need to be dependently typed.<a href="#fnref20" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn21" role="doc-endnote"><p>Languages like Idris push the limits of what a compiler can do. I have experienced compiler hanging, compilation error messages overflowing my terminal buffer‚Ä¶ (the second happened to me in Haskell too but the scenario warranted it more). These issues happen if you start doing certain type level things (I was just trying to implement a block chain on the type level üôÇ).<a href="#fnref21" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn22" role="doc-endnote"><p>For readers not familiar with Haskell, <code>guard</code> allows to reject a computation based on a boolean expression. It is defined using a very general concept of <code>Alternative</code> and at this level of generality specifying an error message is not possible. In real life I see it used with parsers and other computations that could really use an error message.<a href="#fnref22" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn23" role="doc-endnote"><p>The terms understanding and knowledge are often conflated. The difference, however, is significant, here it is described in the context of learning math: <a href="https://japan-math.com/blogs/news/understanding-versus-knowledge" target="_blank">‚ÄúUnderstanding‚Äù Versus ‚ÄúKnowledge‚Äù ‚Äì What‚Äôs The Difference?</a>. This has been very much my experience as a mathematics learner and educator. Things become both easy and simple once you understand them.<a href="#fnref23" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn24" role="doc-endnote"><p>Category Theory will never cease to surprise<a href="#fnref24" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn25" role="doc-endnote"><p>see 2.1 section in <a href="https://core.ac.uk/download/pdf/77240027.pdf" target="_blank">Unlearning before creating new knowledge: A cognitive process.</a><a href="#fnref25" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn26" role="doc-endnote"><p>For readers not familiar with this concept and curious about what this does, <code>Free f a</code> allows to construct monadic (whatever that means) syntax trees with instructions provided by <code>f</code>. In the context of this article, the only important point is that this one line of code has a lot of properties that can be learned (and that many computations come with a similar learning potential).<a href="#fnref26" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn27" role="doc-endnote"><p>Any extraneous cognitive loads associated with effects? Yes, there are a few, especially on the implementation side. Also like most other tools, effects can be abused. I sometimes see a single DSL instruction interpreted directly to IO (more Haskell terminology here, IO is what we call a sin-bin) and used in a brute-force IO code. This just adds cognitive overhead of effects without taking advantage of what they have to offer.<a href="#fnref27" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
</ol>
</section>

    </section>
</article>

        </main>

        <footer>
             <span><a href="../atom.xml">Atom</a></span>
             <span><a href="../RSS.xml">RSS</a></span>
             <span>Site generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a></span>
        </footer>
    </body>
</html>
