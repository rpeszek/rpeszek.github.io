<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Infrequent, Pragmatic, Lambda Blog - Let's agree to be different. On empirical and deductive nature of coding.</title>
        <link rel="alternate" type="application/atom+xml" href="https://rpeszek.github.io/atom.xml" title="atom" />
        <link rel="alternate" type="application/rss+xml" href="https://rpeszek.github.io/RSS.xml" title="rss" />
        <!-- <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="atom"/>
        <link rel="alternate" type="application/rss+xml" href="/RSS.xml" title="rss"/> -->
        <link rel="stylesheet" href="../css/reset.css" />
        <link rel="stylesheet" href="../css/predefault.css" />
        <link rel="stylesheet" href="../css/default.css" />
         
        <link rel="stylesheet" href="../css/syntax.css" /> 
        
        
    </head>
    <body>
        <header>
            <div class="motto">
                <a href="../">hmm >>= oh!</a>
            </div>
            <div class="logo">
                <a href="../">Infrequent, Pragmatic, Lambda Blog</a>
            </div>
            <nav>
                <!-- <a href="/">Home</a> -->
                <a href="../thoughts.html">Semiserious</a>
                <a href="../about.html">About</a>
                <!-- <a href="/contact.html">Contact</a> -->
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>Let's agree to be different. On empirical and deductive nature of coding.</h1>
            <article>
    <section class="header">
        Posted on November  7, 2022
        
        
        
        <div class="changelog"> <div>Revision History: <ul> <li> (2022.11.12) <a href="#fn15">footnote [15]</a> </li> </ul> </div></div>
        
        
        <div class="info">Tags: <a title="All pages tagged 'patterns-of-erroneous-code'." href="../tags/patterns-of-erroneous-code.html">patterns-of-erroneous-code</a>, <a title="All pages tagged 'communication'." href="../tags/communication.html">communication</a></div>
        
    </section>
    <section>

    </section>
    <section>
        <div class="toc"><div class="header">Table of Contents</div>
<ul>
<li><a href="#empirical-vs-deductive">Empirical vs Deductive</a></li>
<li><a href="#coding-by-experimenting-and-observing">Coding by experimenting and observing</a></li>
<li><a href="#why-is-programming-empirical">Why is programming empirical?</a>
<ul>
<li><a href="#experimental-process-and-high-extraneous-loads">Experimental process and high extraneous loads</a></li>
<li><a href="#empirical-fp">Empirical FP</a></li>
</ul></li>
<li><a href="#pragmatists-and-theorists">Pragmatists and theorists</a></li>
<li><a href="#conversations">Conversations</a></li>
<li><a href="#negativity">Negativity</a></li>
<li><a href="#final-thoughts">Final thoughts</a></li>
<li><a href="#unexplored">Unexplored</a></li>
</ul>
</div>
<blockquote>
<p><em>‚ÄúWhen the going gets tough, the tough get empirical.‚Äù Jon Carroll</em></p>
</blockquote>
<blockquote>
<p><em>‚ÄúIf in physics there‚Äôs something you don‚Äôt understand, you can always hide behind the uncharted depths of nature. You can always blame God. You didn‚Äôt make it so complex yourself. But if your program doesn‚Äôt work, there is no one to hide behind. You cannot hide behind an obstinate nature. If it doesn‚Äôt work, you‚Äôve messed up.‚Äù Edsger W. Dijkstra</em></p>
</blockquote>
<p><strong>DRAFT version:</strong> <em>This post is a work-in-progress. Thank you for your feedback.</em></p>
<p>I will discuss (on a very high level) empirical, experimental, and deductive aspects of programming. This distinction is fun to analyze (and a somewhat unusual way to look at programming) but it seems mostly a useless curiosity in itself. I have convinced myself that programmers tend to favor empirical or favor deductive. IMO, we are placing ourselves into 2 camps. I call these camps <em>pragmatists</em> and <em>theorists</em>. This division impacts how we program and communicate. Discussion of both mindsets is the main goal of this post.</p>
<p>The topic for this post came from a realization I had when thinking about cognitive loads (<a href="2022-08-30-code-cognitiveload.html" target="_blank">Cognitive Loads in Programming</a>). It may be obvious to some of you, but it was not obvious to me: programming is largely an empirical process. I will argue that the pragmatic empirical mindset is also dominant.</p>
<p>What the others mean, how they reason, or what is important to them are the contexts in human communication. Communication without the basis of common interest is hard. Good communication requires an effort of understanding these contexts (we call it finding a common language). IMO, <em>empirical, deductive, pragmatist,</em> and <em>theorist</em> are a good terminology choice to analyze some of the current discourse (especially about FP). In this post I will present my observations about the empirical and deductive mindsets. You may disagree with me, please let me know if you do. The point is to get these contexts right, or at least to have all of us think about them a little.</p>
<p>Fairness and lack of bias are rare but beautiful if encountered in human interactions. In my current work I mostly use Haskell and I have been interested in functional programming for a long time, I am a mathematician who became a software developer (27 years ago, but these things stay with you). Thus, this post is likely to have some unintended bias. Also, these are my opinions, not an attempt at a scientifically sound reasoning.</p>
<p>I have not found much discussion about the empirical nature of programming, I am not following academic research in any related area. The topic of <a href="https://en.wikipedia.org/wiki/Empirical_software_engineering" target="_blank">empirical software engineering</a> is relevant to programming and the empirical method, but is not really what I will talk about. Retrospecting on my software programmer career, I recall good and bad things. The good had good communication, the bad had bad communication of some sort. Pragmatists vs theorists is just a part of a bigger puzzle, I am going to explore that part here.</p>
<p>So what is the point I am trying to make? My only real point is that both mindsets are important, my goal is to discuss empirical and deductive (programming), theorists and pragmatists (programmers) in as much debt as I can muster.</p>
<h2 id="empirical-vs-deductive">Empirical vs Deductive</h2>
<p>In my experience, developers do not use this terminology. Hey, in my experience, I do not use this terminology so a recap is in order.</p>
<p>Scientists use these 6 (or more) terms: inductive, empirical, a posteriori, deductive, rational, and a priori. This sounds like the beginning of a catchy song. There is also informal and formal but it breaks the rhythm, so I skip these for now. <em>Practical</em> and <em>theoretical</em> are great terms to describe a mindset, while <em>empirical</em> and <em>deductive</em> describe the thought process. In this post I will mostly try to use <em>empirical</em> and <em>deductive</em> when referring to the thought process, I will use <em>pragmatist</em> and <em>theorist</em> when referring to people.</p>
<p>Empirical (to avoid using inductive<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>) reasoning draws general conclusions from observations. E.g. certain software functionality will work because we tested it (notice how well software testing fits into this definition). Thinking about software testing as an empirical process allows us to consider things like bias<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> (e.g.¬†the assumptions we make in unit tests), observation sample size (did we test enough?), correlation vs causality (e2e tests are unstable, is there something wrong with e2e testing itself?), if observations are balanced (adequate coverage of test scenarios across functional areas), establish observation baseline (<a href="https://en.wikipedia.org/wiki/Characterization_test" target="_blank">golden testing</a> for complex deterministic code)‚Ä¶ Here is an exaggerated example of a correlation vs causation problem: ‚ÄúEach time I test the app it works just fine, yet users keep reporting issues. Something‚Äôs wrong with these people!‚Äù. But it is even more fun to think about both experiments and observations.</p>
<p>Deductive reasoning goes from general knowledge to specific conclusions. E.g. certain software functionality will work because of type safety or because it is a straightforward application of something else we believe works. In this post, deductive represents a wide range of thought processes: from tedious ‚Äúobservation-less‚Äù mental verification of values and types (oh, this value was supposed to be a positive number, why is it negative?, is the new refactored code equivalent to the previous?‚Ä¶) all the way to formal reasoning (e.g.¬†equational proof that refactored code is equivalent).</p>
<p>Empirical and deductive work in tandem and both are essential. IMO, we (as individuals) prefer to use one more than the other. Understanding more about these preferences will be the main topic of this post.</p>
<p> <div class="side-note">Formal reasoning<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> is the only approach humans have figured out to solve complex problems correctly<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> on the first go (without trial and error associated with empirical reasoning). Being a programmer, I like to think about formal reasoning as immutable and empirical reasoning as an in-place mutation (e.g.¬†mathematics keeps adding to itself while empirical sciences like medicine keep changing)<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>.<br />
In-place mutation in programming is the refactoring process. Can you think about math-like immutable designs in programming? E.g. a design or code that aged very well over, say, over the last 20 years?<br />
In this post I am not separating the formal out, it is bundled into deductive. I have struggled with this decision, at the end I decided to simplify things and keep formal reasoning bundled into the more broad deductive process.<br />
 </div></p>
<p>You may think that I am spending too much time explaining the obvious: any engineering will have a strong empirical aspect, engineers like to tinker with things. I assume that some readers are like me and have not thought about it before. The next section goes deeper into the empirical nature of coding.</p>
<h2 id="coding-by-experimenting-and-observing">Coding by experimenting and observing</h2>
<p>Consider these tools and processes: debuggers (<em>observe</em> execution of statements), loggers (record <em>observed</em> behavior), testing (<em>observe</em> app behavior and <em>draw general conclusions</em> about app correctness), TDD (pre-define <em>observation</em> outcomes for the code), design patterns<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> (generalize code <em>observed</em> to work well, create coding protocols). I encourage you to think about tools and processes that are targeting the deductive, there are some!</p>
<p>Trial and error is how a lot of programming is done. We write some code (<em>experiment</em>) and then <em>observe</em> the result using tests, a debugger, looking at the logs, or simply observe how the app behaves ignoring other diligence. Personally, I am a little afraid of experimenting with certain types of code and I try to think through all scenarios, I could miss something but my mental process includes a lot of deductive effort. I have worked with many programmers who operate in a similar way. However, I still need to test the code to <em>observe</em> it working, make changes if needed, and rinse and repeat. Despite some deductive elements, this approach is still very experimental in its nature.</p>
<p>How about working in code that is a complete mess? We make experimental changes and then test / debug / trace the heck out of it<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>, right? We may try to reason about what solution is likely to work, but that is not much different from experimental alchemists trying not to blow themselves up. I can recall several projects where all my understanding was derived from debugging or tracing.</p>
<p>Let‚Äôs talk about process bureaucracy. Working in an empirical world means procedural protocols. Scrum is a procedural protocol: consider the continuous improvement process with retrospectives or team velocity calculation, these are all very empirical. Test plans, test cases, coding and formatting standards, git hygiene, even design patterns are also procedural protocols. In contrast, the deductive needs a cushy couch. Deductive and bureaucracy, IMO, do not mix well. Waterfall was a failed idea of applying an informal deductive approach to project management. There is a lot of real world complexity in project management and empirical is needed (see also <a href="https://premieragile.com/defined-vs-empirical-process/" target="_blank">Defined Process Vs Empirical Process</a>). Waterfall reminds me of mocking in unit testing. Both do not work well for similar reasons.</p>
<p>Let‚Äôs talk about bias in empirical reasoning. Figuring out contributing factors and causality is often the hardest and the most important part in empirical reasoning. If your wrist hurts when you type, is this a pinched nerve in the wrist? or, are you looking down on your laptop and the nerve is pinched around your neck? or there is a pressure point somewhere in your arm? or maybe it is not a nerve issue at all? Practitioners of empirical have been known to assume wrong cause<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>. Empirical is tricky.</p>
<p>Programmers are exposed to bias too. Performance issues or a bug could be caused by many factors, e.g.¬†an application could misbehave only in certain scenarios or only in certain environment configurations, the underlying issue could be in the application code, library code, a configuration issue, an environment problem‚Ä¶ It is not unlikely for a developer to go down a wrong path during the troubleshooting process. I view programming as an empirical process with accelerated feedback. You can go down a wrong path but you typically learn that fast.</p>
<p>I had a fun discussion with my wife, she is a data scientist working on pharmacological studies. We were discussing if a design of a clinical trial could be adjusted to do software benchmarks. There are some intriguing similarities. Obviously, humans are much more complex than programs and targeted approaches will work better in either domain. But it was a fun discussion and one that convinced me even more about the empirical nature of software development.</p>
<p>Why did we settle on using the empirical method in science? We do empirical not because we want to but because we have to. Empirical is the only way to study the unruly real world. Why did we settle on using the empirical method in programming?</p>
<h2 id="why-is-programming-empirical">Why is programming empirical?</h2>
<p>I will focus on these 2 reasons: nondeterminism and code complexity. Let‚Äôs start with the second. An interesting question is how much the empirical nature of programming has to do with arbitrary (artificial) complexity. IMO, a lot.</p>
<h3 id="experimental-process-and-high-extraneous-loads">Experimental process and high extraneous loads</h3>
<p>I am framing this in the context of my previous (<a href="2022-08-30-code-cognitiveload.html" target="_blank">cognitive loads in programming</a>) post. If you have not looked at that post, simply substitute <em>high extraneous load</em> with messy code or complex code. I think we are in a position to put a 1 and 1 together:</p>
<blockquote>
<p>‚ÄÉ <em>The experimental nature of programming is a consequence of its high extraneous load and also one of its main causes</em></p>
</blockquote>
<p>The bigger extraneous load the more we experiment. The more we experiment the bigger the extraneous load gets.<br />
To work on a complex code we are effectively forced to experiment. Adding more experimental code only increases the complexity.</p>
<p>This is a feedback loop. To break this loop (and control the complexity) we need to rewrite or refactor parts of the code. These involve some deductive process. Some amount of deductive is essential, a deductive is what can break the feedback loop. Deductive and empirical thought processes are closely related to cognitive loads discussed in my previous post and to controlling arbitrary complexity.</p>
<p>There is one notable exception where piling up experiments does not result in extraneous complexity. It is called type safety.</p>
<p> <div class="side-note"><strong>Side Note: Type safe experiments</strong> are my favorite approach to programming. In the presence of a nice type system, coding can become solving jig-saw puzzles (writing code by using building blocks that can fit only in a correct way). A similar process can work even in TypeScript<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a>. It is typically enough to provide just enough safety to reduce the implementation solution space to prevent accidental incorrect implementations (this more relaxed approach ignores <a href="https://www.hyrumslaw.com/">Hyrum‚Äôs Law</a> but IMO still works well).</p>
<p>This approach could include an interactive, type checker assisted deductive process (asking the compiler a series of type questions, something akin to type hole driven development<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a>) or just making a guess and trying to see if the pieces fit. The second approach is a form of experimentation. Working with <em>hlint</em> (Haskell linter, other static tools that do similar things exist) is lots of experimental fun too. I often need to get <em>a solution</em> in and the linter will replace it with a much nicer fused code.</p>
<p><em>Combinator</em> is a 100 years old term and I could be wrong about its intended intuitive meaning<a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a>. To me it means a <em>building block</em>. Functional programming is about designing and using well fitting combinators.</p>
<p>Jig-saw puzzle approach results in very clean programs, is addictive, and a lot of fun, but (sadly) is not commonly used at large.  </div></p>
<h3 id="empirical-fp">Empirical FP</h3>
<p>FP is considered theoretical for at least 2 reasons: <em>(1)</em> FP considers formalism to be important, <em>(2)</em> how it is being presented to the public<a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a>. But, is FP an empirical process as well?</p>
<p>Consider 2 cornerstones of scientific experiments: reproducibility and properly randomized sufficiently large observation samples, and restrict our attention to automated testing. FP-ers will immediately notice two related concepts: <em>referential transparency</em> and <em>property testing</em> (e.g.¬†QuickCheck). Clearly FP has a lot going on for it if you look at it from the empirical angle.</p>
<p>Whatever your opinion about FP vs code complexity is, you have to agree that FP is about controlling nondeterminism. Functional programming tries to separate out the predictable deterministic part (pure functions) and limit (even stratify) the unruly effectful parts. Functional programming handling of nondeterminism is analogous to empirical study designs trying to control variance. I think that this is why FP seems so empirically-friendly.</p>
<p>Haskell is sometimes called <em>the best imperative PL</em><a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a>. I propose that <em>FP could become the best empirical programming method</em> (yeah, could I be a little biased). However, it is ‚Äúcould become‚Äù rather than ‚Äúis‚Äù. Empirical process benefits from good observability, e.g.¬†decent debuggers, stack traces, rich amount of error information‚Ä¶ This is an area where FP could improve in general (Haskell in particular)<a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a>.</p>
<p> <div class="side-note"><strong>Side Note:</strong><a href="#fn15" class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a> (Haskell 101). What could better explain a theorist mindset than to actually experience some of the formal thinking? Here is an ‚Äúelementary‚Äù (from ground up, using only basic language features) implementation of a popular Haskell combinator. Notice the implementation is just a bunch of equations that use constructors or pattern match and nothing else:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="ot">partitionEithers ::</span> [<span class="dt">Either</span> a b] <span class="ot">-&gt;</span> ([a], [b]) </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>partitionEithers [] <span class="ot">=</span> ([], [])</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>partitionEithers (<span class="dt">Left</span> a<span class="op">:</span> es) <span class="ot">=</span> (a<span class="op">:</span> ra, rb)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>    <span class="kw">where</span> (ra, rb) <span class="ot">=</span> partitionEithers es</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>partitionEithers (<span class="dt">Right</span> b<span class="op">:</span> es) <span class="ot">=</span> (ra, b<span class="op">:</span> rb)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>    <span class="kw">where</span> (ra, rb) <span class="ot">=</span> partitionEithers es</span></code></pre></div>
<p><strong>Fun exercise 1</strong>: Identify the obvious conservation law for list lengths. Use QuickCheck or other property testing library to verify it. It suffices to test just one type, say <code>a ~ b  ~ Bool</code> (unit <code>()</code> will do too), can you provide a reason why? Can you try to formalize it?<br />
<strong>Fun exercise 2</strong>: Use paper and pencil to prove that this implementation satisfies that law. This exercise shows, formal reasoning does not need to be complex or advanced.<br />
<strong>Fun exercise 3</strong>: Change the above code to violate the conservation law. How likely is for such implementation to be accidental? Add <a href="https://ucsd-progsys.github.io/liquidhaskell/" target="_blank">Liquid Haskell</a> annotations to prevent unlawful solutions.<br />
<strong>Fun exercise 4</strong>: In Haskell, any implementation of <code>partitionEithers</code> type is a <a href="https://bartoszmilewski.com/2015/04/07/natural-transformations/" target="_blank">natural transformation</a> in <code>a</code> and <code>b</code>. Can this be used in exercise 1?<br />
<strong>Fun exercise 5</strong>: (1) and (4) rely on Haskell language property called parametricity. This prevents Haskell programs from learning what the actual types behind <code>a</code> and <code>b</code> are or use values of these types in a concrete way (e.g.¬†there are no globally available <code>==</code>, <code>toString</code> etc). A number of mainstream languages have now the ability to express a type similar to <code>partitionEithers</code>. Exploit lack of parametricity in your chosen language to create an implementation of <code>partitionEithers</code> that violates the conservation law only for some types and works as expected for others (this makes randomized testing harder, why?). Show that your implementation is not a natural transformation.</p>
<p>Hints and partial solutions<a href="#fn16" class="footnote-ref" id="fnref16" role="doc-noteref"><sup>16</sup></a>.  </div></p>
<p>FP is a hybrid containing both empirical and formal. ‚Ä¶ But I got sidetracked a bit. Let‚Äôs finally get to my main topic: the human aspect.</p>
<h2 id="pragmatists-and-theorists">Pragmatists and theorists</h2>
<p>I am using terms <em>theorist</em> and <em>pragmatist</em> somewhat colloquially, but the meaning is close to how the terms are used elsewhere. In this section I will try my best to describe both mindsets. IMO, mindset and interest are very related terms. In this post I could almost use them interchangeably.</p>
<p>If you listen to a functional programmer talk, you are likely to hear these terms: ‚Äúreasoning about code‚Äù, ‚Äúprincipled computation‚Äù, ‚Äúcomputation laws‚Äù, ‚Äúcorrectness by design‚Äù, ‚Äútype safety‚Äù. These people are likely to study things like lambda calculi, operational semantics, category theory, type theory‚Ä¶ All these things come with formal proofs and could result in a very specific mental training. <em>To this group programming is more of a deductive process.</em></p>
<p>These things do not resonate with the vast majority of programmers who have a more pragmatic mindset. You are more likely to hear these terms: ‚Äútesting‚Äù, ‚ÄúTDD‚Äù, ‚Äúhacking‚Äù (meant as a compliment, ‚ÄúI made it work‚Äù), even ‚Äúdesign patterns‚Äù (though rarely these days). <em>To this group programming is more an empirical process.</em><a href="#fn17" class="footnote-ref" id="fnref17" role="doc-noteref"><sup>17</sup></a></p>
<p>A theorist‚Äôs primary interest is in deductive reasoning. This implies an interest in the deductive itself. Deductive reasoning is often called top-down reasoning (general knowledge comes first). Formal reasoning (the pinnacle of deductive) has a very strong attraction for some individuals while being very much disliked by others. Some programmers dive deep into FP and learn formal reasoning. Sometimes a mathematician (this was the case with me) makes a career conversion and becomes a developer. Interest in the deductive and formal is rather rare, to many programmers formal methods are a foreign concept.</p>
<p>In contrast, a pragmatist‚Äôs primary interest is in accomplishing the tasks at hand. Pragmatists will experiment and go empirical to get there. ‚ÄúWhen the going gets tough, the tough get empirical.‚Äù Real world complexity is rarely fully amenable to formal reasoning. Unfortunately pragmatists take a stronger stance on this, a pragmatist may think that formal reasoning is never useful.</p>
<p>I need to emphasize that what I am presenting is an oversimplification. People are complex and cannot be easily labeled. In particular, data scientists, statisticians, programmers interested in probabilistic computing models have a lot of formal training but probably will develop a more empirical attitude towards programming. The attitude towards programming is shaped by many factors (e.g.¬†work experiences, types of programming projects). Theoretical vs pragmatic mindset is IMO a good first approximation.</p>
<p>Pragmatists will say ‚Äúit works because we tested it‚Äù. Theorists will say ‚Äúit is correct by design‚Äù (or closer to Dijkstra: ‚Äúwe tested it and we know it does not work‚Äù<a href="#fn18" class="footnote-ref" id="fnref18" role="doc-noteref"><sup>18</sup></a>). Pragmatists will say ‚Äúthis abstraction is too complicated to use because it is too theoretical‚Äù. Theorists will say ‚Äúthis abstraction is too complicated because it lacks theoretical backing‚Äù. The 2 groups may find it difficult to communicate ‚Äúthis is nice‚Äù and ‚Äúthis is terrible‚Äù have a very different context when spoken by a pragmatist and a theorist.</p>
<p>Pragmatists want the tools to be mainstream and popular to pass their test of practical usefulness. Pragmatists will select tools that provide good ability to observe how the code runs. To a pragmatist reasoning about code often means studying its execution flow. Some pragmatists go a step further and will only select a PL that allows them the best control over execution (e.g.¬† <em>JS</em> is used by browsers so this is what they will want to write). This could be caused by a (somewhat justified<a href="#fn19" class="footnote-ref" id="fnref19" role="doc-noteref"><sup>19</sup></a>) distrust for abstractions.</p>
<p>In contrast, theorists want tools that support, rather than inhibit, deductive reasoning. They typically want to reason on a higher level than the execution flow. Many will view programs and execution as decoupled concerns<a href="#fn20" class="footnote-ref" id="fnref20" role="doc-noteref"><sup>20</sup></a>. This is where the <em>imperative vs denotative</em> discussion comes into play as well.</p>
<p>I consider programming to be a combination of both the engineering procedural processes and math-like science. Pragmatists are interested in the process, they want code standards, formatting standards, clean git history‚Ä¶ Theorists will want functors, monads, higher rank types, higher kinded types, dependent types‚Ä¶ Programming, obviously, benefits from both engineering and mathematics.</p>
<p>What makes us effective and confident when working with code? For a pragmatist the source of confidence is likely to be test coverage, for a theorist it will be type safety, abstractions, lawfulness. For both confidence implies some ability to understand the code (absorb the cognitive load). To put some of these thoughts in the context of the previous post:</p>
<blockquote>
<p>‚ÄÉ <em>Theorist typically prefer germane, pragmatists are more at home with extraneous cognitive load</em><br />
‚ÄÉ <em>Theorist typically prefer simple and hard, pragmatists prefer easy and will accept complex</em></p>
</blockquote>
<p>One bizarre difference I have noticed between heavy deductive thinkers and empirical mindsets is their favorite approach to learning. When learning, some theorists will want to finish a section or chapter before writing a single line of code. The top-down thinking sometimes extends to top-down learning (a theorist wants to internalize the theory before applying it). My wife and I are in this group. I had to force myself to write some code early when going through <a href="https://www.goodreads.com/book/show/112252.Types_and_Programming_Languages" target="_blank">Types and Programming Languages</a>, I decided to create a public github repo to give myself incentive to code as I learn when reading <a href="https://www.goodreads.com/book/show/33618151-category-theory-for-programmers" target="_blank">Category Theory for Programmers</a> and <a href="https://www.manning.com/books/type-driven-development-with-idris" target="_blank">T(ype)DD in Idris</a>. Some theorists treat learning as a murder mystery and want to learn ASAP who done it, pragmatists know it will be the butler.</p>
<p>On the flip side, pragmatists prefer hands-on learning from code examples (ideally, associated with project work) and typically expect immediate return on their learning investments. E.g. a pragmatist is unlikely to spend several months studying, say, a one line of code<a href="#fn21" class="footnote-ref" id="fnref21" role="doc-noteref"><sup>21</sup></a>. Pragmatists are less likely to search for deep understanding (this is kinda definitional, having theoretical interests makes you a theorist).<br />
Also, it seems logical to assume that learning from experience is more habituating. Pragmatists may have a harder time making mental shifts to how they work with code. <em>Unlearning</em> is hard on all of us, I believe it is harder on pragmatists.</p>
<p>The part of FP that has been the most disappointing for me is a typically low quality of error outputs. This may have to do with all falsehoods being equivalent in mathematics<a href="#fn22" class="footnote-ref" id="fnref22" role="doc-noteref"><sup>22</sup></a>. However, we should not criticize the theory, rather the theorists for selecting abstractions that suppress or confuse error information. I wrote about it in the previous post and also before<a href="#fn23" class="footnote-ref" id="fnref23" role="doc-noteref"><sup>23</sup></a>.</p>
<p>In contrast, to an experienced pragmatist error output is (typically) an important observation. It is a pragmatic thing to do to know <em>what</em> went wrong. However, the tendency towards the use of <code>null</code>, <code>Option</code>, <code>Maybe</code> suppressing available information is something I do not understand. IMO, goes beyond the topics we are discussing here.</p>
<p>While theorists may have a problem engaging with things outside of their theoretical model, pragmatists often have a problem engaging with things that are even mildly theoretical like computational laws or even referential transparency. Programmers often don‚Äôt care about computational properties, but will be surprised by software behavior when they are missing. Many gotchas can be described as a ‚Äúnatural‚Äù computation property that is violated.</p>
<p>Some theorists may not see a big difference between a prototype and a product that is fully implemented and maintained. This could be related to <em>published equals done</em> in academia and can be quite annoying.</p>
<p><strong>Probably, the most interesting difference between both mindsets is:</strong></p>
<blockquote>
<p>‚ÄÉ <em>A bug means an observed malfunction to empirical pragmatists</em><br />
‚ÄÉ <em>A bug means a logical flaw to formal theorists</em></p>
</blockquote>
<p>In empirical science, rare is tricky. Rare can escape the empirical process. The term <em>outlier</em>, used in statistics, is relevant. The term ‚Äúzebra‚Äù is used by medical doctors, ‚Äúzebras‚Äù are hard to figure out, rare cases. Empirical reasoning sometimes equates rare with impossible. When dealing with real world we say:</p>
<blockquote>
<p>‚ÄÉ <em>‚Äúthe exception that proves the rule‚Äù</em><br />
‚ÄÉ In formal reasoning <em>exceptions disprove the rule.</em></p>
</blockquote>
<p>In software engineering an exceptional, rare event often stops being rare (e.g.¬†when the data or usage changes expose it). I fixed many bugs caused by a programmer‚Äôs decision that a certain scenario is very unlikely and, thus, it is OK to cut corners. In my experience, ignoring rare scenarios saves hours and ends up costing weeks or even months later.</p>
<p>However, I am not convinced that cutting corners is unique to either mindset. A pragmatist may think ‚Äúthis is so unlikely, I will not waste time on it‚Äù. The rare case could be not represented by the theoretical model that a theorist is considering (e.g.¬†error information in a bunch of FP code). IMO, pragmatists and theorists cut corners in different ways, however, <em>cutting corners has no place in formal reasoning</em> and I expect some programmers (most likely a subset of theorists) carefully think through rare cases.</p>
<p>Theoretical and practical mindsets are antipodes of programming. Even for people who ‚Äúown‚Äù both, being a pragmatist or being a theorist is like wearing a hat. You can‚Äôt wear both at the same time, you would look ridiculous. I started making a conscious effort to understand which hat I have on.</p>
<p> <div class="side-note"><strong>Side Notes.</strong> Many things about programming seem to be on their head (making hats a somewhat tricky accessory). Some ideas typically associated with FP are very pragmatic. E.g. descriptive types, clear inputs and outputs, getting the same result on each try, ADTs (how could the ability to get a lot of generic code for free in Haskell be considered anything but pragmatic?)‚Ä¶ At the same time OOP is quite theoretical (taxonomic knowledge is fascinating academically, e.g.¬†in biology or linguistics, but how practically important is it in programming?) and very complex (e.g.¬†subtyping variance). I dislike OOP primarily because it makes type checking less effective and I rely on type safety.</p>
<p>Another complex aspect is how <em>theoretical</em> or <em>pragmatic</em> you are. If we classify a typical <em>Rust</em> programmer as a <em>theorist</em>, where do we put someone using <a href="http://www.ats-lang.org/" target="_blank"><em>ATS</em></a>? If a typical <em>Haskell</em> developer is a <em>theorist</em>, how do we classify someone working with <em>Agda</em> or <em>Coq</em>‚Ä¶?</p>
<p>I am simplifying all of this and consider programmers to be either <em>pragmatists</em> or <em>theorists</em> and take an oversimplified (binary) and a somewhat stereotypical view of what these terms mean.  </div></p>
<p>This post argues that both traits are important. We will dig deeper into both ways of thinking by analyzing some examples.</p>
<h2 id="conversations">Conversations</h2>
<p>So far, this post has tried to upset people on both sides equally. This section will be biased towards theorists, it is hard for me to present the pragmatist‚Äôs viewpoint this way. Engineers are some of the cleverest people on this planet. If someone rewrote this section from an engineer/pragmatist point of view, I would love to read it.</p>
<p>Perhaps not surprisingly, theorists are not all equally disappointed about logical software defects. Explaining this diversity is a price I have to pay for bundling all theorists together. Think physics, it is very theoretical, yet theoretical physicists are happy to do hand waving arguments. In contrast, there is no hand waving in mathematics. IMO, this stricter view plays a role in how some of us approach programming.</p>
<p>Alice: ‚ÄúWe have a concurrency issue in our code‚Äù<br />
Bob: ‚ÄúAre you talking about a production issue, a failing test, or is it purely theoretical?‚Äù<br />
If Alice gets a change to explain the race condition, she may hear this response:<br />
Carol: ‚ÄúWe did it like this before and everything was fine‚Äù.</p>
<p>Alice (nick name Negative Nancy, a theorist) considers all logical defects to be a disappointment. Bob and Carol are pragmatists and approach logical defects in a more relaxed way. It seems like a good idea for Bob and Carol to understand a little bit about how Alice approaches programming, and vice versa. Let‚Äôs analyze this dialog a little bit.</p>
<p>To Alice logical issues are kinda a big deal. She will consider it very hard to reason about code sprinkled with logical flaws. There is actually a good reason for this. Some logical flaws we examined in my previous post<a href="#fn24" class="footnote-ref" id="fnref24" role="doc-noteref"><sup>24</sup></a> are quite isolated but it is hard (if not impossible) to understand the full impact of many of them. I am like Alice, working in a complex imperative program or a poorly written functional code results in me forming a large mental repository of issues and their unclear impacts. Maintaining it is a tough mental effort.</p>
<p>Here is a story from my personal experience. A few years back I did a code review session with two (very capable) developers. I showed them one of my ‚Äúbug stashes‚Äù in the project we all were contributing to. It had to do with a logically brittle use of inheritance. I demonstrated the process I go through to verify the brittle bits. This session was very productive, we all learned something from it, and this code was refactored later. Their response is something I still contemplate: ‚ÄúWe do not go through such steps, we just assume it will work‚Äù. For me it was a learning experience I still think about, it made me realize how different our mindsets are.</p>
<p>Returning to Bob, he is a pragmatist. Notice that Bob has stratified all contexts he assumed relevant to Alice‚Äôs finding: production issue, failing test, and theoretical. To Bob, a logical issue in code is just a part of life. ‚ÄúIt has bugs, it‚Äôs called software.‚Äù This empirical mindset, in some ways, is healthier<a href="#fn25" class="footnote-ref" id="fnref25" role="doc-noteref"><sup>25</sup></a>. It is not unusual for empirical reasoning to dismiss theoretical concerns, however in this case this is likely to be wrong. It is hard to spot or even assess the impact of some bugs (e.g.¬†race conditions) using testing or other observation based methods<a href="#fn26" class="footnote-ref" id="fnref26" role="doc-noteref"><sup>26</sup></a>. The concurrency flaw Alice has identified can start manifesting itself all the sudden, this is what concurrency issues have been <em>observed</em> üôÇ to do.</p>
<p>Carol‚Äôs response suggests an empirical mindset as well. Carol has generalized previous observations of a working product and that generalization overrides Alice‚Äôs warning bells. Going from specific to general is what empirical process is about. Proper empirical reasoning will question, even invalidate, previous ‚Äúhypothesis‚Äù if new evidence provides reasons for doing so, but Alice is not providing any empirical evidence. Alice‚Äôs argument is purely deductive, it could be helpful if she came up with a test that exposes the concurrency problem she has identified (this could be, obviously, very hard or even impossible to do).</p>
<p>Bob: ‚ÄúWe are starting the new frontend project, I propose we keep using XYZ PL, but maybe we could add a new library to our setup?‚Äù<br />
Alice: ‚ÄúXYZ is fundamentally broken, we should move to something sound, like Reason.‚Äù<br />
Carol: ‚ÄúAlice, we do not know that PL, this will put the project at risk!‚Äù<br />
Alice: ‚ÄúWe know so many problems about XYZ, XYZ puts the project in jeopardy too‚Äù.</p>
<p>You may be wondering why I call JavaScript XYZ? Well üôÇ, XYZ was intended as a placeholder. Alice would like to use tools that help, not inhibit her deductive process and are logically sound. Alice has witnessed her colleagues (and probably herself) trip over XYZ unsound design numerous times. She considers the use of XYZ akin to building a house on a broken foundation.<br />
Bob and Carol insist on tools that have good IDE support, good debugging, and are familiar even if logically unsound. Pragmatists want to reason about execution flow, browsers use <em>JS</em>, thus, they may want a language very close to <em>JS</em>. Carol has a very valid point too, one that Alice may have hard time accepting. I admit, I sympathize with Alice, even if Carol is probably right here.</p>
<p>Alice: ‚ÄúYou are memoizing a computation that is not referentially transparent‚Äù<br />
Carol: ‚ÄúI have manually tested it and, besides, this code has a 100% test coverage‚Äù<br />
Bob: ‚ÄúWe are assuming that it is referentially transparent and want consistent results when we use it‚Äù<br />
Alice: ‚ÄúRemember we patched a bug by updating shared state in the middle of this computation, did you retest this scenario?‚Äù</p>
<p>This code review session shows a benefit of having someone around who keeps a repository of potential issues in their head. I have noticed that developers are typically surprised when computation behavior keeps changing, yet are mostly not willing to engage with the concept of referential transparency. I also think some do not think about what 100% test coverage implies and what it does not<a href="#fn27" class="footnote-ref" id="fnref27" role="doc-noteref"><sup>27</sup></a>.</p>
<p>Bob: ‚ÄúI changed the interface, you can now pass new parameters to control how the data is processed‚Äù<br />
Alice: ‚ÄúI changed the module, you can now use new functions (combinators) to manipulate the data‚Äù</p>
<p>Functions are great for reasoning about code, parameters are great for tweaking and experimenting.<br />
Alice‚Äôs deductive approach can really be beneficial when writing code, probably more than when troubleshooting empirically implemented code. Let‚Äôs get a little philosophical:</p>
<p>Alice: ‚ÄúIdeal code to me is one I would still be proud of after 10 years‚Äù<br />
Bob: ‚ÄúIf you think about your 10 year old code as perfect, you learned nothing in these 10 years‚Äù<br />
Alice: ‚ÄúI am looking for something as timeless as mathematics‚Äù<br />
Carol: ‚ÄúMathematics keeps improving and changing I am sure, everything does‚Äù<br />
Alice: ‚ÄúNo, it only grows, it has not changed its mind in over 100 years‚Äù</p>
<p>This is almost an exact copy of a conversation I had with some of my coworkers. The immutability analogy I have used before works well here: mathematics is immutable while empirical sciences mutate in-place. Bob‚Äôs argument is partially valid as there is a lot of engineering going into coding and that is likely to keep changing<a href="#fn28" class="footnote-ref" id="fnref28" role="doc-noteref"><sup>28</sup></a>. Also, formal verification has a maintenance cost<a href="#fn29" class="footnote-ref" id="fnref29" role="doc-noteref"><sup>29</sup></a> making me question how realistic Alice‚Äôs dream is. Can you think about code examples that aged very well?</p>
<p> <div class="side-note">We consider PLs that reach a certain threshold of usage as immortal. A PL could be immortal but the ideas that went into its design may have died a long time ago. Empirical needs an ability to mutate to improve. PLs are an example where, due to backward compatibility, changes are very hard to do. Empirical + immutable + immortal is a bad combination. This is why some (theorists of course) dislike mainstream PLs. Another example where immutability of formal thought is very, very useful is P2P (e.g.¬†distributed blockchains). If distributing a code change is expensive or impossible, then the formal is needed. Inadequate amount of formal in these areas is simply unpragmatic and costly. IMO, ‚Äúcode that ages well‚Äù is an important topic.<br />
 </div></p>
<p>These conversation examples were not intended to be exhaustive. I invite you to think more about the differences between pragmatists and theorists in both creating and consuming the code. I invite you to think more about how each side thinks.<br />
I need to emphasize, this is not a binary separation where everyone is either pragmatist or theorist. Many of us have both traits, just one is more dominant than the other and they tend to not manifest at the same time.</p>
<p> <div class="side-note">For the longest time, I could not figure out why certain decisions about PLs, popular libraries, or programming projects are being made. I could not understand why certain bugs remain not fixed, why there are no deprecation attempts, why certain decisions have been made in the first place. The empirical mindset I have tried to explain here is my best attempt at understanding these things. E.g. I cannot explain in any other way why Java maintainers decided not to deprecate standard library classes where <code>equals</code> is not symmetric. The list of such issues is long<a href="#fn30" class="footnote-ref" id="fnref30" role="doc-noteref"><sup>30</sup></a>. Are all of these ‚Äúexceptions that prove the rule of solid design‚Äù, rare and thus not important cases in the mindset of the maintainers? I consider this approach to be not pragmatic and expensive. If I was in charge of designing programming courses<a href="#fn31" class="footnote-ref" id="fnref31" role="doc-noteref"><sup>31</sup></a>, an example exercise would look like this:</p>
<blockquote>
<p>‚ÄÉ <em>There is a common belief that TypeScript compilation flags like <code>strictNullChecks</code> prevent escaped <code>null</code> and <code>undefined</code>.<br />
‚ÄÉ Exploit how TS defines variance to create a function that has <code>number</code> as the return type but it returns <code>undefined</code> for some of its input parameter values.</em></p>
</blockquote>
<p>The pragmatist‚Äôs take (as I see it) is: (1) the impact of these booby traps is small and with some luck you will not notice (or <em>observe</em>) them in your project, (2) the ingredients you use do not need to be sound, they are just a part of a bigger implementation noise. I do not agree with these arguments, but at least I think I know what the arguments are.  </div></p>
<h2 id="negativity">Negativity</h2>
<p>There is quite a bit of negativity around us, the programming community is not exempt from it. I will wrap up with some loose thoughts about negativity in the context of deductive and empirical mindsets.</p>
<p>Venting frustration, IMO, does not improve how either the ‚Äúventer‚Äù or the ‚Äúventee‚Äù feel. It only fuels the negativity. IMO, the best way to fight negative emotions is to employ the deductive. Figuring out the underlying context that causes negativity can save a conversation and simply engaging in that search can protect you. Using logic to confront emotions is a form of what psychologists call <a href="https://www.apa.org/topics/anger/control" target="_blank">cognitive restructuring</a>.</p>
<p>Criticism of bad code is bound to be unpleasant to its authors. Even worse, a lot of code can be criticized on purely logical grounds. This can be interpreted as a critique of the author‚Äôs competence and, I am sure, is a big source of negativity and tension. Let‚Äôs look at this differently. Look at some of the empirical sciences like neuroscience and see how much of the knowledge got adjusted if not invalidated<a href="#fn32" class="footnote-ref" id="fnref32" role="doc-noteref"><sup>32</sup></a>. IMO, programming is on a very localized and very accelerated path of the same process. Is ‚Äúbad code‚Äù phenomena partially related to the empirical nature of programming? I think it is<a href="#fn33" class="footnote-ref" id="fnref33" role="doc-noteref"><sup>33</sup></a>.</p>
<p>Theorists are likely to devote a significant effort into learning. How does it feel to not be allowed to use what you worked hard to figure out? Examples like <a href="https://brianmckenna.org/blog/howtostopfp" target="_blank">How to stop functional programming</a> come to mind. This is something that can be changed on a small scale but there are only a few places who care to do so. There must be quite a few frustrated programmers out there<a href="#fn34" class="footnote-ref" id="fnref34" role="doc-noteref"><sup>34</sup></a>. I have been in that position and I know it is mentally hard. I have argued that the deductive process plays an important role and, IMO, it is in the interest of the industry to treat the ‚Äútheorists‚Äù minority better.</p>
<p>I have promised at the beginning that I will not try to make too many ‚Äúpoints‚Äù. This section contained the exceptions that prove the rule üôÇ.</p>
<h2 id="final-thoughts">Final thoughts</h2>
<p>Did I sneak in any other side-‚Äúpoints‚Äù worth noticing? IMO, this one:</p>
<blockquote>
<p><em>Strict backward compatibility implies a need for formalism</em><br />
or, equivalently<br />
<em>Empirical, immortal, immutable, sanity: pick 3</em></p>
</blockquote>
<p>The odd discourse between formal and empirical is not unique to programming. I still remember a few jokes about ‚Äúa mathematician, a physicist, a chemist, ‚Ä¶‚Äù. Empirical vs deductive, if one needs to budge then the empirical wins, mathematics has to move. Some (mostly functional programmers) argue that computer science and programming could benefit from a stricter application of formalism<a href="#fn35" class="footnote-ref" id="fnref35" role="doc-noteref"><sup>35</sup></a>. The difference is where the source of truth is. In a pure empirical world that source has to be what we observe. In programming there can be just enough determinism to benefit from treating logical soundness concerns more seriously. My main point is that we need both empirical and deductive and I hope I made a convincing case for us to try harder for their peaceful coexistence.</p>
<p>Thank you for reading!</p>
<h2 id="unexplored">Unexplored</h2>
<p>We can learn a thing or two about programming if we think about it as an empirical process. We can learn a thing or two about the empirical process itself if we examine programming as a case study. We did a little bit of both in this post. It seems that this synergy can be explored more.</p>
<p>Impact of education on the development of either mindset.</p>
<p>Related psychology, evolutionary biology: Humans survived and evolved by ‚Äúobserving‚Äù things and acting on these observations. Empirical process is in our nature. This also explains why we dismiss rare scenarios. I do not feel qualified to discuss these in more depth.</p>
<p>As we have discussed, developers approach bugs differently. This is how my interest in figuring out different programmer mindsets has started. There is a different way to look at this. Consider these 3 axes: ‚ÄúIt has bugs, it‚Äôs called software‚Äù is the origin, testing is one axis, ‚Äúcorrectness by design‚Äù abstractions and type safety is second, a mental repository of possible issues and their impacts is third. Pragmatists are on the first axis, theorists on the second. We need the name for the third group, let‚Äôs call them <em>perfectionists</em>. I came to FP on a correctness wagon, theory and improved coding efficiency are for me an added bonus. The question is how the <em>perfectionists</em> fit into this picture. This post bundled them with theorists, this was likely an oversimplification.</p>
<p>Implicit contexts in communication between programmers. There appears to be much more to explore here. Consider programming internet discussion forums (IMO, a Manhattan of communication skills, if you can make it there you will do really well in your project team). One can observe all kinds of context related bias issues (on the extreme end of this, some redditers do not consider reading to be a prerequisite to responding) or lack of context clarity (e.g.¬†heavily downvoted posts with no comments). Moving away from discussion groups, teams tend to create their own localized contexts (unique vocabulary, proprietary technical solutions) which is often not ideal. IMO, context clarity is to communication what referential transparency is to programming. IMO, context is to communication what understanding of causation is to empirical science.</p>
<p>Program synthesis, you know the thing that is going to render programmers obsolete: It appears that empirical vs formal translates to 2 different approaches to do program synthesis. I have listened to a few presentations about the formal approach. I expect probabilistic models, deep learning approaches to be more mainstream and prevalent. It is interesting how this will play out, but I do not feel qualified to discuss this in much depth. <em>‚ÄúThe effort of using machines to mimic the human mind has always struck me as rather silly. I would rather use them to mimic something better.‚Äù</em> (Dijkstra, of course). Quite possibly we will see an equivalent of empirical vs deductive play out in this area.</p>
<p>I am sure there are many more interesting angles to explore here.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>This inductive reasoning should be confused with mathematical (or structural in PLT) induction. Believe it or not it sometimes is.<a href="#fnref1" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn2" role="doc-endnote"><p>I use the term bias loosely as well. Scientists are concerned about bias in the design of empirical studies (which observations go in, how things are observed, etc), bias in how results are analyzed (e.g.¬†proper stratification). Bias is a <a href="https://en.wikipedia.org/wiki/Bias_(statistics)" target="_blank">statistics</a> term, <a href="https://en.wikipedia.org/wiki/List_of_cognitive_biases" target="_blank">psychology</a> term, all of this seems very relevant to programming.<a href="#fnref2" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn3" role="doc-endnote"><p>The term <em>formalism</em> has special meaning in mathematics, I use it colloquially (i.e.¬†all mathematics is formal). Examples of formal approaches popular among FP-ers could be equational reasoning, use of logical implication (e.g.¬†with Haskell type class constraints), use of mathematical or structural induction (e.g.¬†with inductive types like a functional list prove properties of, say, the implementation of <code>map</code>). Readers familiar with equational reasoning may agree with me about its similarity to a refactoring process where the developer mentally verifies that the new code is equivalent to the old. The line between formal and informal is sometimes thin.<a href="#fnref3" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn4" role="doc-endnote"><p>This is kinda fun to think about: we have only empirical evidence of mathematics itself being <em>correct</em>, we know we will never prove it formally. Mistakes in mathematics are extremely rare. However, we have a lot of empirical evidence of (past) <em>incorrectness</em> in various empirical sciences. I am a pragmatist enough to say that mathematics is correct, the rest looks good only until we learn more about it (just like bugs in software).<a href="#fnref4" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn5" role="doc-endnote"><p>Obviously, a well established empirical knowledge will not change for ages as well. Immutability is a result of getting things right, empirical method converges towards it, formal method starts there. My metaphor ‚Äúempirical is mutating in-place‚Äù is not perfect.<a href="#fnref5" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn6" role="doc-endnote"><p>Design patterns are an interesting bunch because they include some deductive work. E.g. factory decouples idiosyncratic aspects of object construction and decoupling is known to be beneficial. However, this is not that much different from, say, a wildlife biologist generalizing observed behavior of individuals to a whole species using a known symbiotic relationship in their argument.<br />
Hard to resist: They say symbiotic, we say decoupling‚Ä¶ ;)<a href="#fnref6" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn7" role="doc-endnote"><p>Notice, I did not say ‚Äúdebug the crap out of it‚Äù because that could imply that we are making code improvements.<a href="#fnref7" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn8" role="doc-endnote"><p>Rate of misdiagnosis for carpal tunnel is over 80% according to this article: <a href="https://www.carpalrx.com/post/carpal-tunnel-misdiagnosis" target="_blank">carpal tunnel misdiagnosis</a>. A very sad example for the past: it is now believed that a big cause of death during Spanish Flu was too much aspirin prescribed to treat the symptoms.<a href="#fnref8" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn9" role="doc-endnote"><p>See <a href="2022-03-13-ts-types-part6.html#a-walk-in-the-park" target="_blank">A walk in the park</a>, <a href="2022-01-09-ts-types-part4.html#phantom-types" target="_blank">phantom types</a>, <a href="2022-01-09-ts-types-part4.html#preventing-information-escape" target="_blank">existential types</a> in my TS series.<a href="#fnref9" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn10" role="doc-endnote"><p>A nice presentation that illustrates interacting with the type checker to write code is: <a href="https://youtu.be/DRq2NgeFcO0?t=356">Type-driven Development of Idris, Vect</a> on youtube. Adding type level information about the size of list constricts the solution space and creates a jigsaw puzzle.<a href="#fnref10" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn11" role="doc-endnote"><p>Sch√∂nfinkel (credited for the concept of combinatory logic) was Russian and worked with Hilbert in Germany. His original work was in German. Curry worked with Hilbert as well. The term has to do with building blocks (primitive ‚Äúfunctions‚Äù), aka S K I in SKI calculus. In LC, combinator is a lambda expression without free variables. Looks like a piece of a jigsaw puzzle to me.<a href="#fnref11" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn12" role="doc-endnote"><p>There are efforts to change that, e.g.¬†see this reddit: <a href="https://www.reddit.com/r/haskell/comments/xao5fy/announcing_practical_haskell_bits_initiative/" target="_blank">Practical Haskell Bits</a>.<a href="#fnref12" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn13" role="doc-endnote"><p>‚ÄúHaskell is the world‚Äôs finest imperative programming language‚Äù famous quote, probably originated in this paper <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/mark.pdf?from=https%3A%2F%2Fresearch.microsoft.com%2Fen-us%2Fum%2Fpeople%2Fsimonpj%2Fpapers%2Fmarktoberdorf%2Fmark.pdf" target="_blank">Simon Peyton Jones, Tackling the Awkward Squad</a><a href="#fnref13" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn14" role="doc-endnote"><p>I implemented a proprietary Haskell logger library at my work. It is interesting to think about what we want to observe when we FP. Standard logger libraries for, say, Java are ‚Äúobject-centric‚Äù and will allow configuration options based on which class spilled out info into the log. The library I implemented is ‚Äúdata-centric‚Äù and allows you to configure what data you want to see. FP is about clear inputs and outputs after all.<a href="#fnref14" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn15" role="doc-endnote"><p>I rewrote the side note and changed the exercises type based on comments from <a href="https://www.reddit.com/r/haskell/comments/yonk01/comment/ivk8pgr/?utm_source=share&amp;utm_medium=web2x&amp;context=3" target="_blank">u/kindaro</a> on reddit. Thanks!<a href="#fnref15" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn16" role="doc-endnote"><p>Exercise 2: You will need ‚Äúelementary‚Äù implementation for <code>length</code> (<code>length [] = 0; length (x:xs) = 1 + length xs</code>). Recursion step becomes induction step, the conservation law is an equation, you prove it by writing bunch of equations you get from the program itself.<br />
Exercise 3: Liquid Haskell annotation just spells out the law: <code>{-@ partitionEithers :: xs:[Either a b] -&gt; {ys: ([a], [b])  | (len xs) = (len (fst ys)) + (len (snd ys))} @-}</code>. As of this writing, you can try it online <a href="http://goto.ucsd.edu:8090/index.html#?demo=lenMapReduce.hs" target="_blank">here</a>.<br />
Here is a page with more information: <a href="https://github.com/rpeszek/experiments/tree/master/partition-eithers-excercise" target="_blank">partial solutions</a>.<a href="#fnref16" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn17" role="doc-endnote"><p>The association of pragmatism and empirical process is not unique to programmers, e.g.¬†if you google ‚Äúpragmatists vs formalists‚Äù today you will probably get a link to this quote ‚ÄúFormalism follows deductive approach whereas pragmatism applies empirical approach‚Äù from this legal philosophy paper: <a href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=3423036" target="_blank">Formalism vs.¬†Pragmatism in Legal Philosophy</a><a href="#fnref17" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn18" role="doc-endnote"><p>IMO, some experience with the formal is needed to better understand limitations of empirical. ‚ÄúProgram testing can be used to show the presence of bugs, but never to show their absence!‚Äù is a projection of that understanding onto programming.<a href="#fnref18" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn19" role="doc-endnote"><p>See <a href="2022-08-30-code-cognitiveload.html#extraneous-nature-of-abstraction" target="_blank">Extraneous nature of abstraction</a>.<a href="#fnref19" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn20" role="doc-endnote"><p>E.g. rewrite rules in Haskell.<a href="#fnref20" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn21" role="doc-endnote"><p>I dig a deep hole by using <a href="2022-08-30-code-cognitiveload.html#germane-and-intrinsic-load-of-fp" target="_blank">Free Monad</a> as example of such a line in my previous post.<a href="#fnref21" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn22" role="doc-endnote"><p>I am not a logician, I vaguely remember some versions of logic that allow multiple moralities, in particular one where there was <em>lax</em> in addition to <em>false</em>. Few (even) mathematicians will know these.<a href="#fnref22" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn23" role="doc-endnote"><p>See my posts about maybe and alternative overuse <a href="../tags/patterns-of-erroneous-code.html" target="_blank">patterns-of-erroneous-code</a><a href="#fnref23" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn24" role="doc-endnote"><p>See <a href="2022-08-30-code-cognitiveload.html#extraneous-nature-of-abstraction" target="_blank">Extraneous nature of abstraction</a> and its footnotes.<a href="#fnref24" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn25" role="doc-endnote"><p>I have discussed RNT (repetitive negative thinking) in my <a href="2022-08-30-code-cognitiveload.html" target="_blank">previous post</a> in my previous post.<a href="#fnref25" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn26" role="doc-endnote"><p>Concurrency in particular is a good example, deductive tools like TLA+ exist.<a href="#fnref26" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn27" role="doc-endnote"><p>It does seem that there is a more general disagreement about the limitations of empirical reasoning. Few people think about physics as a collection of simplified mathematical models that only approximate reality. Even some famous physicists (e.g.¬†Niels Bohr, if I remember correctly my reading about it) have apparently thought otherwise. Few people look deeply for bias in biological studies. <em>Hypotheses non fingo</em> is a rare position. 100% test coverage is in the ‚Äúwe tested it and it is correct‚Äù category.<a href="#fnref27" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn28" role="doc-endnote"><p>E.g. consider performance improvements that can be made to my <code>partitionEithers</code>. Note, Haskell code that is implemented using constructors and pattern matching only does not take advantage of rewrite rules that are already in place for combinators like <code>foldr</code>. Compare my code to the source of <a href="https://hackage.haskell.org/package/base-4.17.0.0/docs/src/Data.Either.html#partitionEithers" target="_blank"><code>paritionEithers</code></a> in <code>Data.Either</code>.<a href="#fnref28" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn29" role="doc-endnote"><p>If you use a PL with a proof assistant feature and write proofs for your programs, a refactoring will have additional cost of rethinking the proofs. This could be not an issue with Liquid Haskell, which does the proofs for you, but still may require extra work if the logic solver needs extra help. Consider refactoring my <code>partitionEithers</code> (annotated as before) to use <code>foldr</code> (which is incidentally what Base implementation uses), Liquid Haskell will tell you that your code is unsafe. It is interesting to note that QuickCheck-like property tests maintain very well.<a href="#fnref29" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn30" role="doc-endnote"><p>I will partially repeat a list I came up with in my last post. Example of non-symmetric equals is <code>java.sql.Timestamp</code> used with <code>java.sql.Date</code> or <code>java.util.Date</code>, these remain used as standard JDBC mappings for DB columns, the usage will show no deprecation warning. I wrote a blog series about <a href="../tags/TypeScript-Notes.html" target="_blank">TypeScript Types</a> and ended up presenting a lot of complexities and gotchas that probably surprise any TS developer.<br />
How do Hibernate users prevent this <a href="http://rpeszek.blogspot.com/2014/08/i-dont-like-hibernategrails-part-2.html" target="_blank">concurrency issue</a>?<br />
I remember Grails as a land mine of issues, I wrote an 11 part <a href="http://rpeszek.blogspot.com/2014/10/i-dont-like-hibernategrails-part-11_31.html" target="_blank">blog series</a> about it back in 2014.<br />
Returning to Java, its implementation of <code>Optional</code> is often <a href="https://www.sitepoint.com/how-optional-breaks-the-monad-laws-and-why-it-matters/" target="_blank">criticized</a>. Java array variance is fundamentally broken. Java Streams are broken as well: if you execute a stream twice the second attempt will fail. This (interesting take on referential transparency üôÇ) is bound to create interesting intermittent issues.<br />
I wrote a <a href="2022-08-30-code-cognitiveload.html#fnref19" target="_blank">footnote</a> in the previous post about Haskell ecosystem issues as well.<a href="#fnref30" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn31" role="doc-endnote"><p>On the subject of training, how do you teach, say, equational reasoning using any of the mainstream PLs? Is equational reasoning something that a software engineer will never need? I do use it.<a href="#fnref31" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn32" role="doc-endnote"><p>The main reason typically presented for this is: improved ability to make and measure observations. In programming, we witness things going south in front of our eyes, we typically do not need to wait for a new testing technology.<a href="#fnref32" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn33" role="doc-endnote"><p>In my last post I included a trivia about Turing‚Äôs original paper having several bugs and his adviser‚Äôs (Alonso Church‚Äôs) work being bug free. This is also related to the imperative vs denotative discussion. Here is the link to that footnote: <a href="2022-08-30-code-cognitiveload.html#fn11" target="_blank">Turing</a>. It should make us feel better about ourselves if Turing himself wrote bugs.<a href="#fnref33" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn34" role="doc-endnote"><p>The job market for functional programming jobs is, frankly, dismal. At the same time, languages like Haskell and Rust had topped the weekend use stats based on stackoverflow surveys. Repeating some of what I wrote <a href="2022-03-13-ts-types-part6.html#about-simplicity" target="_blank">here</a>: Haskell was firmly in the first position for the stackoverflow weekend use statistics for several years. Here is one link: <a href="https://stackoverflow.blog/2017/02/07/what-programming-languages-weekends/" target="_blank">2017</a>. In <a href="https://stackoverflow.blog/2019/10/28/research-update-coding-on-the-weekends/" target="_blank">2019</a> Rust moved ahead of Haskell. The job ranking (based on the UK‚Äôs <a href="https://www.itjobswatch.co.uk/jobs/uk/haskell.do" target="_blank">IT Jobs Watch</a>) put Haskell at 932 as of 2022/02/06. Haskell moved ahead of COBOL in that ranking in 2017. This ranking is possibly exaggerated too, lots of jobs list Haskell as good to have but will have you code in PHP. This bias exist for any language but is stronger for something like Haskell than say COBOL.<a href="#fnref34" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn35" role="doc-endnote"><p>I just love the the beginning story in <a href="https://people.mpi-sws.org/~dreyer/tor/papers/reynolds.pdf" target="_blank">Types, Abstraction and Parametric Polymorphism (John C. Reynolds)</a> paper.<a href="#fnref35" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
</ol>
</section>

    </section>
</article>

        </main>

        <footer>
             <span><a href="../atom.xml">Atom</a></span>
             <span><a href="../RSS.xml">RSS</a></span>
             <span>Site generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a></span>
        </footer>
    </body>
</html>
