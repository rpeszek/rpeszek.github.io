<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Infrequent, Pragmatic, Lambda Blog - Type Enthusiast's Notes about TypeScript. Part 2. Typing Honestly</title>
        <link rel="alternate" type="application/atom+xml" href="https://rpeszek.github.io/atom.xml" title="atom" />
        <link rel="alternate" type="application/rss+xml" href="https://rpeszek.github.io/RSS.xml" title="rss" />
        <!-- <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="atom"/>
        <link rel="alternate" type="application/rss+xml" href="/RSS.xml" title="rss"/> -->
        <link rel="stylesheet" href="../css/reset.css" />
        <link rel="stylesheet" href="../css/predefault.css" />
        <link rel="stylesheet" href="../css/default.css" />
        
        <link rel="stylesheet" href="../css/ts.css" />
        
        
    </head>
    <body>
        <header>
            <div class="motto">
                <a href="../">hmm >>= oh!</a>
            </div>
            <div class="logo">
                <a href="../">Infrequent, Pragmatic, Lambda Blog</a>
            </div>
            <nav>
                <!-- <a href="/">Home</a> -->
                <a href="../thoughts.html">Semiserious</a>
                <a href="../about.html">About</a>
                <!-- <a href="/contact.html">Contact</a> -->
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>Type Enthusiast's Notes about TypeScript. Part 2. Typing Honestly</h1>
            <article>
    <section class="header">
        Posted on December 24, 2021
        
            by Robert Peszek
        
        
        
        <div class="changelog"> <div>Revision History: <ul> <li> (2022.04.29 - 2022.05.29) Minor edits </li> <li> (2022.05.29) Draft warning removed </li> </ul> </div></div>
        
        
        <div class="info">Tags: <a title="All pages tagged 'TypeScript-Notes'." href="../tags/TypeScript-Notes.html">TypeScript-Notes</a></div>
        
    </section>
    <section>

    </section>
    <section>
        <div class="toc"><div class="header">Table of Contents</div>
<ul>
<li><a href="#nutshell">Nutshell</a></li>
<li><a href="#can-i-trust-the-types">Can I trust the types?</a></li>
<li><a href="#note-about-the-any-type">Note about the <code>any</code> type</a></li>
<li><a href="#casting-casting-in-a-bad-light">Casting <em>casting</em> in a bad light</a>
<ul>
<li><a href="#improving-office.js-with-type-predicates">Improving <em>office.js</em> with type predicates</a></li>
</ul></li>
<li><a href="#note-about-the-unknown-type">Note about the <code>unknown</code> type</a></li>
<li><a href="#honest-typing-conventions">Honest typing conventions</a>
<ul>
<li><a href="#referential-transparency">Referential Transparency</a></li>
<li><a href="#types-as-documentation">Types as documentation</a></li>
</ul></li>
<li><a href="#next-chapter">Next Chapter</a></li>
</ul>
</div>
<p><em>Please Leave Feedback in: <a href="https://github.com/rpeszek/rpeszek.github.io/discussions/1" target="_blank">git discussions</a></em></p>
<p>Previous post: <a href="2021-12-12-ts-types-part1.html" target="_blank">Part 1. Typing in Anger</a>.</p>
<p><strong>Disclaimers:</strong> (imagine this is a very small font, read it very fast in a half whisper)<br />
<em>I assume strict compiler flags are on, something you get by default with scaffolding, e.g. using <code>create-react-app my-project --template typescript</code> is close enough.<br />
The code examples have been tested with TypeScript v4.4.4 and v4.5.2.<br />
office.js examples are based on https://appsforoffice.microsoft.com/lib/1.1/hosted/office.js and <span class="citation" data-cites="types/office-js">@types/office-js</span><span class="citation" data-cites="1.0.221">@1.0.221</span> (these match the current scaffold for office.js/React).<br />
This post is a pandoc output of a markdown document and code examples are not interactive.<br />
Most of the code examples are published in <a href="https://github.com/rpeszek/ts-experiments/tree/master/ts-notes" target="_blank">ts-notes</a> folder in this github repo: <a href="https://github.com/rpeszek/ts-experiments" target="_blank">ts-experiments</a>.</em></p>
<p><strong>Motivating Quote for the series:</strong></p>
<blockquote>
<p>“TypeScript began its life as an attempt to bring traditional object-oriented types to JavaScript so that the programmers at Microsoft could bring traditional object-oriented programs to the web. As it has developed, TypeScript’s type system has evolved to model code written by native JavaScripters. The resulting system is <em>powerful, interesting and messy.</em>”</p>
</blockquote>
<p><em>From typescriptlang <a href="https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html" target="_blank">TypeScript for Functional Programmers</a></em></p>
<h2 id="nutshell">Nutshell</h2>
<p>This is the second post in the series devoted to types in TypeScript. In this series, I explore type-centric approaches to writing code and often push TS to its limits in doing so. I am writing these posts for like minded developers who are interested in types and either use or consider using TypeScript.</p>
<p>This post will cover TS’s type predicates, the notorious <code>any</code>, and its safer cousin the <code>unknown</code>. These are well known and heavily blogged topics. My goal is provide a little different perspective with a more type-centric view point.<br />
This series uses <em>office.js</em> as a source of code examples. This post examines the correctness of <em>office.js</em> types and fixes them using type predicates.<br />
My main code example is something I am excited about. It demonstrates a case where TS made me completely rethink a previously written JS code.<br />
I will discuss some safety concerns about <code>unknown</code> (no, this is not a typo, I mean the <code>unknown</code> type) and will set the stage for my future note about complexity of TS types.<br />
I will finish in the realm of coding conventions discussing transparent, self documenting type definitions.</p>
<h2 id="can-i-trust-the-types">Can I trust the types?</h2>
<p>I am going to discuss the obvious gotcha in a gradually typed language like TS: runtime values do not satisfy statically defined types.<br />
Despite it being an obvious concern, the issue is something a developer who spends most time in a statically typed language (e.g. me) will not have on his / her mind when working in TS.<br />
The following seem to be the prevalent reasons for why values do not match types: overconfident TS code (e.g. type casting, <code>any</code> type), issues with converted JavaScript (declaration files out of sync or containing otherwise incorrect definitions). I am going to show a real life (or close to real life) example of each.</p>
<p>The series started with an example defining the <code>Person</code> type, to avoid jumping back and forth I will repeat it here</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>type Person <span class="op">=</span> {<span class="dt">firstNm</span><span class="op">:</span> string<span class="op">,</span> <span class="dt">lastNm</span><span class="op">:</span> string} </span></code></pre></div>
<p>This will be a good conversation starter:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="co">//Questionable JSON parsing example</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="kw">const</span> p<span class="op">:</span> Person <span class="op">=</span> <span class="bu">JSON</span><span class="op">.</span><span class="fu">parse</span>(<span class="st">'&quot;John Smith&quot;'</span>)</span></code></pre></div>
<p>Your experience with consistency of JSON data may be different from mine. I rarely see JSON issues in a frontend - backend conversation. On the other hand, my experience with using 3rd party REST APIs is not exactly stellar. JSON data problems do happen.</p>
<p>The above code illustrates what I used to call ‘fail late’ and now I call ‘a type I cannot trust’ case. It is a nasty situation where runtime errors are nowhere near the actual problem. Looking at the example, <code>JSON.parse</code> function is declared to return the TS’s notorious <code>any</code> type. Using <code>any</code> bypasses type checking and the code assigns the result to <code>Person</code>. The actual run-time value of <code>p</code> will be a <code>string</code>, while the type checker is now convinced it is <code>p:Person</code>.</p>
<p>Now, look at the top rated answer in this stackoverflow: <a href="https://stackoverflow.com/questions/38688822/how-to-parse-json-string-in-typescript" target="_blank">how-to-parse-json-string-in-typescript</a>. It appears that the above code matches the top rated answer. Yes, safer approaches are available (look at less popular answers, we will discuss a much safer way as well).<br />
I am not claiming this to be a prevalent problem in TS code, but it is an interesting issue caused by the coexistence of the typed and the untyped.</p>
<p>Now, since I already may have angered a large part of the TS community (did I? I hope not.), let’s beat a little on <strong><em>office.js</em></strong>.</p>
<p><em>office.js</em> is a source of code examples for my series. Looking into <em>office.js</em> release history suggests that a bond between <em>office.js</em> and TypeScript. That bond developed very early. It looks like these projects grew up together. <em>office.js</em> might have even been one of these Microsoft projects that spearheaded the development of TS.</p>
<p><strong>Short Recap</strong> We are using <em>office.js</em> to interact with Outlook emails. <em>office.js</em> provides us with <code>item: Office.MessageRead</code> allowing us to retrieve data from an email opened for viewing in Outlook. <strong>(Recap End)</strong></p>
<p>I imagine it is not that uncommon for a TS library to have a non-nullable property that is undefined at runtime.<br />
The IntelliSense tells me that <code>item: Office.MessageRead</code> contains an overloaded <code>item.body.getTypeAsync</code> method. I was hoping to use it to retrieve the type (plain text vs html) of the email body.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>(method) Office<span class="op">.</span><span class="at">Body</span><span class="op">.</span><span class="fu">getTypeAsync</span>(options<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncContextOptions</span><span class="op">,</span> callback<span class="op">?:</span> ((asyncResult<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncResult</span><span class="op">&lt;</span>Office<span class="op">.</span><span class="at">CoercionType</span><span class="op">&gt;</span>) <span class="kw">=&gt;</span> <span class="kw">void</span>) <span class="op">|</span> <span class="kw">undefined</span>)<span class="op">:</span> <span class="kw">void</span> (<span class="op">+</span><span class="dv">1</span> overload)</span></code></pre></div>
<p><code>getTypeAsync</code> is undefined at runtime. It looks to me like the TS declaration files are not in sync with JavaScript. My hypothesis seems to be confirmed by the <a href="https://docs.microsoft.com/en-us/javascript/api/outlook/office.body?view=outlook-js-preview#getTypeAsync_callback_" target="_blank"><code>item.body.getTypeAsync</code></a> documentation suggesting that this method is available when email is open in compose mode (not when using <code>Office.MessageRead</code>). (I am using office online and the latest <em>office.js</em> as of the time of this writing.)<br />
<em>Please message me in git discussions if you think I am misrepresenting it.</em></p>
<p><em>It seems like <em>office.js</em> types are a little off.</em></p>
<p>We should look at the type definition of the <em>office.js</em> <a href="https://docs.microsoft.com/en-us/javascript/api/outlook/office.item?view=outlook-js-preview" target="_blank"><code>Office.context.mailbox.item</code></a> a little closer.<br />
This property is overloaded to be one of the following types (let me call them <em>facets</em>):</p>
<blockquote>
<p><code>Office.AppointmentCompose</code> (composing calendar entry)<br />
<code>Office.AppointmentRead</code> (reading calendar entry)<br />
<code>Office.MessageCompose</code> (composing email)<br />
<code>Office.MessageRead</code> (reading email)</p>
</blockquote>
<p>These <em>facet</em> types are all different. For example, to get email subject you use <code>item.subject:string</code> if you are working with <code>Office.MessageRead</code> or <code>item.subject:Office.Subject</code> if you are working with <code>Office.MessageCompose</code>.<br />
<code>Office.Subject</code> contains <code>getAsync</code>, <code>setAsync</code> methods and is absolutely not a <code>string</code>.</p>
<p>The type of <code>item</code> provided by <em>office.js</em> is not, as I would expect:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="co">//Type I expected</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>AppointmentCompose <span class="op">|</span> AppointmentRead <span class="op">|</span> MessageCompose <span class="op">|</span> MessageRead</span></code></pre></div>
<p>Rather it is closer (I have not listed all the <code>&amp;</code>-s) to:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="co">//Actual Type with some &amp; parts removed </span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>AppointmentCompose <span class="op">&amp;</span> AppointmentRead <span class="op">&amp;</span> MessageCompose <span class="op">&amp;</span> MessageRead</span></code></pre></div>
<p>Basically, the type <em>office.js</em> chose for <code>item</code> mashes all the available properties, methods, overloads into one type. This is simply an incorrect type for the <code>item</code> property. Runtime values do not satisfy the <em>intersection</em> type, they satisfy the <em>union</em> type. Type checked programs will fail at runtime. <em>office.js</em> type declarations are incorrect.</p>
<p><em>office.js types are off for sure.</em></p>
<p>In a weird way, this explains why the undefined <code>item.body.getTypeAsync</code> has not been noticed. Without a corrective reassignment to, say, <code>Office.MessageRead</code> many other methods are <code>undefined</code> at runtime and it is harder to single this particular one out.</p>
<p>Gradual typing over the wild-west JS has to come with maintenance challenges.<br />
Nonetheless this is surprising. What are the types good for if they’re not accurate?</p>
<blockquote>
<p>“You take the blue pill — the story ends, you wake up in your bed and believe whatever you want to believe.<br />
You take the red pill — you stay in Wonderland, and I show you how deep the rabbit hole goes”</p>
</blockquote>
<p><em>Morpheus about not believing types in a gradually typed language</em><br />
<em>… nightmares of JavaScript running on my walls and ceilings make me wake up screaming</em></p>
<h2 id="note-about-the-any-type">Note about the <code>any</code> type</h2>
<p>My first example in this post used the infamous <code>any</code> type. Let’s have a closer look.</p>
<p><code>any</code> type is crazy. It behaves like the <em>top</em> (you can assign any other type to it). It also behaves like the <em>bottom</em> (it can be assigned to any other type, maybe except of <em>never</em>). Ideally, the bottom type is empty, this one clearly is not.</p>
<p><em>As a result, any value can have any type.</em></p>
<p>We should have some fun with this.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="co">//express yourself with _any_ (notice no casting, only assignments)</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="kw">const</span> sad<span class="op">:</span> any <span class="op">=</span> <span class="st">&quot;emptiness and sadness&quot;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a><span class="kw">const</span> sadVoid<span class="op">:</span> <span class="kw">void</span> <span class="op">=</span> sad</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a><span class="kw">const</span> myCallback <span class="op">=</span> (n<span class="op">:</span> number)<span class="op">:</span> <span class="kw">void</span> <span class="kw">=&gt;</span> {</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>    <span class="cf">return</span> sadVoid<span class="op">;</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>}</span></code></pre></div>
<p>You can have your own favorite <code>null</code> that is not <code>null</code> value, you can <em>define</em> your own <code>undefined</code>. Sky and your creativity are the limits. I will spoil this party and say that I do not recommend doing it. Oh, maybe just a little. Well OK, one more:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">const</span> sassy<span class="op">:</span> any <span class="op">=</span> {<span class="dt">netWorth</span><span class="op">:</span> <span class="st">&quot;billion dollars&quot;</span><span class="op">,</span> <span class="dt">popularityLevel</span><span class="op">:</span> <span class="st">&quot;celebrity&quot;</span>}</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="kw">const</span> sassyNull<span class="op">:</span> <span class="kw">null</span> <span class="op">=</span> sassy</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a><span class="kw">const</span> p<span class="op">:</span> Person <span class="op">|</span> <span class="kw">null</span> <span class="op">=</span> sassyNull</span></code></pre></div>
<p>A bottom that is not empty will cause the language to be unsound. Allowing all values in a bottom type, I would call it insane.<br />
However, using an <em>any</em> type similar to TS’s seems to be a common practice in gradually typed languages (e.g. Python does it too).<br />
Using <code>any</code> is like saying “hey, TS, please suspend type checking, I know what I am doing”. This is the antithesis of type safety, but what else can TS do and maintain JS compatibility?</p>
<p>Actually, TS has a very clever solution for this, it is described in the following sections.<br />
I view <code>any</code> as a form of type coercion or casting.</p>
<h2 id="casting-casting-in-a-bad-light">Casting <em>casting</em> in a bad light</h2>
<p>I will use the term casting and type coercion interchangeably. TypeScript documentation also uses the term <em>type assertion</em>. I view the <code>any</code> type to be in the same boat as well (an implicit type coercion).<br />
TS uses the <code>t as T</code> or <code>&lt;T&gt; t</code> syntax to cast expression <code>t</code> into type <code>T</code>, e.g. <code>iAmSureIsString as string</code>.<br />
(IMO, the second notation, <code>&lt;T&gt; t</code>, is somewhat unfortunate as it is very similar to type application and generic function declaration e.g. <code>const f = &lt;T&gt;():T</code> declares, <code>&lt;T&gt;f()</code> casts, <code>f&lt;T&gt;()</code> applies. I recommend the <code>v as T</code> syntax to make casting more explicit and searchable in your code.)</p>
<p> <div class="side-note"><strong>Type enthusiast’s note on casting at large:</strong><br />
Typically (and rightly) casting is considered to be a last resort, <em>only cast if you must</em>.</p>
<p>With more involved types it is often harder to write code that type checks. That increases the appeal of casting or finding some other alternatives for nudging the type checker into agreeing.<br />
Some languages offer the ability to write a program to persuade the type checker about type equality (write actual <em>proof of type equality</em>). This is an advanced feature and is available in only a few languages (e.g. Coq, Idris, Haskell). Writing such programs is often challenging or even impossible. (I consider writing such proofs to be one of the highest level “type games” that a developer can play. It is both a challenge and fun. A great intro is <a href="https://www.manning.com/books/type-driven-development-with-idris" target="_blank">TDD with Idris</a>)</p>
<p>There is an alternative to type coercion that allows programs to type check but will throw an exception when executed.<br />
This can be useful for interacting with the type checker when writing code. We have seen a TS version of this already, function <a href="2021-12-12-ts-types-part1.html#type-holes" target="_blank"><code>_&lt;T&gt;(): T</code></a>, defined in my previous post and stolen from <a href="https://dev.to/gcanti/type-holes-in-typescript-2lck" target="_blank">Type holes in TS</a>. Such programming practice is foreign to most languages but becomes very convenient when working with more involved types. We are using it in this series.  </div></p>
<p>Let’s beat on <em>office.js</em> some more. <a href="https://docs.microsoft.com/en-us/javascript/api/outlook/office.item" target="_blank">Here</a> is a piece <em>office.js</em> documentation about (you guessed it, this post is so very predictable) the <a href="https://docs.microsoft.com/en-us/javascript/api/outlook/office.item" target="_blank"><code>Office.context.mailbox.item</code></a>:</p>
<blockquote>
<p><em>If you want to see IntelliSense for only a specific type or mode, <strong>cast</strong> this item to one of the following:</em><br />
<em><code>AppointmentCompose</code></em><br />
<em><code>AppointmentRead</code> …</em></p>
</blockquote>
<p>TS offers a neat alternative to casting. I will explain it by <em>not</em> following the <em>office.js</em> documentation ;)</p>
<p>As I indicated already, I can interact with outlook email using <code>Office.context.mailbox.item</code>. However, <code>item</code> property is overloaded into several types discussed in the previous section (I called them <em>facets</em>):</p>
<p>The legacy code I am currently re-implementing at work is retrieving the email subject using <code>item.subject</code> and checking what kind of <code>item.subject</code> it is (a string, has asyc methods, etc) and using it accordingly. It does a similar <em>“check before you use”</em> game to retrieve <code>to</code>, <code>from</code>, <code>cc</code> and other email information.<br />
Such an approach is typical, almost idiomatic to JS. It is also hard to maintain as making changes directed at one facet can easily break the other facets. And you can test your heart out on all emails you can think about and your app will still crash and burn if used with an office calendar appointment.</p>
<p>So what is the new TS-idiomatic way to do it?  TS has the <code>is</code> types.</p>
<h3 id="improving-office.js-with-type-predicates">Improving <em>office.js</em> with type predicates</h3>
<div class="sourceCode" id="cb8"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="im">export</span> <span class="kw">const</span> isMessageRead <span class="op">=</span> (item<span class="op">:</span> any)<span class="op">:</span> item is Office<span class="op">.</span><span class="at">MessageRead</span> <span class="kw">=&gt;</span> {</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>    <span class="cf">return</span> (item<span class="op">.</span><span class="at">itemType</span> <span class="op">===</span> Office<span class="op">.</span><span class="at">MailboxEnums</span><span class="op">.</span><span class="at">ItemType</span><span class="op">.</span><span class="at">Message</span>) <span class="op">&amp;&amp;</span> item<span class="op">.</span><span class="at">getAttachmentsAsync</span> <span class="op">===</span> <span class="kw">undefined</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>} </span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>  </span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a><span class="im">export</span> <span class="kw">const</span> isMessageCompose <span class="op">=</span> (item<span class="op">:</span> any)<span class="op">:</span> item is Office<span class="op">.</span><span class="at">MessageCompose</span> <span class="kw">=&gt;</span> {</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>    <span class="cf">return</span> (item<span class="op">.</span><span class="at">itemType</span> <span class="op">===</span> Office<span class="op">.</span><span class="at">MailboxEnums</span><span class="op">.</span><span class="at">ItemType</span><span class="op">.</span><span class="at">Message</span>) <span class="op">&amp;&amp;</span> item<span class="op">.</span><span class="at">getAttachmentsAsync</span> <span class="op">!==</span> <span class="kw">undefined</span> </span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a>} </span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a>declare <span class="kw">function</span> <span class="fu">doSomethingWithViewedEmail</span>(item<span class="op">:</span> Office<span class="op">.</span><span class="at">MessageRead</span>)<span class="op">:</span> <span class="kw">void</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a>declare <span class="kw">function</span> <span class="fu">doSomethingWithComposedEmail</span>(item<span class="op">:</span> Office<span class="op">.</span><span class="at">MessageCompose</span>)<span class="op">:</span> <span class="kw">void</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a>declare <span class="kw">function</span> <span class="fu">onlyEmailEntriesAreSupported</span>()<span class="op">:</span> <span class="kw">void</span></span></code></pre></div>
<p>(OK, checking <code>getAttachmentsAsync</code> is ugly, office.js could provide some nicer and more stable way to identify the exact <code>item</code> type. This is still not bad. Let’s move on.)</p>
<p><code>doSomethingWithViewedEmail</code> and <code>doSomethingWithComposedEmail</code> can now be coded with confidence (if I trust <em>office.js</em> types) following the corresponding <code>MessageRead</code> or <code>MessageCompose</code> types. IntelliSense makes writing these a breeze and the code is very clean. E.g., <code>subject</code> is just a <code>string</code> in <code>MessageRead</code>.</p>
<p>I can use these without any casting:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="co">//'unknown' replaces incorrect office.js type (see previous section). </span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a><span class="kw">const</span> item<span class="op">:</span> unknown <span class="op">=</span> Office<span class="op">.</span><span class="at">context</span><span class="op">?.</span><span class="at">mailbox</span><span class="op">?.</span><span class="at">item</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a><span class="cf">if</span>(<span class="fu">isMessageRead</span>(item)) {</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>  <span class="co">//doSomethingWithComposedEmail(item) //this will not type check!</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>  <span class="fu">doSomethingWithViewedEmail</span>(item)    </span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>} <span class="cf">else</span> <span class="cf">if</span> (<span class="fu">isMessageCompose</span>(item)) {</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>  <span class="co">//doSomethingWithViewedEmail(item) //this will not type check!</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a>  <span class="fu">doSomethingWithComposedEmail</span>(item)  </span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a>} <span class="cf">else</span> {   </span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true"></a>  <span class="fu">calendarEntriesAreNotSupported</span>()</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true"></a>}</span></code></pre></div>
<p>This is a really nice, bravo TypeScript! Simple to use, yet very useful.</p>
<p>It is also IMO a very interesting case of TS making a bigger impact on how we actually code. <em>“Check before you use”</em> game becomes type assisted and happens on a coarser scale of <code>item</code> types instead of single (e.g. the email <em>subject</em>, <em>from</em>, <em>cc</em>, etc.) properties.<br />
This adds a lot of clarity to the code. TS types not just check my code, types change how I code!</p>
<p><code>t is T</code> type is one of the TypeScript <a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html" target="_blank">narrowing</a> tools. The documentation refers to it as a <em>type predicate</em> or a <em>type guard</em> (a more general term).<br />
IMO, the idea of a middle ground between type checked safety and unsafe type coercion is brilliant.<br />
It is something that sits a half way between a cast and a type equality proof.<br />
This will probably influence other languages (e.g. here is <a href="https://www.python.org/dev/peps/pep-0647/" target="_blank">enhancement proposal for Python</a>).</p>
<p>The syntax <code>t is T</code> is interesting, it clearly borrows from dependently typed languages. The value <code>t</code> appears next to the type <code>T</code> and comes from the earlier part of the declaration. This also somewhat justifies the existence of otherwise cumbersome parameter names in type definitions (something I complained about in my <a href="2021-12-12-ts-types-part1.html#office.js.-using-ts-in-anger" target="_blank">previous post</a>).</p>
<p>I hope the TS community develops a healthy aversion to casting. Why would you use a type checker if you keep subverting it? I also hope that exporting functions returning type predicates will become a standard practice for APIs.</p>
<p> <div class="side-note"><strong>Use of <code>any</code> in type predicates</strong><br />
Arguably, a safer approach was to define <code>isMessageRead</code> and <code>isMessageCompose</code> using a parameter type that is more restrictive than <code>any</code>.<br />
My goal was to keep this example very simple and avoid introducing a <code>CorrectedOfficeItem</code> type to fix <em>office.js</em> typing. In real code, I would opt in for introducing the corrected type. Linked github repo defines and uses <code>CorrectedOfficeItem</code>.<br />
However, using <code>any</code> in type predicate implementations appears to be a common practice. Implementing a type predicate typically requires checking for existence of object properties and <code>any</code> provides access to these.<br />
My suggestion is to avoid type guards in certain places, e.g. in generics. We want generics to be generic.  </div></p>
<h2 id="note-about-the-unknown-type">Note about the <code>unknown</code> type</h2>
<p>This post started with a use of the unsafe <code>JSON.parse</code>. I am quite sure that if TypeScript could travel back in time <code>JSON.parse</code> would return <code>unknown</code> instead of <code>any</code>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="im">export</span> <span class="kw">const</span> safeParseJSON <span class="op">:</span> (_<span class="op">:</span> string) <span class="kw">=&gt;</span> unknown <span class="op">=</span> <span class="bu">JSON</span><span class="op">.</span><span class="fu">parse</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a><span class="kw">const</span> isPerson <span class="op">=</span> (p<span class="op">:</span> any)<span class="op">:</span> p is Person <span class="kw">=&gt;</span> </span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>        <span class="kw">typeof</span> p<span class="op">.</span><span class="at">firstNm</span> <span class="op">===</span> <span class="st">'string'</span> <span class="op">&amp;&amp;</span> <span class="kw">typeof</span> p<span class="op">.</span><span class="at">lastNm</span> <span class="op">===</span> <span class="st">'string'</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a><span class="kw">const</span> possiblyPerson <span class="op">=</span> <span class="fu">safeParseJSON</span>(<span class="st">'&quot;John Smith&quot;'</span>) </span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a><span class="cf">if</span> (<span class="fu">isPerson</span>(possiblyPerson)) {</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a>    <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(possiblyPerson<span class="op">.</span><span class="at">firstNm</span>)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true"></a>} <span class="cf">else</span> {</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true"></a>    <span class="co">// console.log(possiblyPerson.firstNm) //does not compile</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true"></a>}</span></code></pre></div>
<p><code>unknown</code> is a newer and a safer alternative to <code>any</code>.</p>
<p><code>unknown</code> type is (only) the top type (you can assign anything to it but you cannot assign it to anything else, maybe except for <code>any</code>). This is a much better safety than being both the <em>top</em> and the <em>bottom</em>. Compared to <code>any</code> it is more cumbersome to use but significantly safer.</p>
<p>Let’s criticize the <code>unknown</code> a bit. A rough view (IMO) of what type safety is: an ability to <em>separate apples from oranges</em>. If you can assign both an apple to <code>unknown</code> and an orange to <code>unknown</code> then they are no longer separated.<br />
What makes this worse in TS, is its occasional tendency to widen return types to <code>unknown</code>. TS tends to do that if it cannot find a more precise return type, when it tries to apply subtying rules to things like functions, or when it gets confused. We saw two examples of this in the last post:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="co">//compilation bug allows this incorrect code to compile with</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a><span class="co">// emailBody4: unknown</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a><span class="co">//this code will accutally work at runtime because 'crazyConfig' ends up not being used </span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a><span class="kw">const</span> crazyConfig <span class="op">:</span> (_<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncResult</span><span class="op">&lt;</span>string<span class="op">&gt;</span>) <span class="kw">=&gt;</span> <span class="kw">void</span> <span class="op">=</span> x <span class="kw">=&gt;</span> <span class="st">&quot;&quot;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a><span class="kw">const</span> emailBody4 <span class="op">=</span> <span class="cf">await</span> <span class="fu">officePromise</span> (<span class="fu">curry3</span>(item<span class="op">.</span><span class="at">body</span><span class="op">.</span><span class="at">getAsync</span>)(Office<span class="op">.</span><span class="at">CoercionType</span><span class="op">.</span><span class="at">Html</span>)(crazyConfig)) </span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a><span class="co">//test: (a: unknown) =&gt; (b: unknown) =&gt; unknown</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a><span class="kw">const</span> test <span class="op">=</span> <span class="fu">curry</span>({} <span class="im">as</span> any)</span></code></pre></div>
<p>Also, notice <code>unknown</code> in some of the <a href="2021-12-12-ts-types-part1.html#compilation-bloopers" target="_blank">blooper</a> examples from the previous post:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="co">//these should not compile but they do. Names are consitent with previous post and the linked github repo</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a><span class="co">//const nonsense2: &lt;T1, T2, R&gt;(a: (ax: T1, bx: T2) =&gt; R) =&gt; (b: unknown) =&gt; (a: T1) =&gt; (b: T2) =&gt; R</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a><span class="kw">const</span> nonsense2 <span class="op">=</span> <span class="fu">curry</span>(curry) </span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a><span class="co">//const nonsense3: &lt;T1, T2, T3, R&gt;(a: (ax: T1, bx: T2, cx: T3) =&gt; R) =&gt; (b: unknown) =&gt; (a: T1) =&gt; (b: T2) =&gt; (c: T3) =&gt; R</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a><span class="kw">const</span> nonsense3 <span class="op">=</span> <span class="fu">curry</span>(curry3)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a><span class="co">//const nonsense4: &lt;T1, T2, R&gt;(a: (ax: T1, bx: T2) =&gt; R) =&gt; (b: unknown) =&gt; (b: unknown) =&gt; (a: T1) =&gt; (b: T2) =&gt; R</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a><span class="kw">const</span> nonsense4 <span class="op">=</span> <span class="fu">curry</span>(<span class="fu">curry</span>(curry))</span></code></pre></div>
<p>and we will encounter more examples of <em>unknown widening</em> in future notes. I would be happier if many of these examples resulted in a compilation error. Current status quo reduces safety of TS code.</p>
<p>Let’s look at how <code>unknown</code> makes things like <code>===</code> more complex. I really love the fact that this code (a contrived example but generalizes easily to real situations) does not compile:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="co">//Compilation error:</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a><span class="co">//This condition will always return 'false' since the types 'string' and 'number' have no overlap.</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a><span class="st">&quot;some email body&quot;</span> === <span class="dv">1</span> </span></code></pre></div>
<p>However, this does compile:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a>(<span class="st">&quot;some email body&quot;</span> <span class="im">as</span> unknown) <span class="op">===</span> <span class="dv">1</span></span></code></pre></div>
<p>and so does this:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a>emailBody4 <span class="op">===</span> <span class="dv">1</span></span></code></pre></div>
<p>Let’s bring in the type hole <a href="2021-12-12-ts-types-part1.html#type-holes" target="_blank"><code>_&lt;T&gt;(): T</code></a> from the last post. The type hole is a convenient way to ask the compiler type questions.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="co">//hovering over res and _ allows me to see the typing of '===`</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a><span class="kw">const</span> res <span class="op">=</span> <span class="fu">_</span>() <span class="op">===</span> <span class="fu">_</span>()</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>(<span class="dv">1</span> <span class="im">as</span> <span class="dv">1</span>) <span class="op">===</span> <span class="fu">_</span>()</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a><span class="fu">_</span>() <span class="op">===</span> (<span class="dv">1</span> <span class="im">as</span> <span class="dv">1</span>)</span></code></pre></div>
<p>So the “imaginary” type signature of <code>===</code> is:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>declare <span class="kw">function</span> <span class="fu">eqeqeq</span>(a<span class="op">:</span> unknown<span class="op">,</span> b<span class="op">:</span> unknown)<span class="op">:</span> boolean</span></code></pre></div>
<p>Except</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="fu">eqeqeq</span>(<span class="st">&quot;some text&quot;</span><span class="op">,</span> <span class="dv">1</span>) <span class="co">//compiles</span></span></code></pre></div>
<div class="sourceCode" id="cb19"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="st">&quot;some text&quot;</span> <span class="op">===</span> <span class="dv">1</span> <span class="co">//does not compile</span></span></code></pre></div>
<p>In fact, <code>===</code> <em>does not have a type</em>. It is a built-in JS operator. TS applies semantic narrowing rules to the code that uses it.<br />
This complex approach is needed to provide type safety while maintaining compatibility with JS.<br />
TS’s semantic rules prevent certain types like <code>someText === someNumber</code> from compiling, except, this safety is somewhat fragile and breaks when <code>someText</code> or <code>someNumber</code> are accidentally widened to <code>unknown</code> by the type inference. TS uses a similar approach for other built-in JS operators. (We will discuss the crazy <code>===</code> semantics in a deeper detail in the next post.)</p>
<p><strong>General safety concerns about the top:</strong> Developers, like me, who had spent decades working in languages like Java and then switched to a typed FP language see immediate safety benefits just because there isn’t any top type. The concern about <code>unknown</code> is that it is used with many JS functions and operators. Such use is not type safe, similarly to how Java’s <code>Object</code> methods are not type safe.<br />
From the type safety point of view, these JS functions and operators are not implemented well either. Consider for example <code>JSON.stringify</code> which accepts <code>any</code>. Does this expression (it returns <code>undefined</code>) make much sense to you: <code>JSON.stringify(() =&gt; {})</code>?<br />
Generic functions lose safety too, generics are not <em>generic</em> if a generically typed function parameter can use a <em>specific</em> JS function (like the <code>JSON.stringify</code> function).</p>
<p>Something like <code>unknown</code> is probably the only way for TS to achieve JS compatibility, nonetheless <code>unknown</code> is not ideal.</p>
<p>I will come back to this discussion again, I plan to discuss the complexity of TS types. I will also return to the <code>unknown</code> type itself in the future in a more theoretical setting.</p>
<h2 id="honest-typing-conventions">Honest typing conventions</h2>
<p>These notes will be a little ranty (you’ll probably ask: “Did you read your other notes?”). Any coding convention is effectively a hand waving rant. That is why we use types, so we can rant less!</p>
<p>One of my former colleagues liked to use the phrase “gentlemen’s agreement”. It means an agreement between developers to self impose certain limitations on the code they write. These limitations are not enforced by the compiler, only by developers who agree to abide by the set rules. Coding guidelines, design patterns, you know what I am talking about.</p>
<p>There is a term in Programming Language Theory called <em>parametricity</em>. Roughly speaking, a language that supports <em>parametricity</em> can assure that a generic function cannot discover what is the type behind a type variable. Remove the top and the bottom from the language too. You are left with very precise types. As an example,</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a>declare <span class="kw">function</span> someName<span class="op">&lt;</span>T<span class="op">&gt;</span>(t<span class="op">:</span>T)<span class="op">:</span> T</span></code></pre></div>
<p>could be only implemented as an identity. Incidentally, there are a few languages that support strict parametricity and a few that come very close, for mainstream languages, <em>parametricity</em> is an gentlemen’s agreement.</p>
<p>Can you write a whole single page app in TS and give it that signature? I bet you can.<br />
We would probably not call it a type-lie. Calling it not descriptive would probably be more accurate. Or, maybe just not the best design?<br />
If some type definitions are better than others, which of them are better? Apps are written so the decisions are being made, but based on what?</p>
<p>I will give you my very type centric view of programming:</p>
<ol type="1">
<li>Well written program means well typed. Well typed means the types express what is happening.<br />
</li>
<li>Types are more fundamental than a programming language.</li>
<li>Coding conventions supplement the language in implementing typing concepts.</li>
<li>TS (or any programming language) programming needs a balancing act. My approach for writing TS is to balance principled and safe with approachable and informative. That balance is subjective and project specific, my balance point may differ from yours.</li>
</ol>
<p><strong>Expanding on 2:</strong><br />
TS type checks my code, I type check TS (last post). A library (e.g. <em>office.js</em>) provides types, I type check these types and fix some of them (this post). Developer interventions are needed. Understanding of types does not change with a programming language environment. The cumbersomeness of their use does. TS is, comparatively speaking, not that bad.</p>
<p><strong>Expanding on 3:</strong><br />
In TS, almost any program can have almost any type. I can implement</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="kw">function</span> <span class="fu">program</span>()<span class="op">:</span> <span class="kw">void</span> {<span class="op">...</span>}</span></code></pre></div>
<p>and do almost anything I want in that code.<br />
It would not be very clear if most of my types looked like this. There needs to be some coding convention that discourages such code.<br />
Enforcing some level of parametricity when implementing generics is another example of a coding convention.</p>
<p><em>The goal is to move from designing programs to designing types.</em><br />
<em>This post suggests that types are used to define coding conventions.</em></p>
<p>So, besides guarding parametricity, what else can we do? Here are some bootstrapping ideas:</p>
<h3 id="referential-transparency">Referential Transparency</h3>
<p>Referential Transparency is an FP topic but is also very relevant to types and crucially important to the discussion of “type honesty”.</p>
<p>A function is referentially transparent if it does the same thing every time it is called. Referential transparency comes with clear type signatures. The output needs to be a function of the inputs and of nothing else. You can do things like curry or partially apply, but you cannot say, retrieve the current time and act on it (that time parameter would need to be provided as input).<br />
For <code>program:() =&gt; void</code> to be referentially transparent would mean that the implementation does not do anything, just returns.<br />
IMO well written programs identify and separate the referentially transparent parts.</p>
<p>In TS, referential transparency is a coding convention. I will use <em>React.js</em> example to demonstrate this. Readers not familiar with React should think about creating a function from some model (<code>Person</code> in this example) to an actual part of the HTML DOM. Here is my example of a vanilla React component type (I like React to be vanilla as much as possible)</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="kw">const</span> PersonCard<span class="op">:</span> ({ model<span class="op">,</span> onChange }<span class="op">:</span> {</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a>    <span class="dt">model</span><span class="op">:</span> Person<span class="op">;</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a>    <span class="dt">onChange</span><span class="op">:</span> (<span class="dt">_</span><span class="op">:</span> Person) <span class="kw">=&gt;</span> <span class="kw">void</span><span class="op">;</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a>}) <span class="kw">=&gt;</span> JSX<span class="op">.</span><span class="at">Element</span></span></code></pre></div>
<p>Hopefully, the implementation does not use any hooks, it only uses the parameters (I call them setters<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> and getters) to create bits of HTML with event handlers. This would be an example of a referentially transparent React type. It also would be an example of a very explicit type that is very “honest”.</p>
<p> <div class="side-note"><strong>FP side notes:</strong> Such approach is not novel at all (e.g. Elm uses a similar approach, only not as a coding style but as its architecture).<br />
 </div></p>
<p>Many developers will very much disagree with me on this. E.g. many will prefer to encapsulate state handling inside components. I do not intend to argue which approach is better. I will just point out that encapsulation is secretive in the type definition and I am looking for transparency here. Many parts of React code will require some use of hooks, my approach is to do that only when I have to and to keep the hooks outside of my main components. It is not about not using hooks, it is about not having them all over the code base. The goal is to make things very type-explicit. It is an IMO.</p>
<p>Such type is also self documenting.</p>
<p><strong>Expanding on my point 4:</strong> IMO, the best communication tools for developers and the best documenting tools for the code, in that order, are: <em>types and tests</em>. I will only focus on the first.</p>
<h3 id="types-as-documentation">Types as documentation</h3>
<p>When I write TS, I want my types to be very informative. For example, compare these two slightly modified versions of the above React component:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="kw">const</span> PersonCard<span class="op">:</span> React<span class="op">.</span><span class="at">FC</span><span class="op">&lt;</span>{</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a>    <span class="dt">model</span><span class="op">:</span> Person<span class="op">;</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a>    <span class="dt">onChange</span><span class="op">:</span> (<span class="dt">_</span><span class="op">:</span> Person) <span class="kw">=&gt;</span> <span class="kw">void</span><span class="op">;</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a>}<span class="op">&gt;</span></span></code></pre></div>
<p>vs:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="kw">const</span> PersonCard<span class="op">:</span> React<span class="op">.</span><span class="at">FC</span><span class="op">&lt;</span>Props<span class="op">&gt;</span> <span class="co">//Commonly used 'Props' type alias defined next to 'PersonCard'</span></span></code></pre></div>
<p>I like the first one better.<br />
And, I am not suggesting the names for the setters and getters here. I would be equally happy with this:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a><span class="kw">const</span> PersonCard<span class="op">:</span> React<span class="op">.</span><span class="at">FC</span><span class="op">&lt;</span>{</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a>    <span class="dt">get</span><span class="op">:</span> Person<span class="op">;</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a>    <span class="dt">set</span><span class="op">:</span> (<span class="dt">_</span><span class="op">:</span> Person) <span class="kw">=&gt;</span> <span class="kw">void</span><span class="op">;</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true"></a>}<span class="op">&gt;</span></span></code></pre></div>
<p>There is no safety benefit in doing this. Communication, documentation and accessibility are the only goals.<br />
I like to think about a modernized definition of the KISS principle: “Simple” is a lot of very transparent types.</p>
<h2 id="next-chapter">Next Chapter</h2>
<p>There are parts of TS that I absolutely adore and I will talk about them. The complexity of TS types is another big topic to discuss. Complexity causes compilation issues (we will encounter some new bloopers) and makes the language hard to use.</p>
<p>Here is the link: <a href="2022-01-03-ts-types-part3.html" target="_blank">Part 3</a>.</p>
<p>I am working on these notes during the 2021 holiday season. <em>Merry Christmas, Happy New Year!</em> Stay happy and healthy!</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>What I am achieving here is not the full referential transparency. Setters are not referentially transparent, referentially transparent function that returns <code>void</code> cannot do anything. However, This construction is still very explicit.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

    </section>
</article>

        </main>

        <footer>
             <span><a href="../atom.xml">Atom</a></span>
             <span><a href="../RSS.xml">RSS</a></span>
             <span>Site generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a></span>
        </footer>
    </body>
</html>
