<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Infrequent, Pragmatic, Lambda Blog</title>
        <link>https://rpeszek.github.io/</link>
        <description><![CDATA[Infrequent, Pragmatic, Lambda Blog Feed]]></description>
        <atom:link href="https://rpeszek.github.io//RSS.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Mon, 28 Jun 2021 00:00:00 UT</lastBuildDate>
        <item>
    <title>Arming polysemy with Arrows</title>
    <link>https://rpeszek.github.io//posts/2021-06-28-polysemy-arrows.html</link>
    <description><![CDATA[<article>
    <section class="header">
        Posted on June 28, 2021
        
            by Robert Peszek
        
        
          <br /> Last Modified on Jul 04, 2021
        
        
        <div class="changelog"> <div>Revision History: <ul> <li> (2021.07.02) Added Semantic Note in <a href="#creating-arrow-effects">Creating Arrow Effects</a> section </li> <li> (2021.07.02-05) Added <a href="#tweag-workflows">Tweag Workflows</a> section </li> </ul> </div></div>
        
        
        <div class="info">Tags: <a title="All pages tagged 'Haskell'." href="../tags/Haskell.html">Haskell</a></div>
        
    </section>
    <section>

    </section>
    <section>
        <div class="toc"><div class="header">Table of Contents</div>
<ul>
<li><a href="#arrow-effects.-semantics">Arrow Effects. Semantics</a>
<ul>
<li><a href="#tweag-workflows">Tweag Workflows</a></li>
<li><a href="#chris-penners-arrow-idea">Chris Penner’s <del>arr</del>ow idea</a></li>
</ul></li>
<li><a href="#monadic-polysemy-working-example">Monadic polysemy, Working example</a></li>
<li><a href="#semarr-type"><code>SemArr</code> type</a></li>
<li><a href="#consuming-polysemy-effects-using-arrows">Consuming <em>polysemy</em> effects using arrows</a></li>
<li><a href="#arrow-effects.-the-plumbing">Arrow Effects. The Plumbing</a></li>
<li><a href="#creating-arrow-effects">Creating Arrow Effects</a></li>
<li><a href="#creating-nested-effects">Creating Nested Effects</a></li>
<li><a href="#final-thoughts">Final Thoughts</a></li>
</ul>
</div>
<p>Code for this project can be found in my <a href="https://github.com/rpeszek/experiments" target="_blank">experiments</a> github repo (<a href="https://github.com/rpeszek/experiments/tree/master/polysemy-arrows" target="_blank">polysemy-arrows</a> folder).<br />
It is based on <a href="https://hackage.haskell.org/package/polysemy-1.3.0.0" target="_blank"><em>polysemy 1.3.0.0</em></a>.</p>
<p>The goal of this post is to show how to use arrows when working with or creating <em>polysemy</em> effects.</p>
<p><strong>Motivation:</strong> At work I use a proprietary effect system which is based on <a href="https://www.haskell.org/arrows" target="_blank">arrows</a>. I like it quite a bit, but… For something like an effect system, proprietary is not ideal. The effect system has a huge syntactic and semantic impact on the code. IMO it is a worthy goal to try limit the fragmentation of the ecosystem and (in the industrial context) focus on a small set of effect libraries.<br />
This task became my weekend pet project, and I have done some proof of concept work that added arrows to <a href="https://hackage.haskell.org/package/polysemy" target="_blank"><em>polysemy</em></a>. This post summarizes my effort. I believe similar approach can be used with other monadic effect libraries (like <a href="https://hackage.haskell.org/package/fused-effects" target="_blank"><em>fused-effects</em></a>). <em>polysemy</em> seems much closer to the design of the library I use at work, and was my first choice for this proof of concept work.</p>
<p><strong>Nutshell:</strong> There are two reasons for using arrows: syntactic and semantic. This blog, I am afraid, is about the first one. It is mostly about syntax sugar. Polysemy’s <a href="https://hackage.haskell.org/package/polysemy-1.3.0.0/docs/Polysemy.html#t:Sem" target="_blank"><code>Sem r</code></a> Monad instance is unconstrained, and that translates to arrow effects getting the equivalent <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Arrow.html#t:ArrowMonad" target="_blank"><code>ArrowApply</code></a> typeclass instance for free.<br />
The code I am about to present is trivial (at least in the mathematical sense). Monads and arrows loaded with the power of <code>ArrowApply</code> are equivalent. Semantic arrows I am going to implement here are just monads in arrow’s clothing. There is still some coding that needs to happen to implement the transformation and this code is the main subject of this post.</p>
<p>Algebraic effects for arrows <em>that are less expressive</em> (i.e. are not <code>ArrowApply</code> or even <code>ArrowChoice</code>) are meaningfully different and will be briefly discussed in the next section.</p>
<p>The code I write at work uses DSLs with “fully loaded” <code>ArrowApply</code> semantic arrows. We have build a lot of functionality that is directly concerned with inputs and outputs and arrows are a perfect syntactic match for us. DSL expressiveness is also what we want.</p>
<p>My coding goal in this post is to:</p>
<ul>
<li>be able to consume monadic polysemy effects using arrows</li>
<li>write arrow-like effects and consume them in monadic code</li>
</ul>
<p>Another words, a programmer should be able to create monadic effects using arrow effects and vice-versa.<br />
This is largely accomplished by using the <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Arrow.html#t:Kleisli" target="_blank">Control.Arrow.Kleisli</a> type and an effect construction that mimics <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Arrow.html#t:ArrowMonad" target="_blank">Control.Arrow.ArrowMonad</a>.</p>
<p>Many of my coworkers have, at some point, done a presentation or a tutorial about arrows. (<a href="https://www.youtube.com/watch?v=msQiLyExM3w" target="_blank">Jake’s talk</a>, <a href="https://www.youtube.com/watch?v=YqVTCZFPoyQ" target="_blank">Jason’s talk</a>).<br />
I guess this post qualifies as one and, thus, I am joining the club.</p>
<p>This post assumes the reader has at least basic familiarity with the concepts of arrows and algebraic effects.</p>
<h2 id="arrow-effects.-semantics">Arrow Effects. Semantics</h2>
<p>Since this will mostly be a syntax sugar, I need to talk about the semantics … just to add some depth.<br />
In this section I want to explore the realm of theoretical possibilities for what arrow algebraic effects could possibly look like and how they could differ from monadic algebraic effects.</p>
<p>It is interesting to think about arrows from the point of view of code expressiveness. Syntax aside, you can view arrow code as a subset of monadic code. Monadic code is the most expressive, arrows are much more restrictive (<a href="https://www.cl.cam.ac.uk/~jdy22/papers/idioms-are-oblivious-arrows-are-meticulous-monads-are-promiscuous.pdf" target="_blank">Idioms are oblivious, arrows are meticulous, monads are promiscuous</a> by Lindley, Wadler, Yallop). In Haskell, additional <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Arrow.html#t:ArrowChoice" target="_blank"><code>ArrowChoice</code></a> instance is needed to be able to write conditional (<code>if</code> and <code>case</code>) statements, <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Arrow.html#t:ArrowMonad" target="_blank"><code>ArrowApply</code></a> is needed to partially apply things. To focus this fantasy exploration, I want to forget about <code>ArrowChoice</code> and <code>ArrowApply</code> for a moment and consider what arrow effect system would look like for DSLs based on the <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Arrow.html#t:Arrow" target="_blank"><code>Arrow</code></a> typeclass only.</p>
<p>If an arrow code is a subset of a monadic code then monadic handlers (interpreters) have to also work on arrow DSLs. (With some adjustments of course, this is exactly what this post implements.) The question is what kind of other interesting interpreters one could come up with, that wouldn’t work on promiscuous monads but would work on meticulous arrows?</p>
<p>For one, arrow effects should be able to interpret to other interesting arrows. Basically, the handler (defined as the final interpreter / compilation target) should be able live outside of the standard (monadic) function space. There are examples of open source code out there that make steps in this direction. One example is tweag’s <a href="https://hackage.haskell.org/package/funflow-1.3.2/docs/Control-Arrow-Free.html" target="_blank">funflow</a>.</p>
<p>That sounds interesting but it is good to see a more practical benefit. To do that let’s think about what it means to have lack of conditional statements.</p>
<p>A great reading (somewhat on a theoretical side) is the Lindley’s paper <a href="https://homepages.inf.ed.ac.uk/slindley/papers/aeia.pdf" target="_blank">Algebraic Effects and Effect Handlers for Idioms and Arrows</a>.</p>
<p>Lindley uses the terms <em>static control flow</em> and <em>dynamic control flow</em>. Arrows allow for <em>static control flow</em> only.</p>
<p>Consider this monadic code:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>countTo10 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>  i <span class="ot">&lt;-</span> get</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>  <span class="kw">if</span> i <span class="op">&lt;</span> <span class="dv">10</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>  <span class="kw">then</span> put (i <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>  <span class="kw">else</span> <span class="fu">pure</span> ()</span></code></pre></div>
<p>that uses some <em>State</em> effect and increments it until it reaches 10.<br />
This code uses dynamic control flow (<code>if</code>-s on the result of the previous computation) and cannot be implemented with plain arrows.</p>
<p>This leads to the following 2 interesting observations:</p>
<ul>
<li>Arrow effects need to be more precise</li>
<li>Arrow effect handlers could conceivably do crazy stuff</li>
</ul>
<p><strong>Arrow Effects need to be more precise:</strong><br />
Monadic effect algebra GADT for <em>State</em> is likely to look like this (actually copied it from polysemy):</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">State</span> s m a <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>  <span class="dt">Get</span><span class="ot"> ::</span> <span class="dt">State</span> s m s</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>  <span class="dt">Put</span><span class="ot"> ::</span> s <span class="ot">-&gt;</span> <span class="dt">State</span> s m ()</span></code></pre></div>
<p>to implement <code>countTo10</code> without conditional statements I need more precise instructions! For example, I could add:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>  <span class="dt">Modify</span><span class="ot"> ::</span> (s <span class="ot">-&gt;</span> s) <span class="ot">-&gt;</span> <span class="dt">State</span> s m ()</span></code></pre></div>
<p>This forced precision could be perceived as a benefit in some situations. It gives more power to the interpreter to do different things when interpreting <code>Modify</code> than just <code>Get</code>/<code>Put</code> (for example, do something that is more performant or use different log messages).</p>
<p><strong>Arrow effect handlers could conceivably do crazy stuff:</strong><br />
Static control flow makes for a much more predictable syntax tree. In an example mentioned in the above paper, the interpreter statically infers when the <code>put</code> operation is used and when is not!<br />
Again, this translates to more power given to the interpreters, no <code>put</code>-s could, for example, mean a more aggressive optimization that somehow caches the state…</p>
<h3 id="tweag-workflows">Tweag Workflows</h3>
<p><em>u/Ywen</em> pointed out to me <a href="https://www.reddit.com/r/haskell/comments/o9y7re/arming_polysemy_with_arrows/h3oru2a?utm_source=share&amp;utm_medium=web2x&amp;context=3" target="_blank">here</a> that I missed a very cool presentation in the last ICFP, and indeed I did!<br />
References: <a href="https://richarde.dev/papers/2020/workflows/workflows.pdf" target="_blank">Composing Effects into Tasks and Workflows</a> by Parès, Bernardy, and Eisenberg; <a href="https://github.com/tweag/kernmantle" target="_blank"><em>kernmantle</em></a> effects library; here it is on <a href="https://www.youtube.com/watch?v=AiHOBF3BiLY&amp;t=834s" target="_blank">youtube</a>.</p>
<p>The paper is about creating data science workflow pipelines that decouple two runtime phases: config-time and process-time. This allows for fail-early benefits (if config-time effects fail).</p>
<p>This approach uses an arrow (without <em>ArrowApply</em> and with optional (opt-in) <em>ArrowChoice</em>) DSL that contains both applicative (config-phase) effects that do not depend on the result of previous computation and monadic (process-time) effects that do. The effect algebra GADTs separately define parameters that the DSL <em>has to provide statically</em> and parameters that can be used in dynamic arrow invocation. Thus, the interpreters have more power to infer information about the statically used configuration. This allows interpreters to perform config-time checks, for example, if some statically specified model training data file exists and fail early if it does not, interpreters can pre-download needed artifacts at the config-time, etc.</p>
<p>The presentation (see the youtube link) also shows a general <code>ArrowFromEffects</code> arrow type that generalizes <code>Kleisli</code>, <a href="https://hackage.haskell.org/package/comonad-5.0.8/docs/Control-Comonad.html#t:Cokleisli" target="_blank"><code>Cokleisli</code></a> (from <em>comondad</em>), and <a href="https://hackage.haskell.org/package/profunctors-5.6.2/docs/Data-Profunctor-Cayley.html" target="_blank"><code>Cayley</code></a> (from <em>profunctors</em>). <code>Cayley</code> plays an important role in <em>kernmantle</em>. As the interpretation target, it allows for isolating: the process-time computation (typically IO) and the config-time computation that can be used to analyze program configuration without running it.</p>
<p>I am in the process of absorbing this work. I may update this comment when I understand <em>kernmantle</em> better.</p>
<p>Separation between static and dynamic data is impossible when using monadic / ArrowApply computations. I will discuss this a little bit more in the <a href="#creating-arrow-effects">Creating Arrow Effects</a> section of this post.</p>
<h3 id="chris-penners-arrow-idea">Chris Penner’s <del>arr</del>ow idea</h3>
<p>A very interesting <a href="https://www.youtube.com/channel/UCNp-DVb8cQRIOo32sZhWgNg" target="_blank">Berlin’s FP Group</a> presentation by Chris Penner <a href="https://www.youtube.com/watch?v=xZmPuz9m2t0" target="_blank">Deconstructing Lambdas—An Awkward Guide to Programming Without Functions</a> envisions a world with something <code>Arrow</code>-like that does not have the <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Arrow.html#v:arr" target="_blank"><code>arr</code></a>.<br />
From a DSLs prospective, <code>Arrow</code>’s <code>arr</code> translates to the ability to use any Haskell <code>a -&gt; b</code> function inside the DSL.<br />
Removing this ability is very interesting. It is also a hard stop when trying to reuse any monadic effects library.</p>
<p>It seems that Chris Penner’s vision could be implemented with some Arrow-Minus like construction that cares about inputs and outputs and algebraic effect system that will be completely divorced from monadic effects.</p>
<p><strong>The point</strong> I tried to make in this section is that Arrow-like effect systems that are not convertible to monadic effects are very interesting and semantically important. The rest of this post is about interpreting arrows using polysemy and is more a syntax sugar thing.</p>
<p>Now back to <em>polysemy</em> and monads:</p>
<h2 id="monadic-polysemy-working-example">Monadic polysemy, Working example</h2>
<p>I will use the classic <code>Teletype</code> effect as my driving example. This is taken (almost) straight from the polysemy’s github readme:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Teletype</span> m a <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>  <span class="dt">ReadTTY</span><span class="ot">  ::</span> <span class="dt">Teletype</span> m <span class="dt">String</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>  <span class="dt">WriteTTY</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Teletype</span> m ()</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>makeSem '<span class="dt">'Teletype</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a><span class="ot">echo ::</span> <span class="dt">Member</span> <span class="dt">Teletype</span> r <span class="ot">=&gt;</span> <span class="dt">Sem</span> r ()</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>echo <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>  i <span class="ot">&lt;-</span> readTTY</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>  <span class="kw">case</span> i <span class="kw">of</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a>    <span class="st">&quot;&quot;</span> <span class="ot">-&gt;</span> writeTTY <span class="st">&quot;Need some input&quot;</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a>    _  <span class="ot">-&gt;</span> writeTTY <span class="op">$</span> <span class="st">&quot;You said &quot;</span> <span class="op">&lt;&gt;</span> i</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a><span class="co">-- * interpreters</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a><span class="ot">teletypeToIO ::</span> <span class="dt">Member</span> (<span class="dt">Embed</span> <span class="dt">IO</span>) r <span class="ot">=&gt;</span> <span class="dt">Sem</span> (<span class="dt">Teletype</span> '<span class="op">:</span> r) a <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a>teletypeToIO <span class="ot">=</span> interpret \<span class="kw">case</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a>  <span class="dt">ReadTTY</span>      <span class="ot">-&gt;</span> embed <span class="fu">getLine</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true"></a>  <span class="dt">WriteTTY</span> msg <span class="ot">-&gt;</span> embed <span class="op">$</span> <span class="fu">putStrLn</span> msg</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true"></a></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true"></a><span class="ot">interpreter ::</span> r <span class="op">~</span> '[<span class="dt">Teletype</span>, <span class="dt">Embed</span> <span class="dt">IO</span>] <span class="ot">=&gt;</span> <span class="dt">Sem</span> r a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true"></a>interpreter <span class="ot">=</span> runM <span class="op">.</span> teletypeToIO</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true"></a></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true"></a><span class="ot">test ::</span> <span class="dt">IO</span> ()</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true"></a>test <span class="ot">=</span> interpreter echo</span></code></pre></div>
<p>I have spelled out the effect stack in the type signature of the <code>interpreter</code> combinator to add the clarity. I will do that in following examples as well. Compiler can infer these and typical <em>polysemy</em> examples do not list the complete effect list.<br />
The goal is to replace monadic computations with arrows.</p>
<h2 id="semarr-type"><code>SemArr</code> type</h2>
<p>Let me introduce our semantic arrow type:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Control.Arrow</span> <span class="kw">as</span> <span class="dt">Arr</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a><span class="co">-- | Semantic arrows in polysemy</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">SemArr</span> r a b <span class="ot">=</span> <span class="dt">Arr.Kleisli</span> (<span class="dt">Sem</span> r) a b</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a><span class="co">-- | Used to define atomic effect arrows</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a><span class="ot">constSemArr ::</span> (<span class="dt">Sem</span> r) b <span class="ot">-&gt;</span> <span class="dt">SemArr</span> r () b</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>constSemArr c <span class="ot">=</span> <span class="dt">Arr.Kleisli</span> (<span class="fu">const</span> c)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a><span class="co">-- | Used to define atomic effect arrows</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a><span class="ot">semArr ::</span> (a <span class="ot">-&gt;</span> (<span class="dt">Sem</span> r) b)<span class="ot">-&gt;</span> <span class="dt">SemArr</span> r a b</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a>semArr <span class="ot">=</span> <span class="dt">Arr.Kleisli</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true"></a><span class="co">-- | transforms @Sem@ compilation stacks to @SemArr@ compilation stacks.</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true"></a><span class="ot">semArrCompl ::</span> (<span class="dt">Sem</span> r1 b1 <span class="ot">-&gt;</span> <span class="dt">Sem</span> r2 b2) <span class="ot">-&gt;</span> <span class="dt">SemArr</span> r1 a b1 <span class="ot">-&gt;</span> <span class="dt">SemArr</span> r2 a b2 </span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true"></a>semArrCompl comp (<span class="dt">Arr.Kleisli</span> fn) <span class="ot">=</span> <span class="dt">Arr.Kleisli</span> (comp <span class="op">.</span> fn)</span></code></pre></div>
<p><code>Kleisli m a b</code> wraps <code>a -&gt; m b</code> function and is the standard way to express monadic computations as arrows.</p>
<p>It is probably obvious, but it is good to remember that <code>Kleisli</code> is just a type and it does not imply monad payload by itself. In particular, it has these instances:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Functor</span> m <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">Kleisli</span> m a)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">Kleisli</span> m a)</span></code></pre></div>
<p><code>SemArr r a b</code> comes fully loaded with all <code>Arrow</code> typeclass instances (like <code>ArrowApply</code>) because <code>(Sem r)</code> has the unconstrained <code>Monad</code> instance:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">Sem</span> f)</span></code></pre></div>
<p><code>SemArr r a b</code> is a monad in arrow’s clothing.</p>
<h2 id="consuming-polysemy-effects-using-arrows">Consuming <em>polysemy</em> effects using arrows</h2>
<p>This is section will not be interesting. We can tranform monads to arrows using Kleisli, duh:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="ot">readTTYA ::</span> <span class="kw">forall</span> (<span class="ot">r ::</span> [<span class="dt">Effect</span>])<span class="op">.</span> <span class="dt">MemberWithError</span> <span class="dt">Teletype</span> r <span class="ot">=&gt;</span> <span class="dt">SemArr</span> r () <span class="dt">String</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>readTTYA <span class="ot">=</span> constSemArr readTTY</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a><span class="ot">writeTTYA ::</span> <span class="kw">forall</span> (<span class="ot">r ::</span> [<span class="dt">Effect</span>])<span class="op">.</span> <span class="dt">MemberWithError</span> <span class="dt">Teletype</span> r <span class="ot">=&gt;</span> <span class="dt">SemArr</span> r <span class="dt">String</span> ()</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>writeTTYA <span class="ot">=</span> semArr writeTTY</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a><span class="ot">echoA ::</span> <span class="dt">Member</span> <span class="dt">Teletype</span> r <span class="ot">=&gt;</span> <span class="dt">SemArr</span> r () ()</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a>echoA <span class="ot">=</span> proc _ <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a>    i <span class="ot">&lt;-</span> readTTYA <span class="op">-&lt;</span> ()</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a>    <span class="kw">case</span> i <span class="kw">of</span> </span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a>       <span class="st">&quot;&quot;</span> <span class="ot">-&gt;</span> </span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true"></a>           writeTTYA <span class="op">-&lt;</span> <span class="st">&quot;Need some input&quot;</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true"></a>       _ <span class="ot">-&gt;</span>  </span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true"></a>           writeTTYA <span class="op">-&lt;</span> <span class="st">&quot;You said &quot;</span> <span class="op">&lt;&gt;</span> i</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true"></a></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true"></a><span class="co">-- Notice interpreter is input - output based, the last bit @a -&gt; IO b@ is effectively Kleisli arrow</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true"></a></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true"></a><span class="ot">interpreter ::</span>  r <span class="op">~</span> '[<span class="dt">Teletype</span>, <span class="dt">Embed</span> <span class="dt">IO</span>] <span class="ot">=&gt;</span> <span class="dt">SemArr</span> r a b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> b</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true"></a>interpreter arr a <span class="ot">=</span> runM <span class="op">.</span> teletypeToIO <span class="op">$</span> Arr.runKleisli arr a</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true"></a></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true"></a><span class="ot">testA ::</span> <span class="dt">IO</span> ()</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true"></a>testA <span class="ot">=</span> interpreter echoA ()</span></code></pre></div>
<p><code>readTTYA</code> and <code>writeTTYA</code> are arrow-ised versions of the monadic <code>readTTY</code> and <code>writeTTY</code> primitives.</p>
<p>Notice the change in the type signature for <code>interpreter</code>. <code>interpreter</code> now threads the input data into the computation and spells out the output at the end. You can also view it as compiling the <code>SemArr r a b</code> arrow down to <code>Kleisli IO a b</code> (only with <code>Kleisli</code> unwrapped for extra convenience).</p>
<p>Let’s move onto some more interesting stuff:</p>
<h2 id="arrow-effects.-the-plumbing">Arrow Effects. The Plumbing</h2>
<p>One of the syntactic advantages of using arrow effects, at least for me, is the simplified construction of the effect algebra GADT. This definition nicely spells out the input and the output:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Teletype2</span> a b <span class="kw">where</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>  <span class="dt">ReadTTY2</span><span class="ot">  ::</span> <span class="dt">Teletype2</span> () <span class="dt">String</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>  <span class="dt">WriteTTY2</span><span class="ot"> ::</span> <span class="dt">Teletype2</span> <span class="dt">String</span> ()</span></code></pre></div>
<p>I want to be able to add <code>Teletype2</code> to the list of polysemy effects. This needs some plumbing:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Eff2</span> arr r b <span class="kw">where</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>  <span class="dt">MkEff2</span><span class="ot"> ::</span> arr () b <span class="ot">-&gt;</span> <span class="dt">Eff2</span> arr r b</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a><span class="ot">interpretEff2 ::</span> (<span class="kw">forall</span> x <span class="op">.</span> m x <span class="ot">-&gt;</span> <span class="dt">Sem</span> r x) <span class="ot">-&gt;</span> (<span class="kw">forall</span> x y <span class="op">.</span> arr x y <span class="ot">-&gt;</span>  <span class="dt">Arr.Kleisli</span> m x y) <span class="ot">-&gt;</span> <span class="dt">Sem</span> (<span class="dt">Eff2</span> arr '<span class="op">:</span> r) a <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>interpretEff2 comp fn <span class="ot">=</span> interpret \<span class="kw">case</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>  <span class="dt">MkEff2</span> arr   <span class="ot">-&gt;</span> comp (Arr.runKleisli (fn arr) ())</span></code></pre></div>
<p><code>MkEff2</code> is the bit which mimics <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Arrow.html#t:ArrowMonad" target="_blank">Control.Arrow.ArrowMonad</a>! This trick is based on the fact <code>B = B ^ 1</code>: one can represent elements in a set <code>B</code> by using fuctions from a one element set (here <code>()</code>) ending in <code>B</code> that pick that element. That observation nicely generalizes to categorical constructions that use terminal objects and this principled idea works great for what I need.</p>
<p><code>interpretEff2</code> is actually quite powerful. It allows me to implement an equivalent to polysemy’s <code>embed</code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="ot">embedEff2 ::</span> <span class="dt">Member</span> (<span class="dt">Embed</span> m) r <span class="ot">=&gt;</span> (<span class="kw">forall</span> x y <span class="op">.</span> arr x y <span class="ot">-&gt;</span>  <span class="dt">Arr.Kleisli</span> m x y) <span class="ot">-&gt;</span> <span class="dt">Sem</span> (<span class="dt">Eff2</span> arr '<span class="op">:</span> r) a <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>embedEff2 <span class="ot">=</span> interpretEff2 embed</span></code></pre></div>
<p>it will also allow me to reinterpret an arrow effect using other (possibly arrow) effects. We will see it again in the <a href="#effects-based-on-arrow-effects">Nested Effects</a> section.</p>
<p>However, there is a clear problem with what we have so far: <code>arr () b</code> in the definition of <code>Eff2</code> does not match with the <code>WriteTTY2</code> constructor. We need to embed <code>WriteTTY2</code> in a bigger instruction set that has enough expressiveness to be able use the above <code>() -&gt;</code> trick. To do that I will do the following, minimalist, free construction:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Eff2Free</span> eff a b <span class="kw">where</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>  <span class="dt">Pure</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Eff2Free</span> eff a b</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>  <span class="dt">Effect</span><span class="ot"> ::</span> eff a b <span class="ot">-&gt;</span> <span class="dt">Eff2Free</span> eff a b</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>  <span class="dt">Seq</span><span class="ot"> ::</span> <span class="dt">Eff2Free</span> eff a b <span class="ot">-&gt;</span> <span class="dt">Eff2Free</span> eff b c <span class="ot">-&gt;</span> <span class="dt">Eff2Free</span> eff a c</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Category</span> (<span class="dt">Eff2Free</span> eff) <span class="kw">where</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a>  <span class="fu">id</span> <span class="ot">=</span> <span class="dt">Pure</span> Cat.id</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a>  (<span class="op">.</span>) <span class="ot">=</span> <span class="fu">flip</span> <span class="dt">Seq</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true"></a><span class="ot">liftCompKl ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (<span class="kw">forall</span> x y <span class="op">.</span> eff x y <span class="ot">-&gt;</span>  <span class="dt">Arr.Kleisli</span> m x y) <span class="ot">-&gt;</span> <span class="dt">Eff2Free</span> eff a b <span class="ot">-&gt;</span> <span class="dt">Arr.Kleisli</span> m a b</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true"></a>liftCompKl _ (<span class="dt">Pure</span> f) <span class="ot">=</span>  <span class="dt">Arr.Kleisli</span> (<span class="fu">pure</span> <span class="op">Cat..</span> f)</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true"></a>liftCompKl fn (<span class="dt">Effect</span> eff) <span class="ot">=</span> fn eff</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true"></a>liftCompKl fn (<span class="dt">Seq</span> a1 a2) <span class="ot">=</span> liftCompKl fn a1 <span class="op">&gt;&gt;&gt;</span> liftCompKl fn a2</span></code></pre></div>
<p>Combining <code>Eff2</code> with <code>Eff2Free</code> is what I need to move forward.</p>
<p><code>liftCompKl</code> allows me to expand <code>Kleisli</code> encoding of <code>Teletype2</code> to the mini-DSL: <code>Eff2Free Teletype2</code>.</p>
<p><strong>Semantic Note:</strong> When I started working on this, I assumed my <code>Eff2Free</code> will be a free construction of the <code>Arrow</code>, and possibly <code>ArrowChoice</code> or even <code>ArrowApply</code>. This ended up being much more minimalist, we get arrows for free from using <code>SemArr r a b</code>.</p>
<p>What is really needed, is the ability to pre-compose mapped (i.e. <code>Pure</code>) functions with the lifted effect. This free construction needs only to be compatible with the <code>Contravariant</code> Functor (or <code>Profunctor</code> <code>lmap</code>) and there should be some flexibility of how it is done.</p>
<h2 id="creating-arrow-effects">Creating Arrow Effects</h2>
<p>Here is the whole program that uses an Arrow-like effect algebra, arrow instruction primitives, and a DSL program that uses arrows:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Teletype2</span> a b <span class="kw">where</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>  <span class="dt">ReadTTY2</span><span class="ot">  ::</span> <span class="dt">Teletype2</span> () <span class="dt">String</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>  <span class="dt">WriteTTY2</span><span class="ot"> ::</span> <span class="dt">Teletype2</span> <span class="dt">String</span> ()</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a><span class="co">-- type Effect2 arr r b = Eff2 (Eff2Free arr) r b</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a><span class="co">-- | arrow frienly combinator</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a><span class="ot">readTTY2A ::</span> <span class="kw">forall</span> (<span class="ot">r ::</span> [<span class="dt">Effect</span>])<span class="op">.</span> <span class="dt">Member</span> (<span class="dt">Eff2</span> (<span class="dt">Eff2Free</span> <span class="dt">Teletype2</span>)) r <span class="ot">=&gt;</span> <span class="dt">SemArr</span> r () <span class="dt">String</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a>readTTY2A <span class="ot">=</span>  constSemArr readTTY2</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a><span class="co">-- | monad frienly combinator, can be consumed by monadic programs and effects</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true"></a><span class="ot">readTTY2 ::</span> <span class="kw">forall</span> (<span class="ot">r ::</span> [<span class="dt">Effect</span>])<span class="op">.</span> <span class="dt">Member</span> (<span class="dt">Eff2</span> (<span class="dt">Eff2Free</span> <span class="dt">Teletype2</span>)) r <span class="ot">=&gt;</span> <span class="dt">Sem</span> r <span class="dt">String</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true"></a>readTTY2 <span class="ot">=</span> send (<span class="dt">MkEff2</span> (<span class="dt">Effect</span> <span class="dt">ReadTTY2</span>)) </span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true"></a></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true"></a><span class="ot">writeTTY2A ::</span> <span class="kw">forall</span> (<span class="ot">r ::</span> [<span class="dt">Effect</span>])<span class="op">.</span> <span class="dt">Member</span> (<span class="dt">Eff2</span> (<span class="dt">Eff2Free</span> <span class="dt">Teletype2</span>)) r <span class="ot">=&gt;</span> <span class="dt">SemArr</span> r <span class="dt">String</span> ()</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true"></a>writeTTY2A <span class="ot">=</span> semArr writeTTY2</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true"></a></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true"></a><span class="co">-- | mini-DLS @Eff2Free Teletype2@ allows me to encode input paramter to the @WriteTTY2@ instruction</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true"></a><span class="ot">writeTTY2 ::</span> <span class="kw">forall</span> (<span class="ot">r ::</span> [<span class="dt">Effect</span>])<span class="op">.</span> <span class="dt">Member</span> (<span class="dt">Eff2</span> (<span class="dt">Eff2Free</span> <span class="dt">Teletype2</span>)) r <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Sem</span> r ()</span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true"></a>writeTTY2 s <span class="ot">=</span> send (<span class="dt">MkEff2</span> (<span class="dt">Pure</span> (<span class="fu">const</span> s) <span class="op">&gt;&gt;&gt;</span> <span class="dt">Effect</span> <span class="dt">WriteTTY2</span>)) </span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true"></a></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true"></a><span class="ot">echo2A ::</span> <span class="dt">Member</span> (<span class="dt">Eff2</span> (<span class="dt">Eff2Free</span> <span class="dt">Teletype2</span>)) r <span class="ot">=&gt;</span> <span class="dt">SemArr</span> r () ()</span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true"></a>echo2A <span class="ot">=</span> proc _ <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true"></a>    i <span class="ot">&lt;-</span> readTTY2A <span class="op">-&lt;</span> ()</span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true"></a>    <span class="kw">case</span> i <span class="kw">of</span> </span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true"></a>       <span class="st">&quot;&quot;</span> <span class="ot">-&gt;</span> </span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true"></a>           writeTTY2A <span class="op">-&lt;</span> <span class="st">&quot;Need some input&quot;</span></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true"></a>       _ <span class="ot">-&gt;</span>  </span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true"></a>           writeTTY2A <span class="op">-&lt;</span> <span class="st">&quot;You said &quot;</span> <span class="op">&lt;&gt;</span> i</span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true"></a></span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true"></a><span class="co">-- * interpreters</span></span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true"></a></span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true"></a><span class="co">-- | Teletype2 instructions are interpreted as Kleisli</span></span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true"></a><span class="ot">tele2ToKlIO ::</span> <span class="dt">Teletype2</span> a b <span class="ot">-&gt;</span> <span class="dt">Arr.Kleisli</span> <span class="dt">IO</span> a b</span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true"></a>tele2ToKlIO <span class="dt">ReadTTY2</span> <span class="ot">=</span> <span class="dt">Arr.Kleisli</span> <span class="op">$</span> <span class="fu">const</span> <span class="fu">getLine</span></span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true"></a>tele2ToKlIO <span class="dt">WriteTTY2</span> <span class="ot">=</span> <span class="dt">Arr.Kleisli</span> <span class="fu">putStrLn</span></span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true"></a></span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true"></a><span class="co">-- | tele2ToKlIO is extended to the the mini-DLS @Eff2Free Teletype2@</span></span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true"></a><span class="ot">interpreter ::</span>  r <span class="op">~</span> '[<span class="dt">Eff2</span> (<span class="dt">Eff2Free</span> <span class="dt">Teletype2</span>), <span class="dt">Embed</span> <span class="dt">IO</span>] <span class="ot">=&gt;</span> <span class="dt">SemArr</span> r a b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> b</span>
<span id="cb13-39"><a href="#cb13-39" aria-hidden="true"></a>interpreter arr a <span class="ot">=</span> runM <span class="op">.</span> embedEff2 (liftCompKl tele2ToKlIO)  <span class="op">$</span> Arr.runKleisli arr a</span>
<span id="cb13-40"><a href="#cb13-40" aria-hidden="true"></a></span>
<span id="cb13-41"><a href="#cb13-41" aria-hidden="true"></a><span class="ot">testA2 ::</span> <span class="dt">IO</span> ()</span>
<span id="cb13-42"><a href="#cb13-42" aria-hidden="true"></a>testA2 <span class="ot">=</span> interpreter echo2A ()</span></code></pre></div>
<ul>
<li><code>readTTY2</code> and <code>writeTTY2</code> primitives can be used by any monadic polysemy code to create new effects or to use in programs where effect the <code>Eff2 (Eff2Free Teletype2)</code> is available.</li>
<li><code>readTTY2A</code> and <code>writeTTY2A</code> are available for any arrow code. In particular, these can be used to create new arrow effects that compile down to <code>Eff2 (Eff2Free Teletype2)</code>.</li>
</ul>
<p><strong>Semantic Note:</strong> Notice that, when defining monadic version of <code>Teletype</code> GADT, we used value level <code>String</code> in the <code>WriteTTY</code> constructor, now the <code>String</code> input is defined squarely on the type level.<br />
We could consider defining <code>WriteTTY2</code> as <code>WriteTTY2 :: String -&gt; Teletype2 () ()</code> instead.<br />
This would yield <code>String -&gt; SemArr r () ()</code> type for the above <code>writeTTY2A</code>. In the expressive world of <em>monads</em> / <em>ArrowApply</em> both constructions are largely equivalent. Not so in the more restrictive universe of general arrows we discussed in the <a href="#arrow-effects.-semantics">Semantics</a> section.<br />
The new construction would allow a more static handling of the <code>String</code> parameter by the interpreter but the <code>String</code> parameter would not be available for dynamic use at the DSL level. We would not be able to write the above <code>echo2A</code> program. A code example of this is provided in the included repo <a href="https://github.com/rpeszek/experiments/blob/05e23cdca5766b947b731d9084bdfe96c7bcbaae/polysemy-arrows/src/Teletype2B.hs" target="_blank">here</a></p>
<p>Implementing arrow effects on top of other arrows effects seems to be the most interesting case of nesting and is shown next:</p>
<h2 id="creating-nested-effects">Creating Nested Effects</h2>
<p><code>DoEcho2</code> instruction has a non-unit input and output making it more interesting. We will interpret it down to <code>Teletype2</code> effect by writing its input, reading a new input and returning it as the result.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Echoer2</span> a b <span class="kw">where</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>  <span class="dt">DoEcho2</span><span class="ot"> ::</span> <span class="dt">Echoer2</span> <span class="dt">String</span> <span class="dt">String</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a><span class="ot">doEcho2 ::</span> <span class="kw">forall</span> (<span class="ot">r ::</span> [<span class="dt">Effect</span>])<span class="op">.</span> <span class="dt">Member</span> (<span class="dt">Eff2</span> (<span class="dt">Eff2Free</span> <span class="dt">Echoer2</span>)) r <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Sem</span> r <span class="dt">String</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>doEcho2 s <span class="ot">=</span> send (<span class="dt">MkEff2</span> (<span class="dt">Pure</span> (<span class="fu">const</span> s) <span class="op">&gt;&gt;&gt;</span> <span class="dt">Effect</span> <span class="dt">DoEcho2</span>)) </span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a><span class="ot">doEcho2A ::</span> <span class="kw">forall</span> (<span class="ot">r ::</span> [<span class="dt">Effect</span>])<span class="op">.</span> <span class="dt">Member</span> (<span class="dt">Eff2</span> (<span class="dt">Eff2Free</span> <span class="dt">Echoer2</span>)) r <span class="ot">=&gt;</span> <span class="dt">SemArr</span> r <span class="dt">String</span> <span class="dt">String</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true"></a>doEcho2A <span class="ot">=</span> semArr doEcho2 </span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true"></a></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true"></a><span class="co">-- | nice use of arrows to create complex effects</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true"></a><span class="ot">echoer2ToKl ::</span> <span class="dt">Member</span> (<span class="dt">Eff2</span> (<span class="dt">Eff2Free</span> <span class="dt">Teletype2</span>)) r <span class="ot">=&gt;</span> <span class="dt">Echoer2</span> a b <span class="ot">-&gt;</span> <span class="dt">Arr.Kleisli</span> (<span class="dt">Sem</span> r) a b</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true"></a>echoer2ToKl <span class="dt">DoEcho2</span> <span class="ot">=</span> proc inp <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true"></a>  _ <span class="ot">&lt;-</span> writeTTY2A <span class="op">-&lt;</span> inp</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true"></a>  txt <span class="ot">&lt;-</span> readTTY2A <span class="op">-&lt;</span> ()</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true"></a>  <span class="kw">if</span> txt <span class="op">==</span> <span class="st">&quot;&quot;</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true"></a>  <span class="kw">then</span> arr <span class="fu">id</span> <span class="op">-&lt;</span> <span class="st">&quot;No Input&quot;</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true"></a>  <span class="kw">else</span> arr <span class="fu">id</span> <span class="op">-&lt;</span> <span class="st">&quot;You said &quot;</span> <span class="op">&lt;&gt;</span> txt</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true"></a></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true"></a><span class="co">-- | interpretEff2 allows to intepret down the effect</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true"></a><span class="ot">echoer2ToTeletype2 ::</span> <span class="kw">forall</span> r a <span class="op">.</span> <span class="dt">Member</span> (<span class="dt">Eff2</span> (<span class="dt">Eff2Free</span> <span class="dt">Teletype2</span>)) r <span class="ot">=&gt;</span> <span class="dt">Sem</span> (<span class="dt">Eff2</span> (<span class="dt">Eff2Free</span> <span class="dt">Echoer2</span>) '<span class="op">:</span> r) a <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true"></a>echoer2ToTeletype2 <span class="ot">=</span> interpretEff2 <span class="fu">id</span> (liftCompKl <span class="op">@</span> (<span class="dt">Sem</span> r) echoer2ToKl)</span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true"></a></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true"></a><span class="ot">interpreter ::</span>  r <span class="op">~</span> '[<span class="dt">Eff2</span> (<span class="dt">Eff2Free</span> <span class="dt">Echoer2</span>), <span class="dt">Eff2</span> (<span class="dt">Eff2Free</span> <span class="dt">Teletype2</span>), <span class="dt">Embed</span> <span class="dt">IO</span>] <span class="ot">=&gt;</span> <span class="dt">SemArr</span> r a b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> b</span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true"></a>interpreter arr a <span class="ot">=</span> runM <span class="op">.</span> embedEff2 (liftCompKl tele2ToKlIO) <span class="op">.</span> echoer2ToTeletype2 <span class="op">$</span> Arr.runKleisli arr a</span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true"></a></span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true"></a><span class="ot">testEchoerA ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">String</span></span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true"></a>testEchoerA  <span class="ot">=</span> interpreter (doEcho2A <span class="op">&gt;&gt;&gt;</span> doEcho2A) </span></code></pre></div>
<p><code>echoer2ToKl</code> plays the role of an interpreter for the effect algebra. It is implemented using arrows!<br />
The <code>interpretEff2</code> combinator (defined in the <a href="#arrow-effects-the-plumbing">plumbing</a> section) returns an interpreter that <em>polysemy</em> understands.<br />
Again, I view <code>interpreter</code> as a natural transformation between <code>SemArr r a b</code> arrow and <code>Kelisly IO a b</code> arrow (ignoring the <code>runKleisli</code> unwrapping).</p>
<p>We have a two way street to writing compilation stacks:</p>
<ul>
<li>compose <code>Sem r</code> interpreters that remove effects from the <code>r</code> record and compile <code>Sem r1 a</code> monadic computation to a simpler monadic computation <code>Sem r2 a</code> (the standard <em>polysemy</em>’s approach)</li>
<li>compose <code>SemArr r</code> interpreters that compile <code>SemArr r1 a b</code> arrow to a simpler <code>SemArr r2 a b</code> arrow.</li>
</ul>
<p>or mixing both ways. These options are all possible (my git repo has the necessary combinators).</p>
<h2 id="final-thoughts">Final Thoughts</h2>
<p>We have accomplished the goal. We can program <em>polysemy</em> effects by using interchangeably both the monadic and the arrow syntax.</p>
<p>This seems to be an interesting engineering problem: effective refactoring methods for swapping effect systems.<br />
The task of refactoring a large code base to change its effect library will not be easy and I am not even sure it will be attempted.<br />
The differences are not just in the use of arrows vs monads. The effects are declared polymorphically in both cases but in very different ways. The collections of the base (batteries included) effects has subtle differences. There are subtle but important differences in error handling …<br />
It will require much more footwork to be able to do it piece by piece.</p>
<p>The <code>Eff2</code> / <code>Eff2Free</code> tooling is not really arrow specific. I believe, it could be used with other things. That is the reason behind the names (for not using something like <code>EffArr</code>). However, whatever you come up with (e.g. a free Profunctor construction) this will be just dressing a monad in some other clothing - it will be syntactic only. The <code>Arrow</code> seems to be the only meaningful exception, because it comes with the syntax extension (the Arrows pragma).</p>
<p>This was all very much a quick prototype. I am sure the presented code can be improved in many ways. I hope it was good enough to allow for an interesting reading.</p>

    </section>
</article>
]]></description>
    <pubDate>Mon, 28 Jun 2021 00:00:00 UT</pubDate>
    <guid>https://rpeszek.github.io//posts/2021-06-28-polysemy-arrows.html</guid>
    <dc:creator>Robert Peszek</dc:creator>
</item>
<item>
    <title>Is Alternative a Wrong Abstraction for Handling Failures?</title>
    <link>https://rpeszek.github.io//posts/2021-02-13-alternative.html</link>
    <description><![CDATA[<article>
    <section class="header">
        Posted on February 13, 2021
        
            by Robert Peszek
        
        
          <br /> Last Modified on February 17, 2021
        
        
        <div class="changelog"> <div>Revision History: <ul> <li> (2021.02.13) Edited <a href="#pessimistic-instances">Pessimistic Instances</a> top section</li> <li> (2021.02.14) <a href="#pessimists-intro-to-alternative">Intro</a> adds a clarification paragraph linking failures to instances (prompted by reddit), <a href="#nutshell">Nutshell</a> clearly lists goals </li> <li> (2021.02.15-16) Added <a href="#readers-response">Reader's Response</a> section</li> <li> (2021.02.16) Laws&colon; clarified some text</li> <li> (2021.02.17) <a href="#rethinking-the-typeclass-itself">Rethinking</a> section reworded a little</li> </ul> </div></div>
        
        
        <div class="info">Tags: <a title="All pages tagged 'Haskell'." href="../tags/Haskell.html">Haskell</a>, <a title="All pages tagged 'error-messages'." href="../tags/error-messages.html">error-messages</a>, <a title="All pages tagged 'maintainability'." href="../tags/maintainability.html">maintainability</a>, <a title="All pages tagged 'correctness'." href="../tags/correctness.html">correctness</a></div>
        
    </section>
    <section>

    </section>
    <section>
        <div class="toc"><div class="header">Table of Contents</div>
<ul>
<li><a href="#nutshell">Nutshell</a></li>
<li><a href="#pessimists-intro-to-alternative">Pessimist’s Intro to <code>Alternative</code></a></li>
<li><a href="#alternative-laws-pessimistically">Alternative Laws, Pessimistically</a></li>
<li><a href="#real-world-alternative-optimism-with-experience">Real-World <code>Alternative</code> (Optimism with Experience)</a>
<ul>
<li><a href="#failure-at-the-end">Failure at the end</a></li>
<li><a href="#permissive-computation-at-the-end">Permissive computation at the end</a></li>
</ul></li>
<li><a href="#pessimistic-instances">Pessimistic Instances</a>
<ul>
<li><a href="#either-e-a"><code>Either [e] a</code></a></li>
<li><a href="#a-decent-blueprint-either-e-e-a">A Decent Blueprint: <code>Either [e] ([e], a)</code></a></li>
<li><a href="#code-example">Code Example</a></li>
<li><a href="#extending-either-e-e-a">Extending <code>Either [e] ([e], a)</code></a></li>
</ul></li>
<li><a href="#rethinking-the-typeclass-itself">Rethinking the Typeclass Itself</a></li>
<li><a href="#alternative-beyond-parsing"><code>Alternative</code> Beyond Parsing</a></li>
<li><a href="#relevant-work-on-hackage">Relevant work on Hackage</a></li>
<li><a href="#conclusions-thoughts">Conclusions, Thoughts</a>
<ul>
<li><a href="#readers-response">Reader’s Response</a></li>
</ul></li>
</ul>
</div>
<p><strong><em>subtitle:</em> A Constructive <del>Criticism</del> Pessimism about the Alternative Typeclass</strong></p>
<p>Code for this project can be found in my <a href="https://github.com/rpeszek/experiments" target="_blank">experiments</a> repo (<a href="https://github.com/rpeszek/experiments/tree/master/alternative" target="_blank">alternative</a> folder).<br />
This is my second post dedicated to the <em>error information loss</em> in Haskell (the first was about <a href="https://rpeszek.github.io/posts/2021-01-17-maybe-overuse.html" target="_blank">Maybe Overuse</a>).</p>
<h2 id="nutshell">Nutshell</h2>
<p><code>Alternative</code> is a popular functional programming concept and the name of a frequently used Haskell typeclass. <code>Alternative</code> helps in writing elegant, concise code. <code>Alternative</code> instances are also known for producing confusing errors. In this post, we do a deep dive into the alternative thinking only about the errors.</p>
<p>The goals for this post are:</p>
<ul>
<li>discuss how <code>Alternative</code> laws impact the instance ability to keep error information</li>
<li>provide examples of how some <code>Alternative</code> instances can get programmers in trouble</li>
<li>show a ‘blueprint’ <a href="#a-decent-blueprint-either-e-e-a"><code>Either [e] ([e],_)</code></a> instance with a strong ability to preserve error information. This blueprint can be extended to a transformer, parser, etc.</li>
<li>very briefly discuss extending or rethinking the <code>Alternative</code> typeclass itself</li>
</ul>
<p>I realized that there is an interesting connection between many <code>Alternative</code> instances and optimism:<br />
Thinking about <em>the glass being half empty or half full</em>, look at this computation: <code>a &lt;|&gt; b</code> and assume that <code>a</code> fails and <code>b</code> succeeds.<br />
<em>A half empty glass</em> makes us think about the failure of <code>a</code>:<br />
<em>Why</em> did <code>a</code> fail?<br />
Would it not be better if some <code>a</code> failures caused the whole computation to fail?…<br />
<em>A half full glass</em> makes us ignore the failure and focus on <code>b</code>… this is exactly the semantics of <code>&lt;|&gt;</code>.<br />
A half full glass is not what you always want. This post looks at the alternative, its laws, and its instances from the “pessimistic” point of view. In this post pessimism is defined as, simply, thinking about the errors.</p>
<p>This is a long post. You may prefer to pick a section you consider interesting and backtrack from it. The information is largely self-contained (except for referring to the laws).</p>
<p>Implementing good error messages is not trivial. This post should not be viewed as criticism but as a challenge.</p>
<p>I am using the term <em>error</em> colloquially, the correct term is <em>exception</em>. <em>Exception information loss</em> just does not have a ring to it.</p>
<h2 id="pessimists-intro-to-alternative">Pessimist’s Intro to <code>Alternative</code></h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Alternative</span> f <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="ot">  empty ::</span> f a</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="ot">  (&lt;|&gt;) ::</span> f a <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f a</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="ot">  some ::</span> f a <span class="ot">-&gt;</span> f [a] <span class="co">-- optional</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a><span class="ot">  many ::</span> f a <span class="ot">-&gt;</span> f [a] <span class="co">-- optional</span></span></code></pre></div>
<p>The typeclass does not specify the semantics of <code>empty</code> and <code>&lt;|&gt;</code> other than their monoidal nature.<br />
However, many instances link the <code>empty</code> and <code>&lt;|&gt;</code> semantics to computation failures.</p>
<p><em>Optimist, First Look</em>:</p>
<ul>
<li><code>empty</code> typically represents a failed computation</li>
<li><code>(&lt;|&gt;)</code> combines 2 alternatives returning one that is successful. The most common approach is to return the left-to-right first success. This is called left-bias, I like to think about it as <em>right-catch semantics</em>.</li>
<li><code>some</code> and <code>many</code> run the computation until first failure and return the successful results, <code>some</code> expects at least one success, otherwise it will fail. <code>some</code> and <code>many</code> are a nod towards parsers or other computations that change state. <code>some</code> and <code>many</code> are likely to yield bottom (e.g. <code>many (Just 1)</code> does not terminate).</li>
</ul>
<p><code>Alternative</code> is the <code>Monoid</code> for the <code>* -&gt; *</code> types, <code>empty</code> representing <code>mempty</code> and <code>&lt;|&gt;</code> representing <code>mappend</code>. This equivalence is “witnessed” by the <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Monoid.html#t:Alt" target="_blank"><code>Data.Monoid.Alt</code></a> monoid instance. The left-bias semantics is equivalent to the <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Monoid.html#t:First." target="_blank"><code>Data.Monoid.First</code></a> monoid.</p>
<p>The definition of <code>Alternative</code> begs this question: Why the <code>Applicative</code> superclass? As far as I know this is because the intended use of <code>empty</code> and <code>&lt;|&gt;</code> is in the applicative context. More on this later.</p>
<p>As we know, <code>MonadPlus</code> provides a similar semantics for monads. <code>Alternative</code> and <code>MonadPlus</code> are most commonly used with parsers. You are likely to use it with <em>aeson</em>, <em>parsec</em> / <em>megaparsec</em>, <em>attoparsec</em>, etc.<br />
In this post the focus is the <code>Alternative</code> with the typical right-catching, left-biased <code>&lt;|&gt;</code> and the examples typically use <em>attoparsec</em>.</p>
<p><em>Pessimist, First Look</em>:</p>
<ul>
<li><code>empty</code> does not accept any error information. It represents a failure of some unknown reason.<br />
I consider this problematic and an oversimplification.<br />
Unless we introduce a zero-information (let me call it <em>noOp</em>) failure, this probably will bite.<br />
I will leave it to you to ponder philosophical questions about <em>noOp</em> (e.g. <code>Left []</code>) failure.<br />
What does: nothing went wrong but the computation failed mean?<br />
</li>
<li><code>(&lt;|&gt;)</code> semantics is unclear about error information.</li>
<li><code>some</code> and <code>many</code> provide no error information about the failure that ended the production of the result list. I will not discuss <code>some</code> or <code>many</code> in this post.</li>
</ul>
<p>A somewhat popular behavior is: If all alternatives fail, then the error information comes from the last tried computation. Examples of alternatives that behave this way are: <em>attoparsec</em> <code>Parser</code>, <em>aeson</em> <code>Parser</code>, <code>IO</code>.</p>
<p>I am not that deeply familiar with GHC internals. However, as a black box, the GHC compiler often behaves in a very similar way. For example, GHC message could indicate a problem with unifying types; it may suggest that my function needs to be applied to more arguments; … while the real issue is that I am missing a typeclass instance somewhere or something else is happening that is completely not related to the error message. Generating useful compiler messages must be very hard and this is not a criticism of GHC but a familiar UX example.<br />
From time to time, GHC will throw Haskell developers for a loop.</p>
<p><strong>Side-Note:</strong> <em>parsec</em> and <em>megaparsec</em> packages implemented sophisticated ways to provide better error messages by looking at things like longest parsed path. Lack of backtracking is what makes the <em>(maga)parsec</em> <code>Parser</code> not a fully lawful <em>Alternative/MonadPlus</em> (violating <em>right zero</em>). The <em>megaparsec</em> haddock suggest adding <code>try</code> to improve the lawfulness. Adding <code>try</code> can mess up error messages. There appears to be an interesting pragmatic trade-off: <em>good error messages</em> vs <em>more lawful alternative behavior</em>.<br />
A great, related, reading is: <a href="http://blog.ezyang.com/2014/05/parsec-try-a-or-b-considered-harmful/" target="_blank">Parsec: “try a &lt;|&gt; b” considered harmful</a>.</p>
<p>A random advice from a discussion about <em>attoparsec</em> errors:</p>
<blockquote>
<p><em>The trick is to use the parsers library, which lets you switch out parsing backends. You can prototype with the trifecta library (which has good error messages) and then switch to attoparsec when you’re done</em></p>
</blockquote>
<p>(I assume that the author was thinking about parsing something, like a standard protocol, where user input cannot cause errors.)<br />
So, this is clearly a bit of a mess and we are looking for crazy workarounds. I will delve deeper into alternative error outputs by looking at the alternative laws next.</p>
<h2 id="alternative-laws-pessimistically">Alternative Laws, Pessimistically</h2>
<p>The required laws (copied from <a href="https://wiki.haskell.org/Typeclassopedia#Laws_6" target="_blank">Typeclassopedia</a>, see also <a href="https://en.wikibooks.org/wiki/Haskell/Alternative_and_MonadPlus#Alternative_and_MonadPlus_laws" target="_blank">Haskell wikibooks</a>) are:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>empty <span class="op">&lt;|&gt;</span> u  <span class="ot">=</span>  u    <span class="co">-- (1)</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>u <span class="op">&lt;|&gt;</span> empty  <span class="ot">=</span>  u    <span class="co">-- (2)</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>u <span class="op">&lt;|&gt;</span> (v <span class="op">&lt;|&gt;</span> w)  <span class="ot">=</span>  (u <span class="op">&lt;|&gt;</span> v) <span class="op">&lt;|&gt;</span> w  <span class="co">-- (3)</span></span></code></pre></div>
<p>Note that these laws do not link <code>Applicative</code> and <code>Alternative</code> in any way. That happens in the following, optional, set of laws:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>f <span class="op">&lt;*&gt;</span> empty <span class="ot">=</span> empty                        <span class="co">-- (4) Rigth Zero</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>(a <span class="op">&lt;|&gt;</span> b) <span class="op">&lt;*&gt;</span> c <span class="ot">=</span> (a <span class="op">&lt;*&gt;</span> c) <span class="op">&lt;|&gt;</span> (b <span class="op">&lt;*&gt;</span> c)  <span class="co">-- (5) Left Distribution</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>a <span class="op">&lt;*&gt;</span> (b <span class="op">&lt;|&gt;</span> c) <span class="ot">=</span> (a <span class="op">&lt;*&gt;</span> b) <span class="op">&lt;|&gt;</span> (a <span class="op">&lt;*&gt;</span> c)  <span class="co">-- (6) Right Distribution</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>(<span class="fu">pure</span> a) <span class="op">&lt;|&gt;</span> x <span class="ot">=</span> <span class="fu">pure</span> a                    <span class="co">-- (7) Left catch</span></span></code></pre></div>
<p>For example, when writing a parser you may decide to use one of these approaches:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>p1 <span class="ot">=</span> <span class="dt">Employee</span> <span class="op">&lt;$&gt;</span> employeeIdParser <span class="op">&lt;*&gt;</span> (nameParser1 <span class="op">&lt;|&gt;</span> nameParser2)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>p2 <span class="ot">=</span> (<span class="dt">Employee</span> <span class="op">&lt;$&gt;</span> employeeIdParser <span class="op">&lt;*&gt;</span> nameParser1) <span class="op">&lt;|&gt;</span> (<span class="dt">Employee</span> <span class="op">&lt;$&gt;</span> employeeIdParser <span class="op">&lt;*&gt;</span> nameParser2)</span></code></pre></div>
<p>it is good to know that these approaches are equivalent.</p>
<p>The laws are strong enough to restrict what failures can be (this is not necessarily a bad thing). For example, <em>(1)</em> and <em>(4)</em> prevent expressing the concept of a critical failure. A sane definition would be: <code>f</code> is a critical failure if <code>f &lt;|&gt; a = f</code> and <code>f &lt;*&gt; a = f</code> for any <code>a</code>.<br />
<code>empty</code> cannot represent a critical failure because of <em>(1)</em><br />
non-<code>empty</code> cannot represent a critical failure because of <em>(4)</em>.<br />
Critical failures are simply not what <code>Alternative</code> is about and that is OK.</p>
<p><em>Pessimist’s Concerns</em>:</p>
<ul>
<li><code>empty</code> typically represents a failure. <em>(4)</em> is problematic if you want to have other possible failures (e.g. failures with different error messages):<br />
<code>otherFailure &lt;*&gt; empty</code> is likely to be <code>otherFailure</code> not <code>empty</code>.<br />
</li>
<li><em>(1 - 3)</em> force a monoidal structure on the failures themselves (under a reasonable assumption that <code>empty</code> is a failure and alternating two failures produces a failure). This is a good property but instances often ignore it. A semigroup structure would make more pragmatic sense (i.e. what is <code>empty</code> error?).<br />
</li>
<li>Note that any instance of <code>Alternative</code> that tries to accumulate failures is likely to have a problem satisfying the distribution laws <em>(5,6)</em>, as the <em>rhs</em> combines 4 potential failures and <em>lhs</em> combines 3.<br />
Would you expect <em>(5,6)</em> to hold in the context of a failure (e.g. parser error messages)? My answer is: I do not! Violating these laws is not necessarily a bad thing. The end result is that the programmer needs to make an explicit choice between <code>p1</code> and <code>p2</code> selecting one with the more desirable error output. The trade-off is similar to one made by the <em>monad_validate</em> package linked at the end of this article.</li>
</ul>
<p>Let me return to the basic laws, particularly <em>(2)</em>: <code>u &lt;|&gt; empty  =  u</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Attoparsec.ByteString</span> <span class="kw">as</span> <span class="dt">A</span> </span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a><span class="ot">testSuccess ::</span> <span class="dt">A.Parser</span> a <span class="ot">-&gt;</span> <span class="dt">A.Result</span> a</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>testSuccess p <span class="ot">=</span> A.parse p <span class="st">&quot;foo&quot;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a><span class="ot">testFail ::</span> <span class="dt">A.Parser</span> a <span class="ot">-&gt;</span> <span class="dt">A.Result</span> a</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>testFail p <span class="ot">=</span> A.parse p <span class="st">&quot;bar&quot;</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>u <span class="ot">=</span> A.string <span class="st">&quot;foo&quot;</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a>lhs <span class="ot">=</span> u <span class="op">&lt;|&gt;</span> empty</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a>rhs <span class="ot">=</span> u</span></code></pre></div>
<p>Here are the results:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt; testFail lhs</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="co">-- Fail &quot;bar&quot; [] &quot;Failed reading: empty&quot;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt;  testFail rhs</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a><span class="co">-- Fail &quot;bar&quot; [] &quot;string&quot;</span></span></code></pre></div>
<p>So we broke the required second law. Incidentally, we would not be able to break this law using <code>testSuccess</code>.<br />
This should not be surprising, (1-3) imply a monoidal structure on failures and this is not what <em>attoparsec</em> does.</p>
<p><em>attoparsec</em> gets a lot of blame for its error output. Let’s try the <code>IO</code> alternative:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>uIO <span class="ot">=</span> <span class="fu">fail</span> <span class="st">&quot;foo&quot;</span><span class="ot"> ::</span> <span class="dt">IO</span> a</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>lhsIO <span class="ot">=</span> uIO <span class="op">&lt;|&gt;</span> empty</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>rhsIO <span class="ot">=</span> uIO</span></code></pre></div>
<p>ghci:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> lhsIO</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="op">***</span> <span class="dt">Exception</span><span class="op">:</span> user <span class="fu">error</span> (mzero)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> rhsIO</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a><span class="op">***</span> <span class="dt">Exception</span><span class="op">:</span> user <span class="fu">error</span> (foo)</span></code></pre></div>
<p>We see the same issue.</p>
<p>One way to look at this, and I believe this is how some programmers are looking at this issue, is that any failure with any error message is considered equivalent to <code>empty</code>. The laws hold if the error information is ignored. Somewhat of a downer if you care about errors.</p>
<p><strong>Side-Note:</strong> Numerous instances of <code>Alternative</code> manage to satisfy <em>(2)</em>.<br />
That includes <code>ExceptT</code>, the <code>Validatation</code> type listed at the end of this post. Here is the law working for ‘trifecta’</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Text.Trifecta</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>u <span class="ot">=</span> string <span class="st">&quot;foo&quot;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>lhs <span class="ot">=</span> parseTest (u <span class="op">&lt;|&gt;</span> empty) <span class="st">&quot;bar&quot;</span><span class="ot"> ::</span> <span class="dt">IO</span> ()</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>rhs <span class="ot">=</span> parseTest u <span class="st">&quot;bar&quot;</span><span class="ot"> ::</span> <span class="dt">IO</span> ()</span></code></pre></div>
<p>ghci:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> lhs</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>(interactive)<span class="op">:</span><span class="dv">1</span><span class="op">:</span><span class="dv">1</span><span class="op">:</span> <span class="fu">error</span><span class="op">:</span> expected<span class="op">:</span> <span class="st">&quot;foo&quot;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a><span class="dv">1</span> <span class="op">|</span> bar<span class="op">&lt;</span><span class="dt">EOF</span><span class="op">&gt;</span> </span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>  <span class="op">|</span> <span class="op">^</span>        </span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> rhs</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>(interactive)<span class="op">:</span><span class="dv">1</span><span class="op">:</span><span class="dv">1</span><span class="op">:</span> <span class="fu">error</span><span class="op">:</span> expected<span class="op">:</span> <span class="st">&quot;foo&quot;</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a><span class="dv">1</span> <span class="op">|</span> bar<span class="op">&lt;</span><span class="dt">EOF</span><span class="op">&gt;</span> </span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a>  <span class="op">|</span> <span class="op">^</span>    </span></code></pre></div>
<p>We will see the blueprint <code>Monoid</code> fix for <em>(2)</em> in the <a href="#either-e-a"><code>Either [e] a</code></a> section.</p>
<h2 id="real-world-alternative-optimism-with-experience">Real-World <code>Alternative</code> (Optimism with Experience)</h2>
<p>Here are some examples of problems arising from the use of <code>Alternative</code> semantics</p>
<h3 id="failure-at-the-end">Failure at the end</h3>
<p>Laws are important, functional programmers use laws (sometimes even subconsciously) when thinking about, implementing, or designing the code. The second law tells us that we can slap a computation that always errors out at the end without messing things up.</p>
<p>Consider this (a slightly adjusted real-world) situation: your app needs to talk to an external website which can decide to do A, B, or C and will reply with A, B, or C json message. Based on what happened, your app will need to do different things. You need to parse the reply to know how to proceed.<br />
The good news is that only A and B are needed in the short term, C can wait. For now, you are only required to tell the user when C happens.</p>
<p>This should be <em>aeson</em> but I keep <em>attoparsec</em> for consistency (the behavior is the same):</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a>parseReply <span class="ot">=</span> parseA <span class="op">&lt;|&gt;</span> parseB <span class="op">&lt;|&gt;</span> parseC </span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>    parseA <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>    parseB <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>    parseC <span class="ot">=</span> <span class="fu">fail</span> <span class="st">&quot;C is not supported yet!&quot;</span></span></code></pre></div>
<p>The external website changed how they report A, now when A is processed <code>parseA</code> fails, the user sees: “C is not supported yet!”.</p>
<p>The following would be a slightly better code, the user would see <code>parseB</code> error message instead:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a>parseReply <span class="ot">=</span> parseC <span class="op">&lt;|&gt;</span> parseA <span class="op">&lt;|&gt;</span> parseB </span></code></pre></div>
<p><em>(sigh)</em></p>
<p>One way out is to parse A, B, and C separately and handle the results (and the parsing errors) outside of the <code>Parser</code>.</p>
<p>The other design risk is in thinking about the second law as ‘stable’: We will not disturb the computation too much if we append (add at the end of the <code>&lt;|&gt;</code> chain) a very restrictive parser that fails most of the time.<br />
An example would be fixing an existing parser <code>p</code> with a missed corner case parser, <code>p &lt;|&gt; cornerCaseP</code>. Errors from <code>p</code> are now almost not visible.</p>
<p>So would <code>cornerCaseP &lt;|&gt; p</code> be a better solution? Next section covers that case.</p>
<h3 id="permissive-computation-at-the-end">Permissive computation at the end</h3>
<p>This is the example I started with. Consider code like this:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a>specificComputation <span class="op">&lt;|&gt;</span> bestEffortComputation</span></code></pre></div>
<p>The specs may change and you will never learn that <code>specificComputation</code> no longer works because <code>bestEffortComputation</code> effectively hides the issue.</p>
<p>The way out is to run <code>specificComputation</code> and <code>bestEffortComputation</code> separately and handle results (e.g. parsing errors if the computation is a parser) outside, or come up with a different way of not using the alternative.</p>
<p><em>Failure at the end</em> situation improves a bit with certain (other than <em>aeson</em> or <em>attoparsec</em>) alternatives, <em>Permissive computation at the end</em> does not seem to have a good available solution.</p>
<h2 id="pessimistic-instances">Pessimistic Instances</h2>
<p>It would be ideal if the following property was true:</p>
<p><em>If a typeclass A is defined in the <strong>base</strong> package and A has something to do with failures, then there exist at least one instance of <em>A</em> in the <strong>base</strong> allowing to recover the error information</em></p>
<p><code>MonadFail</code> fails this property (especially when combined with <code>MonadPlus</code>: <a href="https://rpeszek.github.io/posts/2021-01-17-maybe-overuse.html#monadfail-and-maybe" target="_blank">Maybe Overuse - MonadFail</a>).</p>
<p><code>Alternative</code> <del>fails it as well</del>. (<strong>EDIT Feb 13, 2021</strong>: It has been pointed out to me on <a href="https://www.reddit.com/r/haskell/comments/lj3h47/is_alternative_a_wrong_abstraction_for_handling/gnas3y2?utm_source=share&amp;utm_medium=web2x&amp;context=3" target="_blank">reddit by u/gcross</a> that this is <strong>not a fair criticism</strong>. <em>base</em> typeclass definition does not really claim any relationship to failures. I stand corrected on this. I still think that it would be very nice to have error information friendly instance of Alternative in <em>base</em>.)</p>
<p>Can we come up with <code>Alternative</code> instances that do a decent job of maintaining error information? It seems that the answer is yes.</p>
<h3 id="either-e-a"><code>Either [e] a</code></h3>
<p>This is a warm-up.</p>
<p>This instance is not new. It matches the <code>ExceptT</code> alternative instance from <em>transformers</em> / <em>mtl</em>. It uses standard <code>Either</code> monad and this is a <code>MonadPlus</code> (with a somewhat questionable right-zero law):</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Monoid</span> e <span class="ot">=&gt;</span> <span class="dt">Alternative</span> (<span class="dt">Either</span> e) <span class="kw">where</span> </span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>    empty  <span class="ot">=</span> <span class="dt">Left</span> <span class="fu">mempty</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>    <span class="dt">Left</span> e1 <span class="op">&lt;|&gt;</span> <span class="dt">Left</span> e2 <span class="ot">=</span> <span class="dt">Left</span> <span class="op">$</span> e1 <span class="op">&lt;&gt;</span> e2</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a>    (<span class="dt">Left</span> _) <span class="op">&lt;|&gt;</span> r <span class="ot">=</span> r</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>    r <span class="op">&lt;|&gt;</span> _ <span class="ot">=</span> r</span></code></pre></div>
<p><em>(Note: transformers package has a conflicting instance in the deprecated <code>Control.Monad.Trans.Error</code> module, in a real code a <code>newtype</code> would be needed to avoid this conflict)</em></p>
<p>I have included <code>Monoid e =&gt; Alternative (Either e)</code> instance as a warm-up and to discuss the laws.</p>
<p><strong>Laws:</strong><br />
The required <em>(1-3)</em> laws are satisfied without resorting to any sort of questionable reasoning that treats all errors as <code>empty</code>. However, <code>empty</code> represents a <em>noOp failure</em> computation (somewhat questionable meaning).</p>
<p>Optional <em>(4 Right Zero)</em> law (<code>f &lt;*&gt; empty = empty</code>) is questionable (consider <code>f = Left e</code> with a non-trivial <code>e</code>).<br />
<em>(7 Left Catch)</em> is OK.<br />
As we have predicted, the distribution laws are not satisfied.<br />
<em>(5)</em> is NOT satisfied:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a>(f <span class="op">&lt;|&gt;</span> g) <span class="op">&lt;*&gt;</span> a <span class="ot">=</span> (f <span class="op">&lt;*&gt;</span> a) <span class="op">&lt;|&gt;</span> (g <span class="op">&lt;*&gt;</span> a) </span></code></pre></div>
<p>If <code>f</code> and <code>g</code> represent successful computation and <code>a</code> is a list of errors then the <em>rhs</em> has twice as many errors as the <em>lhs</em>.</p>
<p><em>(6)</em> is not satisfied either:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a>f <span class="op">&lt;*&gt;</span> (b <span class="op">&lt;|&gt;</span> c) <span class="ot">=</span> (f <span class="op">&lt;*&gt;</span> b) <span class="op">&lt;|&gt;</span> (f <span class="op">&lt;*&gt;</span> c) </span></code></pre></div>
<p>If <code>f</code> represents a failed computation then <em>rhs</em> will duplicate <code>f</code> errors.<br />
This looks like a bigger problem than it really is. The <em>lhs</em> and <em>rhs</em> contain the same amount of error information.</p>
<p>So, overall, <code>Either [e] a</code> has done quite well as an alternative!</p>
<h3 id="a-decent-blueprint-either-e-e-a">A Decent Blueprint: <code>Either [e] ([e], a)</code></h3>
<p>What would really be nice, is to have a standard “right-catch with warnings” <code>Alternative</code> instance (please let me know if you have seen it somewhere on Hackage):</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">ErrWarn</span> e w a <span class="ot">=</span> <span class="dt">EW</span> {<span class="ot">runEW ::</span> <span class="dt">Either</span> e (w, a)} <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Functor</span>)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>  </span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a><span class="kw">instance</span> (<span class="dt">Monoid</span> e) <span class="ot">=&gt;</span> <span class="dt">Alternative</span> (<span class="dt">ErrWarn</span> e e) <span class="kw">where</span> </span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a>    empty  <span class="ot">=</span> <span class="dt">EW</span> <span class="op">$</span> <span class="dt">Left</span> <span class="fu">mempty</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a>    <span class="dt">EW</span> (<span class="dt">Left</span> e1) <span class="op">&lt;|&gt;</span> <span class="dt">EW</span> (<span class="dt">Left</span> e2) <span class="ot">=</span> <span class="dt">EW</span> (<span class="dt">Left</span> <span class="op">$</span> e1 <span class="op">&lt;&gt;</span> e2)</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a>    <span class="dt">EW</span> (<span class="dt">Left</span> e1) <span class="op">&lt;|&gt;</span> <span class="dt">EW</span> (<span class="dt">Right</span> (w2, r)) <span class="ot">=</span> <span class="dt">EW</span> <span class="op">$</span> <span class="dt">Right</span> (e1 <span class="op">&lt;&gt;</span> w2, r) <span class="co">-- coupling between @Either e@ and @(e,)@</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true"></a>    r<span class="op">@</span>(<span class="dt">EW</span> (<span class="dt">Right</span> _)) <span class="op">&lt;|&gt;</span> _ <span class="ot">=</span> r</span></code></pre></div>
<p>This approach, when computing <code>a &lt;|&gt; b</code>, does not try to compute <code>b</code> if <code>a</code> succeeds. Thus, this instance matches the common left bias semantics. The approach accumulates all errors encountered up to the point of the first success and returns them as warnings.<br />
This is a lawful <code>Alternative</code> (satisfies required laws <em>(1-3)</em>) and it does not rely on any questionable unification of <code>empty</code> with non-trivial errors.</p>
<p>I now feel justified using <code>Monoid e</code> constraint. Empty failure makes no sense, but empty warnings make a lot of sense!</p>
<p>But wait! To have <code>Alternative</code> we need <code>Applicative</code>. It is possible to implement <code>Applicative</code> for this type in more than one way, one even leads to a valid <code>Monad</code> and <code>MonadPlus</code> (with the right-zero caveat discussed above).<br />
That approach is equivalent to <code>WriterT w (Except e)</code>, it does not try to <code>&lt;*&gt;</code>-accumulate <code>e</code>-s, it only accumulates <code>w</code>-s:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="kw">instance</span> (<span class="dt">Monoid</span> w) <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">ErrWarn</span> e w) <span class="kw">where</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a>    <span class="fu">pure</span> x <span class="ot">=</span> <span class="dt">EW</span> <span class="op">$</span> <span class="dt">Right</span> (<span class="fu">mempty</span>, x)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a>    <span class="dt">EW</span> (<span class="dt">Left</span> e) <span class="op">&lt;*&gt;</span> _ <span class="ot">=</span> <span class="dt">EW</span> <span class="op">$</span> <span class="dt">Left</span> e</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a>    <span class="dt">EW</span> (<span class="dt">Right</span> (u, f)) <span class="op">&lt;*&gt;</span> <span class="dt">EW</span> (<span class="dt">Right</span> (v, x)) <span class="ot">=</span> <span class="dt">EW</span> (<span class="dt">Right</span> (u <span class="op">&lt;&gt;</span> v, f x))</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a>    <span class="dt">EW</span> (<span class="dt">Right</span> (u, f)) <span class="op">&lt;*&gt;</span> <span class="dt">EW</span> (<span class="dt">Left</span> e)  <span class="ot">=</span> <span class="dt">EW</span> <span class="op">$</span> <span class="dt">Left</span> e</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true"></a><span class="kw">instance</span> (<span class="dt">Monoid</span> w) <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">ErrWarn</span> e w) <span class="kw">where</span> </span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true"></a>    <span class="dt">EW</span> (<span class="dt">Left</span> e) <span class="op">&gt;&gt;=</span> _  <span class="ot">=</span> <span class="dt">EW</span> <span class="op">$</span> <span class="dt">Left</span> e</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true"></a>    <span class="dt">EW</span> (<span class="dt">Right</span> (u, x)) <span class="op">&gt;&gt;=</span> k <span class="ot">=</span> </span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true"></a>        <span class="kw">case</span> k x <span class="kw">of</span> </span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true"></a>            <span class="dt">EW</span> (<span class="dt">Right</span> (v, b)) <span class="ot">-&gt;</span> <span class="dt">EW</span> (<span class="dt">Right</span> (u <span class="op">&lt;&gt;</span> v, b))</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true"></a>            <span class="dt">EW</span> (<span class="dt">Left</span> e) <span class="ot">-&gt;</span> <span class="dt">EW</span> (<span class="dt">Left</span> e)</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true"></a></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true"></a><span class="kw">instance</span> (<span class="dt">Monoid</span> e) <span class="ot">=&gt;</span> <span class="dt">MonadPlus</span> (<span class="dt">ErrWarn</span> e e)    </span></code></pre></div>
<p>Please note the small difference. Standard <em>transformers</em> / <em>mtl</em> <code>ExeptT</code> and <code>WriterT</code> both support <code>Alternative</code></p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a> (<span class="dt">Monad</span> m, <span class="dt">Monoid</span> e) <span class="ot">=&gt;</span> <span class="dt">Alternative</span> (<span class="dt">ExceptT</span> e m)	</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a> (<span class="dt">Monoid</span> w, <span class="dt">Alternative</span> m) <span class="ot">=&gt;</span> <span class="dt">Alternative</span> (<span class="dt">WriterT</span> w m) <span class="co">-- Monoid only used to define @empty@</span></span></code></pre></div>
<p>but in a decoupled way, <code>ErrWarn</code> couples these two by “writing” <code>e</code>-s.</p>
<p>This instance exhibits similar problems with matching the <code>&lt;*&gt;</code> semantics as the <code>Monoid e =&gt; Either e</code> instance from the previous section (i.e. <em>(5,6)</em> are not satisfied). Overall it is a very well behaved alternative.</p>
<h3 id="code-example">Code Example</h3>
<p>Here is a very convoluted (and not very good) parsing code that is intended only to demonstrate how <code>ErrWarn</code> works. This code creates a natural transformation from the <em>attoparsec</em> parser to <code>ErrWarn</code> and compares the error outputs from both.</p>
<p>This code will parse <em>ByteStrings</em> like “id last-first-name dept boss2” to produce, if successful, a hard-coded <em>id, name, department, and boss name</em>:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a>idP <span class="ot">=</span> <span class="dv">123</span> <span class="ot">`onKeyword`</span> <span class="st">&quot;id&quot;</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a>nameP1 <span class="ot">=</span> <span class="st">&quot;Smith John&quot;</span>  <span class="ot">`onKeyword`</span> <span class="st">&quot;last-first-name&quot;</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a>nameP2 <span class="ot">=</span> <span class="fu">fail</span> <span class="st">&quot;first-last-name not implemented yet&quot;</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a>deptP <span class="ot">=</span>  <span class="st">&quot;Billing&quot;</span> <span class="ot">`onKeyword`</span> <span class="st">&quot;dept&quot;</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a>bossP1 <span class="ot">=</span> <span class="st">&quot;Jim K&quot;</span> <span class="ot">`onKeyword`</span> <span class="st">&quot;boss1&quot;</span>     </span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true"></a>bossP2 <span class="ot">=</span> <span class="st">&quot;Kim J&quot;</span> <span class="ot">`onKeyword`</span> <span class="st">&quot;boss2&quot;</span>    </span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true"></a>bossP3 <span class="ot">=</span> <span class="fu">pure</span> <span class="st">&quot;Mij K bosses everyone&quot;</span> </span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true"></a></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true"></a><span class="ot">onKeyword ::</span> a <span class="ot">-&gt;</span> <span class="dt">B.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">AT.Parser</span> <span class="dt">B.ByteString</span> a</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true"></a>onKeyword val key <span class="ot">=</span> <span class="fu">const</span> val <span class="op">&lt;$&gt;</span> A.manyTill ACh.anyChar</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true"></a>                    (A.lookAhead <span class="op">$</span> A.string key)</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true"></a>                    <span class="op">A.&lt;?&gt;</span> <span class="fu">show</span> key</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true"></a></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Employee</span> <span class="ot">=</span> <span class="dt">Employee</span> {</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true"></a><span class="ot">    id ::</span> <span class="dt">Int</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true"></a>    ,<span class="ot"> name ::</span> <span class="dt">String</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true"></a>    ,<span class="ot"> dept  ::</span> <span class="dt">String</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true"></a>    ,<span class="ot"> boss ::</span> <span class="dt">String</span></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true"></a>   } <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true"></a></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true"></a><span class="ot">emplP ::</span> <span class="dt">A.Parser</span> <span class="dt">B.ByteString</span> <span class="dt">Employee</span></span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true"></a>emplP <span class="ot">=</span> </span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true"></a>   <span class="dt">Employee</span> </span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true"></a>   <span class="op">&lt;$&gt;</span> idP</span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true"></a>   <span class="op">&lt;*&gt;</span> (nameP1 <span class="op">&lt;|&gt;</span> nameP2)</span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true"></a>   <span class="op">&lt;*&gt;</span> deptP</span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true"></a>   <span class="op">&lt;*&gt;</span> (bossP1 <span class="op">&lt;|&gt;</span> bossP2 <span class="op">&lt;|&gt;</span> bossP3) </span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true"></a></span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true"></a><span class="ot">emplP' ::</span> <span class="dt">B.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">ErrWarn</span> [<span class="dt">String</span>] [<span class="dt">String</span>] <span class="dt">Employee</span></span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true"></a>emplP' txt <span class="ot">=</span> </span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true"></a>   <span class="dt">Employee</span> </span>
<span id="cb20-32"><a href="#cb20-32" aria-hidden="true"></a>   <span class="op">&lt;$&gt;</span> ew idP </span>
<span id="cb20-33"><a href="#cb20-33" aria-hidden="true"></a>   <span class="op">&lt;*&gt;</span> (ew nameP1  <span class="op">&lt;|&gt;</span> ew nameP2 )</span>
<span id="cb20-34"><a href="#cb20-34" aria-hidden="true"></a>   <span class="op">&lt;*&gt;</span> ew deptP </span>
<span id="cb20-35"><a href="#cb20-35" aria-hidden="true"></a>   <span class="op">&lt;*&gt;</span> (ew bossP1  <span class="op">&lt;|&gt;</span> ew bossP2 <span class="op">&lt;|&gt;</span> ew bossP3)</span>
<span id="cb20-36"><a href="#cb20-36" aria-hidden="true"></a>   <span class="kw">where</span></span>
<span id="cb20-37"><a href="#cb20-37" aria-hidden="true"></a><span class="ot">        ew ::</span> <span class="dt">A.Parser</span> a  <span class="ot">-&gt;</span> <span class="dt">ErrWarn</span> [<span class="dt">String</span>] [<span class="dt">String</span>] a</span>
<span id="cb20-38"><a href="#cb20-38" aria-hidden="true"></a>        ew p <span class="ot">=</span> singleErr <span class="op">$</span> A.parseOnly p txt</span>
<span id="cb20-39"><a href="#cb20-39" aria-hidden="true"></a></span>
<span id="cb20-40"><a href="#cb20-40" aria-hidden="true"></a><span class="ot">        singleErr ::</span> <span class="dt">Either</span> e a <span class="ot">-&gt;</span> <span class="dt">ErrWarn</span> [e] [e] a</span>
<span id="cb20-41"><a href="#cb20-41" aria-hidden="true"></a>        singleErr (<span class="dt">Left</span> e) <span class="ot">=</span> <span class="dt">EW</span> <span class="op">$</span> <span class="dt">Left</span> [e]</span>
<span id="cb20-42"><a href="#cb20-42" aria-hidden="true"></a>        singleErr (<span class="dt">Right</span> r) <span class="ot">=</span> <span class="dt">EW</span> <span class="op">$</span> <span class="dt">Right</span> ([], r)</span></code></pre></div>
<p>Trying it with a good input:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt; A.parseOnly emplP &quot;id last-first-name dept boss1&quot;</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a><span class="co">-- Right (Employee {id = 123, name = &quot;Smith John&quot;, dept = &quot;Billing&quot;, boss = &quot;Jim K&quot;})</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt; emplP' &quot;id last-first-name dept boss1&quot;</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a><span class="co">-- EW {runEW = Right ([],Employee {id = 123, name = &quot;Smith John&quot;, dept = &quot;Billing&quot;, boss = &quot;Jim K&quot;})}</span></span></code></pre></div>
<p>Trying <a href="#failure-at-the-end">failure at the end</a> situation (typo in <code>"last-first-name"</code>):</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt; A.parseOnly emplP &quot;id last-firs-name dept boss2&quot;</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a><span class="co">-- Left &quot;Failed reading: first-last-name not implemented yet&quot;</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt; runEW $ emplP' &quot;id last-firs-name dept boss2&quot;</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a><span class="co">-- Left [&quot;\&quot;last-first-name\&quot;: not enough input&quot;,&quot;Failed reading: first-last-name not implemented yet&quot;]</span></span></code></pre></div>
<p>(A similar benefit can be achieved by using one of the Hackage <em>validation</em> packages listed at the end of this post or using the <code>ExceptT</code> alternative.)</p>
<p>Trying <a href="#permissive-computation-at-the-end">permissive computation at the end</a> situation (<code>"boss"</code> parsing error):</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt; A.parseOnly emplP &quot;id last-first-name dept boss&quot;</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a><span class="co">-- Right (Employee {id = 123, name = &quot;Smith John&quot;, dept = &quot;Billing&quot;, boss = &quot;Mij K bosses everyone&quot;})</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt;runEW $ emplP' &quot;id last-first-name dept boss&quot;</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a><span class="co">-- Right ([&quot;\&quot;boss1\&quot;: not enough input&quot;,&quot;\&quot;boss2\&quot;: not enough input&quot;],Employee {id = 123, name = &quot;Smith John&quot;, dept = &quot;Billing&quot;, boss = &quot;Mij K bosses everyone&quot;})</span></span></code></pre></div>
<p>(A similar benefit cannot be achieved by using a <em>validation</em> package from the list at the end of this post or a <em>transformers</em> stack. Please let me know if something like this exists elsewhere.)</p>
<p>We are no longer being thrown for a loop!</p>
<h3 id="extending-either-e-e-a">Extending <code>Either [e] ([e], a)</code></h3>
<p>The <em>right-catch with warnings</em> semantics of <code>Either [e] ([e], a)</code> is a decent principled computation that can be extended to other types. For example, a similar semantics could find its way into some parser internals.</p>
<p>I have created several prototype alternative instances (including a primitive <code>WarnParser</code> parser and <code>ErrWarnT</code> transformer) that follow the same semantics, they can be found in the linked <a href="https://github.com/rpeszek/experiments/tree/master/alternative" target="_blank">repo</a>.</p>
<p><code>ErrWarnT</code> allows to program in a <code>ErrWarnT e e f</code> alternative (e.g. <code>ErrWarnT e e Parser</code>) and annotate additional error information on <code>f</code> (e.g. during parsing). This allows, for example, to <em>pattern match on errors</em> to figure out which alternatives in <code>&lt;|&gt;</code> have failed even if the overall computation has succeeded.<br />
<code>WarnParser</code> accumulates <code>&lt;|&gt;</code> similar errors and warnings out of the box.</p>
<h2 id="rethinking-the-typeclass-itself">Rethinking the Typeclass Itself</h2>
<p>Is <code>Alternative</code> a wrong abstraction for alternating failing computations? I think it is. IMO any abstraction used for working with failures should include failures in its semantics. <code>Alternative</code> typeclass does not do that.</p>
<p><code>Alternative</code> is widely used and creating an ‘alternative’ to it will, probably, be very hard or even impossible. That typeclass would be useful only if the ecosystem accepted it.</p>
<p>One conceptually simple improvement would be to split <code>Alternative</code> to mimic the <code>Semigoup</code> / <code>Monoid</code> split (<em>semigroupoids</em> has <code>Data.Functor.Alt</code> which seems to fit the bill).<br />
This would clean up some instances like <code>ExceptT</code> (the above <a href="#either-e-a"><code>Either [e]</code></a>) or <a href="#relevant-work-on-hackage"><code>Validation</code></a> by reducing the need for questionable <code>empty</code> definitions like <code>Left []</code>. Incidentally, this would be the opposite of the <a href="https://wiki.haskell.org/MonadPlus_reform_proposal" target="_blank"><code>MonadZero</code></a> proposal.</p>
<p>I would really like to see <code>e</code>-s in the typeclass definition:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Semigroup1</span> f <span class="kw">where</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a><span class="ot">   (&lt;|&gt;)  ::</span> f a <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f a </span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">Applicative</span> (f e) <span class="ot">=&gt;</span> <span class="dt">Semigroup2</span> e f <span class="kw">where</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a><span class="ot">   (&lt;||&gt;)  ::</span> f e a <span class="ot">-&gt;</span> f e a <span class="ot">-&gt;</span> f e a </span></code></pre></div>
<p>The linked <a href="https://github.com/rpeszek/experiments/tree/master/alternative" target="_blank">repo</a> contains some loose replacement ideas for <code>Alternative</code> and <code>MonadPlus</code>. It is a work in progress.</p>
<h2 id="alternative-beyond-parsing"><code>Alternative</code> Beyond Parsing</h2>
<p>It should be mentioned that there are instances of <code>Alternative</code> such as the list <code>[]</code>, or <code>ZipList</code> where failures are not a concern. Sorting algorithms using MonadPlus are thumbs up. Examples like <code>LogicT</code> or other backtracking search mechanisms should be in the same boat (at least from the failure point of view, other aspects can be questionable and fascinating <a href="https://stackoverflow.com/questions/15722906/must-mplus-always-be-associative-haskell-wiki-vs-oleg-kiselyov" target="_blank">stackoverflow on mplus associativity</a>).</p>
<p>Also, these instances are rather cool.<br />
Languages like JavaScript, Python, Groovy have a concept of <em>truthiness</em>. <em>Truthy</em> <em>Falsy</em> are a thing and come with a Boolean algebra of sorts. Try evaluating this in you browser’s console:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a><span class="op">&gt;</span> <span class="st">&quot;hello&quot;</span> <span class="op">||</span> <span class="st">&quot;&quot;</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a><span class="st">&quot;hello&quot;</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a><span class="op">&gt;</span> <span class="st">&quot;&quot;</span> <span class="op">||</span> <span class="st">&quot;hello&quot;</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true"></a><span class="st">&quot;hello&quot;</span></span></code></pre></div>
<p><em>Truthiness</em> is questionable because the Boolean algebra laws (like <code>a || b = b || a</code>) no longer hold.</p>
<p>Now try these in ghci:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> <span class="st">&quot;&quot;</span> <span class="op">&lt;|&gt;</span> <span class="st">&quot;hello&quot;</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a><span class="st">&quot;hello&quot;</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> <span class="st">&quot;hello&quot;</span> <span class="op">&lt;|&gt;</span> <span class="st">&quot;&quot;</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true"></a><span class="st">&quot;hello&quot;</span></span></code></pre></div>
<p>Alternative is a principled version of the <em>truthiness</em>. The laws properly state the algebra limitations.<br />
As we have seen, the problem is in going with this generalization too far.</p>
<p><em>async</em> package uses <code>&lt;|&gt;</code> to return result form the computation that finishes first. This seems a good use to me.</p>
<p>Several types like <code>ExceptT</code>, <code>Validation</code> (see <a href="#relevant-work-on-hackage">hackage section</a> below) allow to use user defined monoid error types. <code>mempty</code> may not have much sense as an error, but this setup offers interesting options for accumulating errors. For example, using it with <code>Data.Monoid.Max</code> could be very interesting.</p>
<p><strong>Not so good:</strong><br />
An interesting case is the <code>STM</code> monad. <code>a &lt;|&gt; b</code> is used to chain computations that may want to <code>retry</code>. I imagine, composing <code>STM</code> computations this way is rare. If you wanted to communicate why <code>a</code> has decided to retry, how would you do that? I consider <code>STM</code> use of alternatives problematic.</p>
<p><code>IO</code> itself is an <code>Alternative</code> and uses <code>&lt;|&gt;</code> as a <code>catch</code> that throws away the error information. I dislike the <code>IO</code> instance. “Launching missiles” and not knowing what went wrong seems not ideal.</p>
<h2 id="relevant-work-on-hackage">Relevant work on Hackage</h2>
<p><a href="https://hackage.haskell.org/package/free" target="_blank"><em>free</em></a> package contains a semantic (free) version of <em>Alternative</em>.</p>
<p><a href="https://hackage.haskell.org/package/semigroupoids-5.3.5/docs/Data-Functor-Alt.html" target="_blank"><em>semigroupoids</em></a> offers <em>Alt</em> that is just a <em>Functor</em> and does not need to have <code>empty</code>.</p>
<p><a href="https://hackage.haskell.org/package/transformers-0.5.6.2" target="_blank"><em>transformers</em></a> ExceptT implements <code>Alternative</code> which accumulates “Lefts”.</p>
<p>A list of interesting packages that implement <code>Monoid</code>-like semantics for <code>Applicative</code> (most also implement <code>Alternative</code>) to accumulate errors provided by <a href="https://www.reddit.com/user/affinehyperplane/" target="_blank">u/affinehyperplane</a> on <a href="https://www.reddit.com/r/haskell/comments/kyo4xk/maybe_considered_harmful/gji7fmx?utm_source=share&amp;utm_medium=web2x&amp;context=3" target="_blank">reddit</a>:</p>
<p><a href="https://hackage.haskell.org/package/either-5.0.1.1/docs/Data-Either-Validation.html" target="_blank"><em>either</em></a> defines <code>Either</code> like <code>Validation e a</code> applicative, both <code>&lt;|&gt;</code> and <code>&lt;*&gt;</code> accumulate errors<br />
<a href="https://hackage.haskell.org/package/validation-1.1/docs/Data-Validation.html" target="_blank"><em>validation</em></a> defines a similar <code>Validation</code> type, it does not define alternative instance.<br />
<a href="https://hackage.haskell.org/package/validation-selective-0.1.0.0/docs/Validation.html" target="_blank"><em>validation-selective</em></a> defines a similar <code>Validation</code> type loaded with (non-monad) instances<br />
<a href="https://hackage.haskell.org/package/monad-validate-1.2.0.0/docs/Control-Monad-Validate.html" target="_blank"><em>monad-validate</em></a> provides an interesting and very useful validation <em>monad</em> transformer (this is lawful if you do not compare error outputs) that can accumulate errors, it does not implement <code>Alternative</code>.</p>
<p>In the context of parsers, it should be noted that packages like <em>trifecta</em>, <em>(mega)parsec</em> do nice job returning error messages when <code>&lt;|&gt;</code> fails.</p>
<p>A good references about Alternative and MonadPlus in general is the <a href="https://wiki.haskell.org/Typeclassopedia#Failure_and_choice:_Alternative.2C_MonadPlus.2C_ArrowPlus" target="_blank">Typeclassopedia</a> and <a href="https://en.wikibooks.org/wiki/Haskell/Alternative_and_MonadPlus" target="_blank">wikibooks</a>, both contain interesting links.</p>
<p>There are many stackoverflow answers about Haskell solutions to accumulating errors. These typically refer to some of the packages in the above list, I am not linking them here.<br />
There are many, many discussions about error output from different parsing libraries. These are typically focused on criticizing a particular package (typically <em>attoparsec</em>) not the <code>Alternative</code> typeclass itself.<br />
I am sure, this list is not complete. Please let me know if you see a relevant work elsewhere.</p>
<h2 id="conclusions-thoughts">Conclusions, Thoughts</h2>
<p>It is possible to implement instances that do a decent error management but it feels like this is accomplished despite of the <code>Alternative</code> typeclass definition and its laws. To answer my title: IMO <code>Alternative</code> is a wrong abstraction for managing computational failures.</p>
<p>The more I program in Haskell the more I view Functional Programming as a branch of Applied Mathematics.<br />
Criticizing mathematical abstractions does not make much sense. Criticism of how well an abstraction fits is application if a fair game.</p>
<p>Why errors are being overlooked? I assembled a possible list when writing about the <a href="https://rpeszek.github.io/posts/2021-01-17-maybe-overuse.html#why-maybe-is-overused-possible-explanations" target="_blank">Maybe Overuse</a> and that list seems to translate well to the alternative typeclass. For example, code using <code>&lt;|&gt;</code> is very terse, something with a stronger error semantics will most likely be more verbose; coding with <code>&lt;|&gt;</code> is simple, stronger error semantics will likely be more complex …<br />
I could be wrong on this: the original usages of MonadPlus were probably related to sorting/searching and lists. Alternative computations with more complex error structure were probably introduced later? … and, the instances ended up outgrowing the typeclass?</p>
<p>The <em>pessimist</em> theme was partially inspired by the following two concepts:<br />
<a href="https://link.springer.com/referenceworkentry/10.1007%2F978-94-007-0753-5_2219#:~:text=Definition,favor%20positive%20information%20in%20reasoning." target="_blank"><em>Positivity Bias</em></a> and, its opposite, the <a href="https://en.wikipedia.org/wiki/Negativity_bias" target="_blank"><em>Negativity Bias</em></a> are psychological notions that, I believe, have a deep relevance to the programming in general.<br />
<em>Positivity Bias</em> includes a <em>tendency to favor positive information in reasoning</em> and, by definition, will make you think about “happy path” and “sunny day scenarios”.<br />
<em>Negativity Bias</em> includes a <em>tendency to favor negative information in reasoning</em> and, by definition, will make you consider “rainy day scenarios”, corner cases, error handling, error information.<br />
I think we should embrace some form of <em>pessimism</em> and put in on the pedestal next to the principled construction.</p>
<p>I hope this post will motivate more discussion about the <em>error information</em> handling in Haskell.<br />
My particular interest is in discussing:</p>
<ul>
<li>your views about rethinking the <code>Alternative</code> typeclass</li>
<li>your views on pessimism in programming</li>
<li>your views on the error information loss in Haskell code</li>
<li>is <code>ErrWarn</code> somewhere on Hackage and I did not see it?</li>
<li>other interesting <code>Alternative</code> instances that care about errors</li>
<li>obviously, anything that I got wrong</li>
</ul>
<p><a href="https://www.reddit.com/r/haskell/comments/lj3h47/is_alternative_a_wrong_abstraction_for_handling/" target="_blank">reddit</a> discussion<br />
github <a href="https://github.com/rpeszek/rpeszek.github.io/discussions/1" target="_blank">discussions</a></p>
<p>Thank you for reading!</p>
<h3 id="readers-response">Reader’s Response</h3>
<p>Common critical response on reddit (2021-02-15) can be summarized as: Alternative should not be used like this and there are better ways of writing such code.</p>
<blockquote>
<p>“it seems a bit odd, to me, to criticize and talk about rethinking a typeclass because it does something that it was never intended to do”<br />
“people should be using a typeclass designed for handling errors”<br />
“maybe you are asking too much to Alternative”</p>
</blockquote>
<p>The <code>ErrWarn</code> blueprint or other instances with strong error information preserving abilities were not discussed.</p>
<p>There appears to be mixed response to the error information loss being a problem in general. Some readers claim that this is not a problem, some seem to share my concern.</p>
<p><strong>Author’s Defense</strong></p>
<p>I agree with the: “Alternative should not be used like this”.</p>
<p>Alternative is an example of an abstraction that is very easy to use, it makes coding fast.<br />
It most likely will end up being used (I have seen it) in ways similar to what I described in this post.<br />
It is important that the developers are aware of the gotchas that come with some of the instances.</p>
<p>Any code (alternative or not) producing confusing error output is a concern.<br />
IMO, every abstraction and every instance needs to be concerned about the error output quality. <em>Not being designed for error handling</em> should not be a thing. At the same time, error friendlier instances should be a good thing.</p>

    </section>
</article>
]]></description>
    <pubDate>Sat, 13 Feb 2021 00:00:00 UT</pubDate>
    <guid>https://rpeszek.github.io//posts/2021-02-13-alternative.html</guid>
    <dc:creator>Robert Peszek</dc:creator>
</item>
<item>
    <title>Maybe Overuse, Stories About Error Information Loss</title>
    <link>https://rpeszek.github.io//posts/2021-01-17-maybe-overuse.html</link>
    <description><![CDATA[<article>
    <section class="header">
        Posted on January 17, 2021
        
            by Robert Peszek
        
        
          <br /> Last Modified on February 17, 2021
        
        
        <div class="changelog"> <div>Revision History: <ul> <li> (2021.01.18) Added <a href="#monadfail-and-maybe">MonadFail</a> subsection to <a href="#maybe-on-hackage">Maybe on Hackage</a> </li> <li> (2021.02.17-now) <a href="#more-links">More Links</a> (list of related links)</li> </ul> </div></div>
        
        
        <div class="info">Tags: <a title="All pages tagged 'Haskell'." href="../tags/Haskell.html">Haskell</a>, <a title="All pages tagged 'error-messages'." href="../tags/error-messages.html">error-messages</a>, <a title="All pages tagged 'maintainability'." href="../tags/maintainability.html">maintainability</a></div>
        
    </section>
    <section>

    </section>
    <section>
        <div class="toc"><div class="header">Table of Contents</div>
<ul>
<li><a href="#nutshell">Nutshell</a></li>
<li><a href="#error-clarity-rule">Error Clarity Rule</a></li>
<li><a href="#harmful-real-world-examples">Harmful Real-World Examples</a>
<ul>
<li><a href="#maybe-on-hackage"><code>Maybe</code> on Hackage</a></li>
<li><a href="#cut-catmaybes">Cut <code>catMaybes</code></a></li>
<li><a href="#hkd-pattern">HKD pattern</a></li>
<li><a href="#traversable-with-maybe"><code>Traversable</code> with <code>Maybe</code></a></li>
</ul></li>
<li><a href="#questioning-record-types-with-all-maybe-fields">Questioning Record Types with all <code>Maybe</code> Fields</a>
<ul>
<li><a href="#recreating-java-beans-with-maybe">Recreating <em>Java Beans</em> with <code>Maybe</code> ;)</a></li>
<li><a href="#maybe-first-monoid-fields"><em>Maybe-First</em> <code>Monoid</code> fields</a></li>
</ul></li>
<li><a href="#alternative-typeclass"><code>Alternative</code> typeclass</a></li>
<li><a href="#good-uses-of-maybe">Good uses of Maybe</a></li>
<li><a href="#why-maybe-is-overused-possible-explanations">Why <code>Maybe</code> is Overused? Possible Explanations</a></li>
<li><a href="#more-links">More Links</a></li>
</ul>
</div>
<h4 id="motivating-references">Motivating References:</h4>
<p>I was very happy to find Michael Snoyman’s <a href="https://www.snoyman.com/blog/2020/10/haskell-bad-parts-1/" target="_blank">Haskell The Bad Parts</a> series.<br />
I was also motivated by <a href="https://www.michaelpj.com/blog/2021/01/02/elementary-programming.html" target="_blank">Elementary Programming</a> post (<a href="https://www.reddit.com/r/haskell/comments/kst0d3/elementary_programming/" target="_blank">reddit</a>).</p>
<p><strong>Similar:</strong> <a href="https://www.reddit.com/r/haskell/comments/jxj8i/data_maybe_harmful/" target="_blank">reddit data_maybe_harmful</a></p>
<p>This post is Haskell specific.<br />
This post treats the term error colloquially, it does not distinguish between <a href="https://wiki.haskell.org/Error_vs._Exception" target="_blank"><em>exceptions</em> and <em>errors</em></a>. In particular, <em>error information loss</em> refers to exceptions not errors.</p>
<h2 id="nutshell">Nutshell</h2>
<p><code>Maybe</code> is the functional answer to <code>null</code> - the <a href="https://en.wikipedia.org/wiki/Tony_Hoare" target="_blank">billion dollar mistake</a>. I claim that using <code>Maybe</code> can still be problematic.</p>
<p>IMO <code>Maybe</code> is often overused. I have started to question the use of <code>Maybe</code> every time I see it in the code base I maintain. The result is either accepting its usage or rewriting the code to use <code>Either</code>. This approach has been effective in creating more robust code. I am not claiming that <code>Maybe</code> has no place in a well written code, only that its use should be closely examined. I have seen brilliant code that has been hard to maintain because of its overuse of <code>Maybe</code>. This post shares a perspective of someone who maintains a complex Haskell code base.</p>
<p><code>Maybe</code> improves over <code>null</code>. But it does not supersede it. Languages that have <code>null</code> also have easy access to logging, stack traces etc.</p>
<p><code>Maybe</code> typically represents data that can be <em>missing</em> or a computation that can result in an <em>unknown error</em>.<br />
What you typically care about is <em>what data is missing</em> and <em>what is the error</em>.</p>
<p><em>Code correctness</em>, <em>reasoning about code</em> are, arguably, the defining aspects of FP. <em>Reasoning about code</em> typically refers to some advanced use of the type system or formal methods. IMO “reasoning about code” should start with reasoning about errors and corner cases (like missing data). This is why the use of <code>Maybe</code> needs to be examined and questioned. In my experience this aspect of reasoning about code is often overlooked.</p>
<p>Reasoning about errors is not easy: The type system can’t help with errors that bypass it (e.g. <code>error :: String -&gt; a</code>). It can’t help with exceptions which were intentionally suppressed into <code>Nothing</code> <em>(the focus of this post)</em>. And, the list goes on…</p>
<p>My points / pleas are:</p>
<ul>
<li>The ecosystem would be better off without offering convenience combinators that return <code>Maybe</code> if an equivalent returning <code>Either</code> exists</li>
<li>Examples, tutorials, and blog posts should favor <code>Either</code> over <code>Maybe</code></li>
<li>Developers should be careful about not overusing <code>Maybe</code></li>
</ul>
<h2 id="error-clarity-rule">Error Clarity Rule</h2>
<p><em>What does <code>Nothing</code> mean? If the reason behind it can be disambiguated to one root cause, then I consider the use of <code>Maybe</code> justified. Otherwise, I question its use.</em></p>
<p>Consider this code:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Data.Map</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Key</span> <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Value</span> <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a><span class="co">-- OK</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a><span class="ot">phone ::</span> <span class="dt">Map</span> <span class="dt">Key</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Value</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>phone <span class="ot">=</span> <span class="fu">lookup</span> <span class="st">&quot;phone&quot;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a><span class="co">-- OK</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a><span class="ot">email ::</span> <span class="dt">Map</span> <span class="dt">Key</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Value</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a>email <span class="ot">=</span> <span class="fu">lookup</span> <span class="st">&quot;email&quot;</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true"></a><span class="co">-- OK</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true"></a><span class="ot">creditCardNum ::</span> <span class="dt">Map</span> <span class="dt">Key</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Value</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true"></a>creditCardNum <span class="ot">=</span> <span class="fu">lookup</span> <span class="st">&quot;card-number&quot;</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">FormData</span> <span class="ot">=</span> <span class="dt">FormData</span> {</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true"></a><span class="ot">   fdPhone ::</span> <span class="dt">Value</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true"></a>   ,<span class="ot"> fdEmail ::</span> <span class="dt">Value</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true"></a>   ,<span class="ot"> fdCardNum ::</span> <span class="dt">Value</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true"></a>   }</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true"></a><span class="co">-- less OK</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true"></a><span class="ot">formData ::</span> <span class="dt">Map</span> <span class="dt">Key</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">FormData</span>  </span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true"></a>formData <span class="fu">map</span> <span class="ot">=</span> <span class="dt">FormData</span> <span class="op">&lt;$&gt;</span> phone <span class="fu">map</span> <span class="op">&lt;*&gt;</span> email <span class="fu">map</span> <span class="op">&lt;*&gt;</span> creditCardNum <span class="fu">map</span> </span></code></pre></div>
<p>you can clearly explain the first 3 functions:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="ot">explain ::</span> err <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Either</span> err a</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>explain <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Err</span> <span class="ot">=</span> <span class="dt">MissingEmail</span> <span class="op">|</span> <span class="dt">MissingPhone</span> <span class="op">|</span> <span class="dt">MissingCardNum</span> </span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a><span class="ot">email' ::</span> <span class="dt">Map</span> <span class="dt">Key</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">Err</span> <span class="dt">Value</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>email' <span class="ot">=</span> explain <span class="dt">MissingEmail</span> <span class="op">.</span> email</span></code></pre></div>
<p>How do I explain <code>formData</code>? I am stuck with:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">UnknownFieldMissing</span> <span class="ot">=</span> <span class="dt">UnknownFieldMissing</span> </span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a><span class="ot">formData' ::</span> <span class="dt">Map</span> <span class="dt">Key</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">Err</span> <span class="dt">Value</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>formData' <span class="ot">=</span> explain <span class="dt">UnknownFieldMissing</span> <span class="op">.</span> formData</span></code></pre></div>
<p>and that “Unknown” is not a field name.<br />
The bigger the record, the bigger the problem.</p>
<h2 id="harmful-real-world-examples">Harmful Real-World Examples</h2>
<p>These are in no particular order, other than this presentation reuses types defined earlier.</p>
<h3 id="maybe-on-hackage"><code>Maybe</code> on Hackage</h3>
<h4 id="servant-multipart-example"><em>servant-multipart</em> example:</h4>
<p>If you used older versions of <a href="https://hackage.haskell.org/package/servant-multipart" target="_blank">servant-multipart</a> you are familiar with</p>
<p><em>status code 400, message “fromMultipart returned Nothing”</em>.</p>
<p>You must have noticed that your logs have been silent as well.<br />
The fix was implemented in 0.11.6</p>
<p>New version (much better):</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="co">-- version 0.11.6</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">FromMultipart</span> tag a <span class="kw">where</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a><span class="ot">   fromMultipart ::</span> <span class="dt">MultipartData</span> tag <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> a</span></code></pre></div>
<p>Old version:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="co">-- version 0.11.5</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">FromMultipart</span> tag a <span class="kw">where</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a><span class="ot">  fromMultipart ::</span> <span class="dt">MultipartData</span> tag <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span></code></pre></div>
<p>Any typo, missed form field, wrong form field type submitted from the calling program resulted in a meaningless 400 error.<br />
To work around this issue I ended up implementing <code>fromMultipart</code> in <code>Either MultiformError</code> monad and converting it to <code>Maybe</code> with something like that:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="ot">loggedMultipartMaybe ::</span>  <span class="dt">Either</span> <span class="dt">MultipartException</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>loggedMultipartMaybe (<span class="dt">Left</span> err) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>    <span class="kw">let</span> logDetails <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>    <span class="fu">seq</span> </span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>      (debugLogger logDetails) <span class="co">-- uses unsafePeformIO to match your logging style</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>      <span class="dt">Nothing</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>loggedMultipartMaybe (<span class="dt">Right</span> r) <span class="ot">=</span> <span class="dt">Just</span> r </span></code></pre></div>
<p>to, at least, get some logs.</p>
<p>In just one project, that saved me hours in both new development and troubleshooting cost.<br />
For a more complex multipart form that implements both <code>FromMultipart</code> and <code>ToMultipart</code> by hand, verifying that <code>fromMultipart . toMultipart</code> is the identity would have been very hard without some information about errors. If the multipart is called from a different program, different language …</p>
<h4 id="convenience-combinators">Convenience Combinators:</h4>
<p>It should be noted that many popular packages offer convenience <code>Maybe</code> functions even though it is very easy to write this natural transformation:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="ot">unExplain ::</span> <span class="dt">Either</span> err a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span></code></pre></div>
<p>Why is that? Why not just provide <code>Either</code> versions? Looking at <em>aeson</em> as an example:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="ot">decode ::</span> <span class="dt">FromJSON</span> a <span class="ot">=&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="ot">eitherDecode ::</span> <span class="dt">FromJSON</span> a <span class="ot">=&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> a </span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a><span class="ot">parseEither ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Parser</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> b </span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a><span class="ot">parseMaybe ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Parser</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b </span></code></pre></div>
<p>the name <code>decode</code> is suggestive of being the one commonly used.</p>
<p>Having <code>aeason</code> in the spotlight, I like this part of their <a href="https://hackage.haskell.org/package/aeson-1.5.5.1/docs/Data-Aeson-Types.html##v:parse" target="_blank">documentation</a>:</p>
<blockquote>
<p><em>The basic ways to signal a failed conversion are as follows:</em></p>
<ul>
<li><em>fail yields a custom error message: it is the recommended way of reporting a failure;</em></li>
<li><em>empty (or mzero) is uninformative: use it when the error is meant to be caught by some (&lt;|&gt;);</em></li>
</ul>
</blockquote>
<p>Overuse of <code>mzero</code> in parsing code is as bad as the overuse of <code>Maybe</code>.</p>
<h4 id="monadfail-and-maybe"><code>MonadFail</code> and <code>Maybe</code>:</h4>
<p>Number of packages try to be polymorphic and use <code>MonadFail</code> constraint to provide information about unexpected errors (e.g. <em>time</em>, <em>mongoDB</em>). Sadly <em>base</em> provides no standard way to retrieve this information. The <a href="https://gitlab.haskell.org/ghc/ghc/-/issues/12160" target="_blank">ticket</a> to add <code>Either String</code> instance is a no-go for now.</p>
<p>The packages which use <code>MonadFail</code> do not offer convenience <code>MonadFail</code> monads either. It seems wrong and asymmetric to force the caller to define their type for retrieving error information.</p>
<p>But <code>MonadFail</code> has <code>Maybe</code> instance! I strongly believe in <em>make writing good code easy, bad code hard</em> design principle. This is clearly violated here.</p>
<p>Also, notice this part of documentation (in <em>base</em> Control.Monad.Fail):</p>
<blockquote>
<p>If your Monad is also MonadPlus, a popular definition is</p>
<p><code>fail _ = mzero</code></p>
</blockquote>
<p><em>(quiet sob)</em></p>
<h3 id="cut-catmaybes">Cut <code>catMaybes</code></h3>
<p>Replacing</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="ot">catMaybes ::</span> [<span class="dt">Maybe</span> a] <span class="ot">-&gt;</span> [a]</span></code></pre></div>
<p>with</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="ot">partitionEithers ::</span> [<span class="dt">Either</span> e a] <span class="ot">-&gt;</span> ([e], [a])</span></code></pre></div>
<p>very often improves the robustness of code.</p>
<p>Consider <code>Contact</code> record type with <code>cEmail :: Maybe Email</code> field. We can get</p>
<ul>
<li>lists of emails by using <code>catMaybes</code></li>
<li>list of emails and the information which <code>Contact</code>-s do not have an email using <code>partitionEithers</code>.</li>
</ul>
<p>The <code>Contact</code> list could come from a parsed JSON and could contain a list of company employees or is a parsed mail-mime <em>CC:</em> header. Missing email should be rare.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Control.Arrow</span> ((&amp;&amp;&amp;))</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a><span class="co">-- maybe version</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a><span class="ot">getEmails ::</span> [<span class="dt">Contact</span>] <span class="ot">-&gt;</span> [<span class="dt">Email</span>]</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>getEmails <span class="ot">=</span> catMaybes <span class="op">.</span> <span class="fu">map</span> cEmail</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a><span class="co">-- either version</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">MissingData</span> a <span class="ot">=</span> <span class="dt">MissingEmailData</span> a <span class="op">|</span> <span class="op">...</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true"></a><span class="ot">getEmails' ::</span> [<span class="dt">Contact</span>] <span class="ot">-&gt;</span> ([<span class="dt">MissingData</span> <span class="dt">Contact</span>], [<span class="dt">Email</span>])</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true"></a>getEmails' <span class="ot">=</span> partitionEithers <span class="op">.</span> <span class="fu">map</span> (<span class="fu">uncurry</span> explain <span class="op">.</span> (<span class="dt">MissingEmailData</span> <span class="op">&amp;&amp;&amp;</span> cEmail))</span></code></pre></div>
<p>These are “it is rare, therefore can be ignored” vs “it is rare and therefore cannot be ignored” approaches.<br />
I do not know what is the proper name for software that does not handle corner cases. I call it <em>expensive</em> ;)<br />
I question the use of <code>catMaybes</code> every time I see it.</p>
<p>I try to be terse in the above example, but it is clear that <code>Either</code> is more work. Terseness and ease of programming are IMO some of the reasons for <code>Maybe</code> overuse.</p>
<h3 id="hkd-pattern">HKD pattern</h3>
<p>Higher-Kinded Data pattern is super cool and can be very useful. This post explains what it is: <a href="https://reasonablypolymorphic.com/blog/higher-kinded-data/" target="_blank">reasonablypolymorphic on HKD pattern</a>. My example follows <em>reasonablypolymorphic</em> blog closely.</p>
<p>In nutshell, we can create a record type like</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Person</span> f <span class="ot">=</span> <span class="dt">Person</span> { </span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a><span class="ot">    pName ::</span> f <span class="dt">String</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>  ,<span class="ot"> pAge  ::</span> f <span class="dt">Int</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>  <span class="co">-- imagine a lot more fields here</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a>  } </span></code></pre></div>
<p>parametrized by a type of kind <code>* -&gt; *</code> e.g. <code>Maybe</code> or <code>Identity</code>. All or some of the fields in that record type have an <code>f</code> in front of them.<br />
<em>HKD Patter</em> is about using generic programming to transform that record based on operations that work on the fields.<br />
For example, we can hoist <code>forall a . f a -&gt; g a</code> functions to <code>hkd f -&gt; hkd g</code> (here <code>Person f -&gt; Person g</code>).</p>
<p>Imagine that <code>Person</code> has a long list of fields and there is a web form for entering them.<br />
The post descibes a completely generic validation function that, when restricted to our <code>Person</code> type, looks like this:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="ot">validate ::</span> <span class="dt">Person</span> <span class="dt">Maybe</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Person</span> <span class="dt">Identity</span>)</span></code></pre></div>
<p>I hate when this is done to me: it took 5 minutes to enter the information, the submit button is grayed out, and I see no way to move forward. Typically, when that happens, it is caused by a JavaScript error.</p>
<p>In this example it is not a programming bug, it is a design decision: a very sophisticated way to check that user entered all fields that does not provide information about which fields they missed.<br />
Web form data entry aside, I challenge you to find one meaningful example where the above <code>validate</code> is useful. A one off data science code that processes massive amount of data and requires all fields to be present to be useful? All examples I can come up with seem far-fetched and still would benefit from having <code>Either</code>.</p>
<p>Questions I am asking:</p>
<ul>
<li>Would you expect a production code somewhere out there that validates user input using HKD pattern and actually uses <code>Maybe</code>?</li>
<li>Did <em>reasonablypolymorphic</em> confuse or simplify things by using <code>Maybe</code> in its example?</li>
</ul>
<p>In <em>reasonablypolymorphic</em> post <code>Maybe</code> is not just in the <code>validate</code> function. The post defines the whole <code>GValidate</code> boilerplate that assumes <code>Maybe</code>.</p>
<p>Fortunately, the approach can be generalized to other <code>f</code> types.<br />
A meaningful validation would have a type</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">FieldInfo</span> <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a><span class="ot">validate ::</span> <span class="dt">Person</span> <span class="dt">Maybe</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> [<span class="dt">FieldInfo</span>] (<span class="dt">Person</span> <span class="dt">Identity</span>)</span></code></pre></div>
<p>This is arguably more work to do and beyond what <em>HKD pattern</em> can offer. However, it is quite possible to do something like this generically:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">FieldInfo</span> <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a><span class="ot">validate ::</span> <span class="dt">Person</span> (<span class="dt">Either</span> <span class="dt">FieldInfo</span>) <span class="ot">-&gt;</span> <span class="dt">Either</span> [<span class="dt">FieldInfo</span>] (<span class="dt">Person</span> <span class="dt">Identity</span>)</span></code></pre></div>
<p>Check out the documentation for the <a href="https://hackage.haskell.org/package/barbies" target="_blank">barbies</a> package, it comes with exactly this example! Notice, some boilerplate work is still needed to annotate missing values with field information:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="ot">addFieldInfo ::</span>  <span class="dt">Person</span> <span class="dt">Maybe</span> <span class="ot">-&gt;</span> <span class="dt">Person</span> (<span class="dt">Either</span> <span class="dt">FieldInfo</span>) </span></code></pre></div>
<p><code>addFieldInfo</code> would need to happen outside of the <em>HKD pattern</em>.<br />
One can argue that a better solution would be not to use <code>Person Maybe</code> and convert user form data entry directly to <code>Person (Either FieldInfo)</code>.</p>
<h3 id="traversable-with-maybe"><code>Traversable</code> with <code>Maybe</code></h3>
<p><em>barbies</em> validation of <code>Person</code> required a traversal of the <em>HKD</em> type. So, maybe, we should consider a somewhat simpler design where fields are unified into one type. Keeping up with the <em>reasonablypolymorphic</em> example:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="ot">{-## LANGUAGE DeriveFunctor ##-}</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a><span class="ot">{-## LANGUAGE DeriveFoldable ##-}</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a><span class="ot">{-## LANGUAGE DeriveTraversable ##-}</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Person'</span> a <span class="ot">=</span> <span class="dt">Person'</span> { </span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a><span class="ot">    pName' ::</span> a</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true"></a>  ,<span class="ot"> pAge'  ::</span> a</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true"></a>  <span class="co">-- imagine a lot more fields here</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true"></a>  } <span class="kw">deriving</span> (<span class="op">...</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Traversable</span>)</span></code></pre></div>
<p>And “now we are cooking with gas”!</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">FieldData</span> <span class="ot">=</span> <span class="op">...</span> <span class="co">-- unifying type for Person' fields</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a><span class="ot">validateMaybe ::</span> <span class="dt">Person'</span> (<span class="dt">Maybe</span> <span class="dt">FieldData</span>) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Person'</span> <span class="dt">FieldData</span>)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a>validateMaybe <span class="ot">=</span> <span class="fu">traverse</span> <span class="fu">id</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a><span class="ot">validateEither ::</span> <span class="dt">Person'</span> (<span class="dt">Either</span> <span class="dt">FieldInfo</span> <span class="dt">FieldData</span>) <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">FieldInfo</span> (<span class="dt">Person'</span> <span class="dt">FieldData</span>)</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true"></a>validateEither <span class="ot">=</span> <span class="fu">traverse</span> <span class="fu">id</span></span></code></pre></div>
<p>New <code>validateEither</code> is not as good as the <em>barbies</em> version. It gives the user only one of the fields they missed.<br />
IMO <code>validateMaybe</code> is useless for any data entry form validation.</p>
<p>The <code>validateMaybe</code> example is here for a reason. It directly mimics the example discussed in <a href="https://www.michaelpj.com/blog/2021/01/02/elementary-programming.html" target="_blank">Elementary Programming</a>, which used</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="ot">mapMaybe ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [b]</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a>mapMaybe <span class="ot">=</span> <span class="fu">traverse</span></span></code></pre></div>
<p>as its only example.</p>
<p><code>Maybe</code> is viral.</p>
<h2 id="questioning-record-types-with-all-maybe-fields">Questioning Record Types with all <code>Maybe</code> Fields</h2>
<p>Besides being a natural fit for data coming from something like a web form, there are other reasons for designing record types with many <code>Maybe</code> fields.<br />
Here is my attempt at debunking some of them.</p>
<h3 id="recreating-java-beans-with-maybe">Recreating <em>Java Beans</em> with <code>Maybe</code> ;)</h3>
<p>Defining record types with many <code>Maybe</code> fields allows to construct such records easily if you care about only some of the fields.</p>
<p>This can be done via some <code>empty</code> defaulting mechanism (I will use the <code>Person</code> type defined above to serve as an example):</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="ot">emptyPerson ::</span> <span class="dt">Person</span> <span class="dt">Maybe</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a>emptyPerson <span class="ot">=</span> <span class="dt">Person</span> <span class="dt">Nothing</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>or with a use of <code>Monoid</code> and <code>mempty</code>. <code>emptyPerson</code> could be defined in a generic way as well (see <a href="https://hackage.haskell.org/package/hkd-default" target="_blank">hkd-default</a>).</p>
<p>Say, your code cares about <code>pAge</code> only, you can just set <code>pAge</code>:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="ot">isDrinkingAge ::</span> <span class="dt">Person</span> <span class="dt">Identity</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a>isDrinkingAge p <span class="ot">=</span> runIdentity (pAge p) <span class="op">&gt;=</span> <span class="dv">21</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a>test10YearOld <span class="ot">=</span> emptyPerson {pAge <span class="ot">=</span> <span class="dt">Identity</span> <span class="dv">10</span>}</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a>test <span class="ot">=</span> isDrinkinAge test10YearOld</span></code></pre></div>
<p>I do not like this approach. It feels like a poorly typed code.</p>
<p>It also reminds me of <code>null</code> and hence the <em>Java Bean</em> reference. (<a href="https://stackoverflow.com/questions/1612334/difference-between-dto-vo-pojo-javabeans" target="_blank">Java Bean</a> was a popular pattern in the Java ecosystem. A <em>Bean</em> needs to have an empty constructor, and a <em>setter</em> / <em>getter</em> method for each field. It seems very similar to a record type with lots of <code>Maybe</code> fields.)</p>
<p>An easy improvement would be to create <code>Age</code> type</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">Age</span> <span class="ot">=</span> <span class="dt">Age</span> <span class="dt">Int</span> </span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Person''</span> f <span class="ot">=</span> <span class="dt">Person''</span> { </span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a>  <span class="op">...</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a>  ,<span class="ot"> pAge''  ::</span> f <span class="dt">Age</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true"></a>  <span class="co">-- imagine a lot more fields here</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true"></a>  } </span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true"></a></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true"></a><span class="ot">isDrinkingAge' ::</span> <span class="dt">Age</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true"></a>isDrinkingAge' (<span class="dt">Age</span> a) <span class="ot">=</span> a <span class="op">&gt;=</span> <span class="dv">21</span></span></code></pre></div>
<p>If we feel strongly about checking age on the <code>Person</code> type, we can use Haskell’s ability to program with polymorphic fields:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="ot">{-## LANGUAGE TypeApplications ##-}</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a><span class="ot">{-## LANGUAGE DataKinds ##-}</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a><span class="ot">{-## LANGUAGE FlexibleContexts ##-}</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a><span class="ot">{-## LANGUAGE DuplicateRecordFields ##-}</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">GHC.Records</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true"></a><span class="ot">isDrinkingAge ::</span> <span class="dt">HasField</span> <span class="st">&quot;pAge&quot;</span> p (<span class="dt">Identity</span> <span class="dt">Int</span>) <span class="ot">=&gt;</span> p <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true"></a>isDrinkingAge p <span class="ot">=</span> runIdentity (getField <span class="op">@</span> <span class="st">&quot;pAge&quot;</span> p) <span class="op">&gt;=</span> <span class="dv">21</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true"></a></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">AgeTest</span> <span class="ot">=</span> <span class="dt">AgeTest</span> {<span class="ot"> pAge ::</span> <span class="dt">Identity</span> <span class="dt">Int</span>}</span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true"></a></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true"></a>test40YearOld <span class="ot">=</span> isDrinkingAge <span class="op">$</span> <span class="dt">AgeTest</span> (<span class="dt">Identity</span> <span class="dv">40</span>)</span></code></pre></div>
<p>IMO creating record types with lots of <code>Maybe</code> fields for the benefit of easy construction is not a good pattern.</p>
<h3 id="maybe-first-monoid-fields"><em>Maybe-First</em> <code>Monoid</code> fields</h3>
<p><code>Maybe (First _)</code> is a valid <code>Monoid</code>.<br />
Using Maybe-First semantics, <code>mappend</code> selects the first non-<code>Nothing</code> element. Appending can be implemented as:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Data.Semigroup</span> (<span class="dt">First</span> (..))</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a>a <span class="op">&lt;&gt;</span> b <span class="ot">=</span> <span class="fu">fmap</span> getFirst <span class="op">$</span> <span class="fu">fmap</span> <span class="dt">First</span> a <span class="op">&lt;&gt;</span> <span class="fu">fmap</span> <span class="dt">First</span> b</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a><span class="co">-- or in more &quot;elemenary&quot; way as:</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true"></a></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true"></a><span class="dt">Nothing</span> <span class="op">&lt;&gt;</span> b <span class="ot">=</span> b</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true"></a>a <span class="op">&lt;&gt;</span> <span class="dt">Nothing</span> <span class="ot">=</span> a</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true"></a>a <span class="op">&lt;&gt;</span> b <span class="ot">=</span> a</span></code></pre></div>
<p>You can use this approach on each field to define <code>Monoid</code> instances for large record types that consist of <code>Maybe</code> fields.<br />
This pattern provides a convenient defaulting mechanism and allows to set groups of fields at once using <code>mappend</code>.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a>overrides <span class="op">&lt;&gt;</span> record</span></code></pre></div>
<p>This approach can also result in very weird data combinations if one is not careful:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a>gd <span class="ot">=</span> (<span class="fu">mempty</span><span class="ot"> ::</span> <span class="dt">Person</span> <span class="dt">Maybe</span>) {pName <span class="ot">=</span> <span class="st">&quot;grandpa&quot;</span>} <span class="co">-- missing age</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a>baby <span class="ot">=</span> (<span class="fu">mempty</span><span class="ot"> ::</span> <span class="dt">Person</span> <span class="dt">Maybe</span>) {pName <span class="ot">=</span> <span class="dt">Just</span> <span class="st">&quot;baby&quot;</span>, pAge <span class="ot">=</span> <span class="dt">Just</span> <span class="dv">1</span>} </span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true"></a>grampatoddler <span class="ot">=</span> gd <span class="op">&lt;&gt;</span> baby <span class="co">-- it is easy to create surprising data</span></span></code></pre></div>
<p>The reverse: <code>First (Maybe _)</code> <code>Monoid</code> instance is far less convenient to use but is much less surprising.</p>
<p>I do not think that <code>Maybe-First</code> <code>Monoid</code> is necessarily bad. There is simply a trade-off between the conveniences it offers and its gotchas. I prefer designs that provide more safety over accidental bugs.</p>
<h2 id="alternative-typeclass"><code>Alternative</code> typeclass</h2>
<p><code>Alternaive</code> <code>(&lt;|&gt;)</code> is very convenient tool often used with parsers. It can be dangerous on its own merit. It can suppress error information in questionable ways if overused (I wrote a separate <a href="https://rpeszek.github.io/posts/2021-02-13-alternative.html" target="_blank">post</a> about it).</p>
<p>There is currently no <code>Alternative</code> instance for <code>Either err</code> but there is one for <code>Maybe</code>. This creates temptation to <code>unExplain</code> the <code>err</code> …</p>
<h2 id="good-uses-of-maybe">Good uses of Maybe</h2>
<p>I think the following old design principle (Postel’s law) is still valid (on the implementation side)</p>
<p><em>Lenient input, Strict Output</em>.</p>
<p>This means <code>Maybe</code> is great as input parameter, less so in the result. The above <em>Error Clarity Rule</em> should be the overriding factor here. If the call-site can disambiguate what <code>Nothing</code> is, then <code>Maybe</code> results are fine.</p>
<p>In particular, <em>prisms</em> are typically used on not nested coproducts, thus, the call-site can disambiguate at which level the pattern match failed. <code>lookup</code> in <code>Data.Map</code>, <code>find</code> for a <code>Foldabe</code> are all perfectly good choices for a <code>Maybe</code> result type.</p>
<h2 id="why-maybe-is-overused-possible-explanations">Why <code>Maybe</code> is Overused? Possible Explanations</h2>
<p>IMO these are the main causes of the overuse:</p>
<ol type="1">
<li><p>Using <code>Maybe</code> is simpler that <code>Either</code>. If doing the right thing takes more time and effort it will often not be done.</p></li>
<li><p>Coding with <code>Maybe</code> is terser. Thus, coding with <code>Maybe</code> may seem more elegant.</p></li>
<li><p><code>Maybe</code> is more expressive. Examples: <code>Alternative</code> instance; to use <code>Monad</code>, <code>Applicative</code> with <code>Either err</code> you need to unify on the <code>err</code> type which is extra work.</p></li>
<li><p>Sophisticated abstractions can obscure common sense. <code>Maybe</code> is likely to fit the abstraction more often and easier than <code>Either</code>.</p></li>
</ol>
<p>Oversimplifications are nothing new in mathematical modeling. Anyone who studied, for example, mathematical physics has seen a lot of crazy oversimplifications. Code design appears not that different.</p>
<ol start="5" type="1">
<li>Non production code. Lots of Haskell code is about CS research. Lots of Haskell code is pet projects. Such code does not need to be maintained in production. <code>Maybe</code> is good enough.</li>
</ol>
<p>If developer can disambiguate the reason for <code>Nothing</code>, then use of <code>Either</code> is optional. This is not an overuse case and is justified.</p>
<p>I started with link to <a href="https://www.michaelpj.com/blog/2021/01/02/elementary-programming.html" target="_blank">Elementary Programming</a> post and want to end with it. Would more explicit “elementary” programs help in spotting obvious things like error information loss? I think they could. Starting from requirements and going back to most elementary solution would probably never arrive at:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a><span class="ot">mapMaybe ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [b]</span></code></pre></div>
<p>if only the requirements cared about errors.<br />
I do not advocate avoiding abstractions, just do not forget errors on the way. Don’t throw the baby out with the bathwater.</p>
<p>I am sure I do not have a full understanding of why and how <code>Maybe</code> is overused. The intent of this post is to start a discussion.</p>
<p>Discussion links:</p>
<ul>
<li>github <a href="https://github.com/rpeszek/rpeszek.github.io/discussions" target="_blank">discussions</a></li>
<li><a href="https://www.reddit.com/r/haskell/comments/kyo4xk/maybe_considered_harmful/" target="_blank">reddit</a></li>
</ul>
<h2 id="more-links">More Links</h2>
<p>(Links and information added later, after the original post)</p>
<ul>
<li><p><a href="https://www.parsonsmatt.org/2018/11/03/trouble_with_typed_errors.html" target="_blank">The Trouble with Typed Errors</a> - My post is often read as “Use Either” (I would prefer just “Do not overuse Maybe”). Matt Parsons’s great article talks about problems with monolithic error types and more. Extensible error types is important topic worth its own github awesome page.</p></li>
<li><p><a href="https://haskellweekly.news/episode/35.html" target="_blank">Haskell Weekly Podcast</a> has discussed this post. Thank you so much!</p></li>
</ul>

    </section>
</article>
]]></description>
    <pubDate>Sun, 17 Jan 2021 00:00:00 UT</pubDate>
    <guid>https://rpeszek.github.io//posts/2021-01-17-maybe-overuse.html</guid>
    <dc:creator>Robert Peszek</dc:creator>
</item>
<item>
    <title>Maybe Considered Harmful (deleted)</title>
    <link>https://rpeszek.github.io//posts/2021-01-16-maybe-harmful.html</link>
    <description><![CDATA[<article>
    <section class="header">
        Posted on January 16, 2021
        
            by Robert Peszek
        
        
        
        
        <div class="info">Tags: </div>
        
    </section>
    <section>

    </section>
    <section>
        <p><strong>… or stories about error information loss </strong></p>
<p>Due to the negative reaction to the title (<a href="https://www.reddit.com/r/haskell/comments/kyo4xk/maybe_considered_harmful/gji0235?utm_source=share&amp;utm_medium=web2x&amp;context=3" target="_blank">reddit</a>) this has been re-posted as <a href="../posts/2021-01-17-maybe-overuse.html">Maybe Overuse, Stories About Error Information Loss</a>.</p>
    </section>
</article>
]]></description>
    <pubDate>Sat, 16 Jan 2021 00:00:00 UT</pubDate>
    <guid>https://rpeszek.github.io//posts/2021-01-16-maybe-harmful.html</guid>
    <dc:creator>Robert Peszek</dc:creator>
</item>
<item>
    <title>Why I stopped "Opinions and Programming" blog</title>
    <link>https://rpeszek.github.io//posts/2021-01-10-OldBlog.html</link>
    <description><![CDATA[<article>
    <section class="header">
        Posted on January 10, 2021
        
            by Robert Peszek
        
        
        
        
        <div class="info">Tags: <a title="All pages tagged 'announcement'." href="../tags/announcement.html">announcement</a></div>
        
    </section>
    <section>

    </section>
    <section>
        <p>I used to blog here: <a href="http://rpeszek.blogspot.com/" target="_blank">Opinions and Programming</a>.</p>
<p>My most read blogs were the series <em>I don’t like Hibernate and Grails</em>. It presented some lessons learned from using Grails in anger. Here are the direct links: the series started with <a href="http://rpeszek.blogspot.com/2014/08/i-dont-like-hibernate-and-grails-part-1.html" target="_blank">Part 1</a> and ended with <a href="http://rpeszek.blogspot.com/2014/10/i-dont-like-hibernategrails-part-11_31.html" target="_blank">Part 11</a>. This series topped the list of most read Groovy language blogs (according to <a href="http://groovyblogs.org" target="_blank">groovyblogs.org</a>) for several months back in 2014.</p>
<p><em>Opinions and Programming</em> site illustrates my programming journey and my fascination with functional programming. Includes my old posts about <a href="https://github.com/rpeszek/fpiglet" target="_blank"><em>figlet</em></a> (functional programming library I wrote for Groovy) staring from <a href="http://rpeszek.blogspot.com/2013/06/making-groovy-more-functional-fpiglet.html" target="_blank">this old post</a> to <a href="http://rpeszek.blogspot.com/2013/08/monadic-comprehensions-in-groovy-and.html" target="_blank">Monadic Comprehensions in Groovy/Fpiglet</a>. Functional programming never caught on in Groovy, <em>fpiglet</em> was one of the first attempts. I also done functional side trips like a <a href="http://rpeszek.blogspot.com/2013/10/functional-groovy-y-combinator-learning.html" target="_blank">Groovy take on Y-combinator</a>.</p>
<p>More recent blogs were more and more focused on Haskell. I have stopped contributing to this blog in 2017. There are many excellent Haskell blogs out there already.</p>
<p>Looking at stats for these blogs was a very interesting exercise. The stats for FP posts were very poor. The difference in number of views between my posts related to mainstream Groovy/Grails and my posts related to functional programming was 10X or bigger. Functional programming remains a niche part within the programming profession. Any estimates I have seen about mainstream vs functional programming jobs show FP to be less than 1% of job market. I believe spamming bots and accidental hits were the reasons why I have seen only a 10X reduction in number of viewer visits. Whatever the actual stats were, the small viewership contributed to my decision to stop blogging.</p>
<p>Playing with code is so much more fun that writing about it. But I still settled on a hybrid. I switched to literate Haskell programs and deployed these as <em>wiki</em> pages on my github projects:<br />
<a href="https://github.com/rpeszek/notes-milewski-ctfp-hs/wiki" target="_blank">Milewski’s Category Theory for Programmers notes</a><br />
<a href="https://github.com/rpeszek/IdrisTddNotes/wiki" target="_blank">Idris TTD book notes</a>.<br />
These seemed better than blog to me. The wiki introduction to my CTFP notes ended up copied on the old blog site <a href="http://rpeszek.blogspot.com/2018/02/" target="_blank">Why read CPFP?</a> but it was just a pandoc copy of the corresponding wiki page.</p>
<p>I still have occasional need to vent my technical thoughts and concerns. For this reason I decided to move my blog here, closer to my github pet projects.</p>
    </section>
</article>
]]></description>
    <pubDate>Sun, 10 Jan 2021 00:00:00 UT</pubDate>
    <guid>https://rpeszek.github.io//posts/2021-01-10-OldBlog.html</guid>
    <dc:creator>Robert Peszek</dc:creator>
</item>

    </channel>
</rss>
