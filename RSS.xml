<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Infrequent, Pragmatic, Lambda Blog</title>
        <link>https://rpeszek.github.io/</link>
        <description><![CDATA[Infrequent, Pragmatic, Lambda Blog Feed]]></description>
        <atom:link href="https://rpeszek.github.io//RSS.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Mon, 03 Jan 2022 00:00:00 UT</lastBuildDate>
        <item>
    <title>Type Enthusiast's Notes about TypeScript. Part 3. TS Complexity</title>
    <link>https://rpeszek.github.io//posts/2022-01-03-ts-types-part3.html</link>
    <description><![CDATA[<article>
    <section class="header">
        Posted on January  3, 2022
        
            by Robert Peszek
        
        
        
        
        <div class="info">Tags: <a title="All pages tagged 'TypeScript-Notes'." href="../tags/TypeScript-Notes.html">TypeScript-Notes</a></div>
        
    </section>
    <section>

    </section>
    <section>
        <div class="toc"><div class="header">Table of Contents</div>
<ul>
<li><a href="#nutshell">Nutshell</a></li>
<li><a href="#interesting-safety">Interesting safety</a>
<ul>
<li><a href="#apple-orange-type-safety"><code>apple !== orange</code> type safety</a></li>
<li><a href="#switch-exhaustive-check"><code>switch</code> exhaustive check</a></li>
<li><a href="#null-undefined-safety"><code>null</code> / <code>undefined</code> safety</a></li>
</ul></li>
<li><a href="#complexity-of-ts-types">Complexity of TS types</a>
<ul>
<li><a href="#semantics-rejected-overlap"><code>===</code> semantics, rejected overlap</a></li>
<li><a href="#semantics-whats-an-overlap"><code>===</code> semantics, what’s an overlap?</a></li>
<li><a href="#hidden-blooper-side-note">Hidden blooper (side note)</a></li>
<li><a href="#diy-equality">DIY equality</a></li>
<li><a href="#subtyping">Subtyping</a></li>
<li><a href="#comparative-complexity-rant">Comparative complexity rant</a></li>
<li><a href="#variance-problems">Variance problems</a></li>
<li><a href="#summary">Summary</a></li>
</ul></li>
<li><a href="#next-chapter">Next Chapter</a></li>
</ul>
</div>
<p><em>Please Leave Feedback in: <a href="https://github.com/rpeszek/rpeszek.github.io/discussions/1" target="_blank">git discussions</a></em></p>
<p>Previous post: <a href="2021-12-24-ts-types-part2.html" target="_blank">Part 2. Typing Honestly</a>.</p>
<p><strong>DRAFT version</strong> <em>(I am sorry about any misprints. It seems I have goblins in my laptop that toy with me, remove or change words. When this note disappears, you will know that I gave up.)</em></p>
<p><strong>Disclaimers:</strong> (imagine this is a very small font, read it very fast in a half whisper)<br />
<em>I assume strict compiler flags are on, something you get by default with scaffolding, e.g. using <code>create-react-app my-project --template typescript</code> is close enough.<br />
The code examples have been tested with TypeScript v4.5.2.<br />
This post is a pandoc output of a markdown document and code examples are not interactive.<br />
Most of the code examples are published in <a href="https://github.com/rpeszek/ts-experiments/tree/master/ts-notes" target="_blank">ts-notes</a> folder in this github repo: <a href="https://github.com/rpeszek/ts-experiments" target="_blank">ts-experiments</a>.</em></p>
<p><strong>Motivating Quote for the series:</strong></p>
<blockquote>
<p>“TypeScript began its life as an attempt to bring traditional object-oriented types to JavaScript so that the programmers at Microsoft could bring traditional object-oriented programs to the web. As it has developed, TypeScript’s type system has evolved to model code written by native JavaScripters. The resulting system is <em>powerful, interesting and messy.</em>”</p>
</blockquote>
<p><em>From typescriptlang <a href="https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html" target="_blank">TypeScript for Functional Programmers</a></em></p>
<h2 id="nutshell">Nutshell</h2>
<p>Happy New Year! Let’s hope 2022 it will be way better than 2021. It has to be.</p>
<p>This is the third post in the series devoted to types in TypeScript. In this series, I explore type-centric approaches to writing code and push TS to its limits in doing so. I am writing these posts for like minded developers who are interested in types and either use or consider using TypeScript.</p>
<p>In this post we will see TS struggle. We will see compilation inconsistencies and surprising type checker behavior.<br />
My main goal is to point out the complexity of what TS is trying to accomplish and share my understanding of it.<br />
On a positive note, I will introduce additional tools for asking TS type questions.<br />
Also, I promise, the next installment will be about good things in TS. It will be about programming with type variables.</p>
<p>Before we discuss the messy bits, let’s briefly talk about some cool type safety features.</p>
<h2 id="interesting-safety">Interesting safety</h2>
<p>TypeScript implements special <a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html" target="_blank">narrowing</a> semantics when processing parts of JS code. These semantic rules provide very surprising and useful type safety features. TS can effectively narrow types used in a number of JS operators such as <code>typeof</code>, <code>===</code>, <code>==</code> and apply this information to <code>if-else</code>, <code>switch</code> statements. This post has already shown a few examples where this, almost magically, prevents placing code in a wrong branch of conditional if-else blocks.</p>
<p>Here are some of my favorites with IMO on their use.</p>
<h3 id="apple-orange-type-safety"><code>apple !== orange</code> type safety</h3>
<p>This JavaScript code (I keep reusing <code>type Person = {firstNm: string, lastNm: string}</code> from the first post):</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="co">//Bad code</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="kw">function</span> <span class="fu">blah</span>(lhs<span class="op">:</span> string<span class="op">,</span> rhs<span class="op">:</span> Person) {</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>  <span class="cf">if</span> (lhs <span class="op">===</span> rhs) {</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>    <span class="co">//Do something</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>  } <span class="cf">else</span> {</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>    <span class="co">//Do something else</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>  }</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>}</span></code></pre></div>
<p>is a programming bug and will not type-check in TypeScript. You can just replace it with:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="co">//Actual equivalent</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="kw">function</span> <span class="fu">blah</span>(lhs<span class="op">:</span> string<span class="op">,</span> rhs<span class="op">:</span> Person) {</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>  <span class="co">//Do something else</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>}</span></code></pre></div>
<p>TypeScript prevents from using <code>===</code> if it can guess<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>, by looking at the types, that <code>===</code> will always be <code>false</code>. This is true in general, not just inside <code>if-else</code>, but the <code>if-else</code> use is the killer app IMO.<br />
One cool example of <code>===</code> type safety combines type narrowing with literal types: <code>1 === 2</code> will not compile!</p>
<p>This is a big deal. <code>===</code> is often used to compare things like <code>string</code> or <code>number</code> <em>id</em>-s or <em>hashes</em> and it is not that uncommon to accidentally try to compare something like an <em>id</em> with something completely different.<br />
I have seen analogous issues in many programming languages including even <em>Scala</em>.</p>
<h3 id="switch-exhaustive-check"><code>switch</code> exhaustive check</h3>
<p><code>if-else</code> does not provide any mechanism for the type checker to verify that the program checked all possible conditions.<br />
Interestingly, TS uses the <code>switch</code> statement to solve this problem:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="co">//This compiles!</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a><span class="kw">const</span> contrived_better <span class="op">=</span> (n<span class="op">:</span> <span class="dv">1</span> <span class="op">|</span> <span class="dv">2</span>)<span class="op">:</span> number <span class="kw">=&gt;</span> {</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>    <span class="cf">switch</span>(n) {</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>       <span class="cf">case</span> <span class="dv">1</span><span class="op">:</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>       <span class="cf">case</span> <span class="dv">2</span><span class="op">:</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>        <span class="cf">return</span> <span class="dv">2</span> </span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>    } </span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="co">//Compilation error</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="co">//Function lacks ending return statement and return type does not include 'undefined'.ts(</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>export <span class="dt">const</span> contrived_better_ = (n: <span class="dv">1</span> | <span class="dv">2</span> | <span class="dv">3</span>): number =&gt; {</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>    <span class="kw">switch</span>(n) {</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>       <span class="kw">case</span> <span class="dv">1</span>:</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>        <span class="kw">return</span> n</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>       <span class="kw">case</span> <span class="dv">2</span>:</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>        <span class="kw">return</span> n </span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>    } </span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>}</span></code></pre></div>
<p>That is another nice example of TS enhancing JS with a nice type safety feature.</p>
<p>IMO an even better solution is provided by the <em>ts-pattern</em> library. See this blog post: <a href="https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k" target="_blank">Introducing ts-pattern v3.0</a></p>
<h3 id="null-undefined-safety"><code>null</code> / <code>undefined</code> safety</h3>
<p>We have seen <code>null</code> safety already. There is a semantic difference between <code>null</code> and <code>undefined</code> but most code does not care. My personal preference is to unify these two.</p>
<p>In my very first example in the series, <a href="2021-12-12-ts-types-part1.html#typescript-is-great" target="_blank"><code>getName(p: NullablePerson)</code></a>, was not <code>undefined</code> safe, only <code>null</code> safe. Using it with <code>undefined</code> (e.g. typed as <code>any</code>) will cause an error.</p>
<p>My coding preference would be to rewrite my first example like this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="co">//Reusable utility type</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="im">export</span> type Undefined <span class="op">=</span> <span class="kw">null</span> <span class="op">|</span> <span class="kw">undefined</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a><span class="im">export</span> <span class="kw">const</span> isUndefined <span class="op">=</span> (d<span class="op">:</span> unknown)<span class="op">:</span> d is Undefined <span class="kw">=&gt;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>   (d <span class="op">===</span> <span class="kw">null</span>) <span class="op">||</span> (d <span class="op">===</span> <span class="kw">undefined</span>) <span class="co">//I prefer not to use '=='</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a><span class="kw">const</span> getName2 <span class="op">=</span> (p<span class="op">:</span>Person <span class="op">|</span> Undefined)<span class="op">:</span> string <span class="kw">=&gt;</span> {</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>    <span class="co">//const tst1 = p.firstNm //will not compile</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>    <span class="cf">if</span>(<span class="fu">isUndefined</span>(p)){</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a>        <span class="co">//const tst2 = p.firstNm //will not compile</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a>        <span class="cf">return</span> <span class="st">&quot;John Smith&quot;</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a>    } <span class="cf">else</span> {</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true"></a>        <span class="cf">return</span> p<span class="op">.</span><span class="at">firstNm</span> <span class="op">+</span> <span class="st">&quot; &quot;</span> <span class="op">+</span> p<span class="op">.</span><span class="at">lastNm</span> <span class="co">//compiles</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true"></a>    }</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true"></a>}</span></code></pre></div>
<p>This is just my personal preference, I also use this approach when typing optional <code>?</code> object properties. E.g.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>type Person2 <span class="op">=</span> {<span class="dt">firstNm</span><span class="op">:</span> string<span class="op">;</span> middleNm<span class="op">?:</span> string <span class="op">|</span> Undefined<span class="op">;</span> <span class="dt">lastNm</span><span class="op">:</span> string}</span></code></pre></div>
<p>The extra safety features are what surprised and excited me about TS. They reminded me of a functional programming language.</p>
<h2 id="complexity-of-ts-types">Complexity of TS types</h2>
<p>Throughout the series, we encountered a few examples where the TS type checker did not work as expected, we will encounter more of TS quirkiness in this section. This note suggests a reason for this: type complexity.</p>
<p>My original plan was to write about TS needing to implement a separate ad-hoc semantics for various JS operators. I was not able to present anything very insightful and I have abandoned that idea, e.g. these <a href="2021-12-12-ts-types-part1.html#type-holes" target="_blank">type hole</a> expressions do not even compile:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="co">//Compiliation errors: Object is of type 'unknown'</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="fu">_</span>() + <span class="fu">_</span>()</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a><span class="fu">_</span>() * <span class="fu">_</span>()</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a><span class="fu">_</span>() / <span class="fu">_</span>()</span></code></pre></div>
<p>Taking the quote from the top of this post to heart, I concluded that TS is about providing support for OO and other idiomatic uses of JS. I decided to narrow the focus of this note to subtyping and the <code>===</code> operator semantics.</p>
<h3 id="semantics-rejected-overlap"><code>===</code> semantics, rejected overlap</h3>
<p>I have picked <code>===</code> because we discussed it already in my previous note about the <a href="2021-12-24-ts-types-part2.html#note-about-the-unknown-type" target="_blank"><code>unknown</code> type</a>. Selecting <code>==</code> would produce a very similar presentation.</p>
<p>Here is an example of safety around the <code>===</code> operator:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="co">//This condition will always return 'false' since the types '&quot;world!&quot;' and '&quot;Dolly!&quot;' have no overlap.ts(2367)</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="st">&quot;world!&quot;</span> === <span class="st">&quot;Dolly!&quot;</span> <span class="co">//does not compile</span></span></code></pre></div>
<p>Let’s try to figure out the semantic rules around <code>===</code>. What does “not having an overlap” mean?<br />
I have not seen a formal (or even a somewhat precise) definition of the semantic rules for the <code>===</code>.<br />
(Please comment in git discussions if you know about any place that defines these.)<br />
The informal definition (from typescriptlang documentation) points to a “common type that both <code>x</code> and <code>y</code> could take on” but this statement clearly has some loose ends.</p>
<p>The first part of the error message “This condition will always return ‘false’” suggests a way to start:</p>
<p><strong>(EQ-SAFETY attempt 1):</strong> <em>TypeScript prevents using <code>===</code> if it can prove, by looking at the types, that the result of <code>===</code> would always be <code>false</code>.</em></p>
<p>This is a very high level and does not explain how TS does it. But is this even true?</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>function <span class="fu">testEqSemantics</span>(a: {bye: string}, b: {hello: string): <span class="dt">boolean</span> {</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>   <span class="co">//This condition will always return 'false' since the types '{ bye: string; }' and '{ hello: string; }' have no overlap.</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>   <span class="kw">return</span> a === b <span class="co">//does not compile</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>}</span></code></pre></div>
<p>Let me temporarily comment the not compiling code:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="kw">function</span> <span class="fu">testEqSemantics</span>(a<span class="op">:</span> {<span class="dt">bye</span><span class="op">:</span> string}<span class="op">,</span> b<span class="op">:</span> {<span class="dt">hello</span><span class="op">:</span> string})<span class="op">:</span> boolean {</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>   <span class="co">//This condition will always return 'false' since the types '{ bye: string; }' and '{ hello: string; }' have no overlap.</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>   <span class="co">//return a === b</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>   <span class="cf">return</span> <span class="kw">true</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>}</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a><span class="kw">const</span> helloBye <span class="op">=</span> {<span class="dt">bye</span><span class="op">:</span><span class="st">&quot;world!&quot;</span><span class="op">,</span> <span class="dt">hello</span><span class="op">:</span><span class="st">&quot;world!&quot;</span>}</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a><span class="fu">testEqSemantics</span>(helloBye<span class="op">,</span> helloBye)  <span class="co">//compiles, here is the overlap!</span></span></code></pre></div>
<p>TS has effectively prevented me from using <code>===</code> even though there are legitimate cases where the <code>===</code> would have returned <code>true</code>! This seems like a major blooper.</p>
<p><strong><em>We have falsified the error message from TS.</em></strong></p>
<p>OO is complex and type design issues are not uncommon among OO languages, this could be one of them.<br />
On the other hand, preventing <code>{bye: "world!"} === {hello: "world!"}</code> from compiling seems useful from a pragmatic point of view. It is possible that this behavior is intentional.</p>
<p>I see 2 possible conclusions</p>
<ol type="1">
<li>This is a bug caused by a complexity of TS’s semantic rules</li>
<li>This is a feature indicating that the rules are indeed complex</li>
</ol>
<h3 id="semantics-whats-an-overlap"><code>===</code> semantics, what’s an overlap?</h3>
<p>Let’s focus on this part of the error message: “types … and … have no overlap”.</p>
<p><strong>(EQ-SAFETY attempt 2):</strong> <em><code>x === y</code> compiles if <code>x: X</code> and <code>y: Y</code> and the compiler successfully computes some special non-<code>never</code> <code>Overlap</code> type that widens to both <code>X</code> and <code>Y</code></em></p>
<p><code>X</code> is the computed type for <code>x</code>, <code>Y</code> is the computed type for <code>y</code>, how do we compute <code>Overlap</code> type for both? I think we can assume that <em>widens</em> simply means <code>extends</code>.<br />
The 64K dollar question is how is the <code>Overlap</code> computed? It is clearly not the same as intersection (the type operator <code>&amp;</code>), we have falsified that hypothesis in the previous section. Let’s try to look at some patterns:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="kw">const</span> helloDolly<span class="op">:</span> {<span class="dt">hello</span><span class="op">:</span> string} <span class="op">=</span> {<span class="dt">hello</span><span class="op">:</span> <span class="st">&quot;Dolly!&quot;</span>}</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a><span class="kw">const</span> datedHello<span class="op">:</span> {<span class="dt">hello</span><span class="op">:</span> string<span class="op">,</span> <span class="dt">since</span><span class="op">:</span> number} <span class="op">=</span> {<span class="dt">hello</span><span class="op">:</span> <span class="st">&quot;world!&quot;</span><span class="op">,</span> <span class="dt">since</span><span class="op">:</span><span class="dv">2022</span>}</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a><span class="kw">const</span> one <span class="op">=</span> <span class="dv">1</span> <span class="co">//const one: 1</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a><span class="kw">const</span> two <span class="op">=</span> <span class="dv">2</span> <span class="co">//const two: 2</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a><span class="kw">const</span> onenum<span class="op">:</span> number  <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a><span class="kw">const</span> twonum<span class="op">:</span> number  <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a><span class="kw">const</span> world<span class="op">:</span> string <span class="op">=</span> <span class="st">&quot;world&quot;</span></span></code></pre></div>
<div class="sourceCode" id="cb12"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="co">//fails, different literal types do not overlap</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a><span class="st">&quot;Dolly!&quot;</span> ===  <span class="st">&quot;world!&quot;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a><span class="co">//fails, different literal types do not overlap</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>one === two</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a><span class="co">//fails, string and number do not overlap</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a>one === world</span></code></pre></div>
<div class="sourceCode" id="cb13"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="co">//compilies, note both have the same type</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>onenum <span class="op">===</span> twonum</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a><span class="co">//compiles, note 'typeof datedHello' extends 'typeof helloDolly' </span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>helloDolly <span class="op">===</span> datedHello</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a><span class="co">//compiles, the overlap seems to be the 'Person' type</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a><span class="kw">function</span> <span class="fu">tst</span> (x<span class="op">:</span> number <span class="op">|</span> Person<span class="op">,</span> y<span class="op">:</span> string <span class="op">|</span> Person) {</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a>    <span class="cf">return</span> x <span class="op">===</span> y</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a>}</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true"></a><span class="co">//compiles, the overlap seems to be `{hello: string, since: number}` </span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true"></a><span class="kw">function</span> <span class="fu">testEqSemantics2</span>(a<span class="op">:</span> {<span class="dt">hello</span><span class="op">:</span> string} <span class="op">|</span> <span class="dv">1</span><span class="op">,</span> b<span class="op">:</span> <span class="st">&quot;boo&quot;</span> <span class="op">|</span> {<span class="dt">hello</span><span class="op">:</span> string<span class="op">,</span> <span class="dt">since</span><span class="op">:</span> number})<span class="op">:</span> boolean {</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true"></a>    <span class="cf">return</span> a <span class="op">===</span> b</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true"></a>}</span></code></pre></div>
<p>A possible rule for calculating <code>Overlap</code> could be (this is just a rough, high level heuristics, <em>please comment if you know a better definition</em>):</p>
<ul>
<li>for intersection types <code>X</code> and <code>Y</code>, if <code>X extends Y</code> take <code>X</code> else if <code>Y extends X</code> take <code>Y</code> otherwise reject</li>
<li>for union types <code>X = X1 | X2 | ...</code> and <code>Y = Y1 | Y2 | ...</code> recursively check if any <code>Xi</code> and <code>Yj</code> overlaps (this heuristics ignores performance cost)</li>
<li>for complex combinations of union and intersection types? I DUNNO, I have not tested it enough.</li>
</ul>
<p>I have not played with this assumption for a very long time, but so far these rules seem to hold with these exceptions:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="co">//All compile</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a><span class="dv">1</span> <span class="op">===</span> <span class="kw">null</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a><span class="dv">1</span> <span class="op">===</span> <span class="kw">undefined</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a><span class="kw">function</span> <span class="fu">tst2</span> (x<span class="op">:</span> <span class="dv">1</span><span class="op">,</span> y<span class="op">:</span> <span class="kw">null</span>) {</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a>    <span class="cf">return</span> x <span class="op">===</span> y</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true"></a>}</span></code></pre></div>
<p>Does <code>1</code> have an overlap with <code>null</code> and <code>undefined</code>? What does that even mean? With the <em>strictNullChecks</em> compiler flag, <code>null</code> should be well separated from other types.<br />
This particular quirkiness is actually useful, it allows for a program to do conservative null checks even if the type indicates that it is not needed.</p>
<p>I hope you agree. This is complicated.<br />
I will hopefully bring this point even closer to home by the end of this post.</p>
<h3 id="hidden-blooper-side-note">Hidden blooper (side note)</h3>
<p>If you remove type annotations from the above definitions, the <code>helloDolly === datedHello</code> still compiles:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="kw">const</span> helloDolly <span class="op">=</span> {<span class="dt">hello</span><span class="op">:</span> <span class="st">&quot;Dolly!&quot;</span>}</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a><span class="kw">const</span> datedHello <span class="op">=</span> {<span class="dt">hello</span><span class="op">:</span> <span class="st">&quot;world!&quot;</span><span class="op">,</span> <span class="dt">since</span><span class="op">:</span><span class="dv">2022</span>}</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a>helloDolly <span class="op">===</span> datedHello <span class="co">//still compiles</span></span></code></pre></div>
<p>From a pragmatic standpoint this is very strange. <code>"Dolly!" ===  "world!"</code> is statically rejected, but <code>{hello: "Dolly!"} === {hello: "world!", since:"2022"}</code> is not.</p>
<p>This surprising situation is caused by the type inference widening the types. The types inferred in the expression <code>"world!" === "Dolly!"</code> are the literal types <code>"world!": "world!"</code> and <code>"Dolly!": "Dolly!"</code>, while the <code>helloDolly</code> and <code>datedHello</code> infer a <code>string</code> and <code>number</code> for their properties:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="co">//IntelliSense view of helloDolly</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a><span class="kw">const</span> helloDolly<span class="op">:</span> {</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>    <span class="dt">hello</span><span class="op">:</span> string<span class="op">;</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>}</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a><span class="co">//IntelliSense view of datedHello</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a><span class="kw">const</span> datedHello<span class="op">:</span> {</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true"></a>    <span class="dt">hello</span><span class="op">:</span> string<span class="op">;</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true"></a>    <span class="dt">since</span><span class="op">:</span> number<span class="op">;</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true"></a>}</span></code></pre></div>
<p>IMO, widening object property types is an arbitrary complexity.</p>
<h3 id="diy-equality">DIY equality</h3>
<p>The question is how far can I get by trying to reproduce safety around the <code>===</code> on my own.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>declare <span class="kw">function</span> eq<span class="op">&lt;</span>T<span class="op">&gt;</span>(t1<span class="op">:</span> T<span class="op">,</span> t2<span class="op">:</span> T)<span class="op">:</span> boolean</span></code></pre></div>
<p>This generic function (it could be implemented by simply using <code>===</code>) forces both arguments to have the same type. That should give me at least some level of extra safety and prevent from comparing apples and oranges.<br />
Let’s see, starting with these type holes:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="co">//type holes shows a string, not bad, I would prefer the literal &quot;foo&quot;.</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a><span class="fu">eq</span>(<span class="st">&quot;foo&quot;</span><span class="op">,</span> <span class="fu">_</span>())</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a><span class="co">//type holes shows unknown, Another unexpected 'uknown' widening issue? </span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a><span class="fu">eq</span>(<span class="fu">_</span>()<span class="op">,</span> <span class="st">&quot;foo&quot;</span>)</span></code></pre></div>
<p>Let’s ignore the second type hole disappointing quirkiness and move on.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="co">//These all compile</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a><span class="fu">eq</span>(<span class="dv">1</span> <span class="im">as</span> <span class="dv">1</span><span class="op">,</span> <span class="kw">null</span>)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a><span class="fu">eq</span>(<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span>)              <span class="co">//</span><span class="al">NOTE</span><span class="co"> we lost the type safety of ===</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a><span class="fu">eq</span>(<span class="dv">1</span> <span class="im">as</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span> <span class="im">as</span> <span class="dv">2</span>)    <span class="co">//</span><span class="al">NOTE</span><span class="co"> we lost the type safety of ===</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a><span class="fu">eq</span>({<span class="dt">bye</span><span class="op">:</span> <span class="st">&quot;world&quot;</span>}<span class="op">,</span> {<span class="dt">hello</span><span class="op">:</span> <span class="st">&quot;world&quot;</span>})  <span class="co">//</span><span class="al">NOTE</span><span class="co"> we lost the (possibly erroneous) type safety preventing {bye: &quot;world&quot;} === {hello: &quot;world&quot;}</span></span></code></pre></div>
<p>How come these compile? These are all different types but TS can unify them into a supertype (next section will discuss it). These are all legitimate statements. Unfortunately, the type safety has been lost. This explains why the semantic narrowing around the <code>===</code> operator is needed. It is needed because structural subtyping can unify types even if types are very different.</p>
<p>However, quirkiness alert, these do not compile:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="co">//Argument of type '&quot;boo&quot;' is not assignable to parameter of type '1'.ts(2345)</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a><span class="fu">eq</span>(<span class="dv">1</span>, <span class="st">&quot;boo&quot;</span>)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a><span class="co">//Argument of type '1' is not assignable to parameter of type '&quot;boo&quot;'.ts(2345)</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a><span class="fu">eq</span>(<span class="st">&quot;boo&quot;</span>, <span class="dv">1</span>)</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a><span class="co">//Argument of type '{ hello: string; }' is not assignable to parameter of type '1'.ts(2345)</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true"></a><span class="fu">eq</span>(<span class="dv">1</span>, {hello: <span class="st">&quot;world&quot;</span>})</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true"></a><span class="co">//Argument of type '{ hello: string; }' is not assignable to parameter of type '&quot;boo&quot;'.ts(2345)</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true"></a><span class="fu">eq</span>(<span class="st">&quot;boo&quot;</span>, {hello: <span class="st">&quot;world&quot;</span>})</span></code></pre></div>
<p><em>This is very unfortunate</em>, you want generic functions to work <em>consistently</em> across types. IMO this is a bug or an arbitrary complexity.<br />
The quirkiness seems to be related to the type inference working inconsistently and failing to widen the types if a string literal type is involved (next section discussed it).</p>
<p>The narrative has run away from me, but the point should be somewhat clear: Generics provide only limited type safety in TS.<br />
E.g. enhanced safety semantics around <code>===</code> does not transfer to a DIY safety that a library solution could expose.</p>
<h3 id="subtyping">Subtyping</h3>
<p>How come this compiles?</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="fu">eq</span>(<span class="dv">1</span> <span class="im">as</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span> <span class="im">as</span> <span class="dv">2</span>) </span></code></pre></div>
<p>The type checker widens the types of both arguments to <code>1 | 2</code>. This is because of a subtyping rule that says that <code>1 extends (1 | 2)</code> and <code>2 extends (1 | 2)</code>.<br />
Here is a somewhat clever trick to see that:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="im">export</span> declare <span class="kw">function</span> unify<span class="op">&lt;</span>T<span class="op">&gt;</span>(t1<span class="op">:</span> T<span class="op">,</span> t2<span class="op">:</span> T) <span class="op">:</span> T</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a><span class="co">//hovering over unify shows me:</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a><span class="co">//(alias) unify&lt;1 | 2&gt;(t1: 1 | 2, t2: 1 | 2): 1 | 2</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a><span class="fu">unify</span>(<span class="dv">1</span> <span class="im">as</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span> <span class="im">as</span> <span class="dv">2</span>)</span></code></pre></div>
<p>if you do not believe me that <code>1 extends (1 | 2)</code> you can check it for yourself with another trick:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="im">export</span> <span class="kw">function</span> verifyExtends<span class="op">&lt;</span>T2 <span class="kw">extends</span> T1<span class="op">,</span> T1<span class="op">&gt;</span>() {}</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a>verifyExtends<span class="op">&lt;</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span> <span class="op">|</span> <span class="dv">2</span><span class="op">&gt;</span>()</span></code></pre></div>
<p>However, TS appears to be not consistently good about inferring these subtyping rules. TS apparently did not notice that <code>1 extends (1 | "boo")</code> and <code>"boo" extends (1 | "boo")</code>. Hence the blooper</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a>verifyExtends<span class="op">&lt;</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span> <span class="op">|</span> <span class="st">&quot;boo&quot;</span><span class="op">&gt;</span>()</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a>verifyExtends<span class="op">&lt;</span><span class="st">&quot;boo&quot;</span><span class="op">,</span> <span class="dv">1</span> <span class="op">|</span> <span class="st">&quot;boo&quot;</span><span class="op">&gt;</span>()</span></code></pre></div>
<div class="sourceCode" id="cb25"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a><span class="co">//Argument of type '&quot;boo&quot;' is not assignable to parameter of type '1'.ts(2345)</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a><span class="fu">eq</span>(<span class="dv">1</span>, <span class="st">&quot;boo&quot;</span>)</span></code></pre></div>
<p>Let’s try to force TS into compliance by type annotating everything:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a><span class="kw">const</span> booone <span class="op">:</span> <span class="dv">1</span> <span class="op">|</span> <span class="st">&quot;boo&quot;</span> <span class="op">=</span> <span class="st">&quot;boo&quot;</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a><span class="kw">const</span> oneboo <span class="op">:</span> <span class="dv">1</span> <span class="op">|</span> <span class="st">&quot;boo&quot;</span> <span class="op">=</span> <span class="dv">1</span></span></code></pre></div>
<div class="sourceCode" id="cb27"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a><span class="co">//Argument of type '1' is not assignable to parameter of type '&quot;boo&quot;'.ts(2345)</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true"></a><span class="fu">eq</span>(booone, oneboo) </span></code></pre></div>
<div class="sourceCode" id="cb28"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a><span class="co">//finally compiles with type application on 'eq'</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true"></a>eq<span class="op">&lt;</span>(<span class="dv">1</span> <span class="op">|</span> <span class="st">&quot;boo&quot;</span>)<span class="op">&gt;</span>(booone<span class="op">,</span> oneboo)</span></code></pre></div>
<p>In our above examples we have seen that <code>===</code> narrowing is partially consistent with the intersection (<code>&amp;</code> operator).<br />
Let’s look at <code>&amp;</code> semantics a little closer.</p>
<p>We can try to double check how the <code>&amp;</code> intersection works by doing this:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a><span class="co">//both compile suggesting that Person is equivalent to the intersection  (number | Person) &amp; (string | Person)</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true"></a>verifyExtends<span class="op">&lt;</span>Person<span class="op">,</span> (number <span class="op">|</span> Person) <span class="op">&amp;</span> (string <span class="op">|</span> Person)<span class="op">&gt;</span>()</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true"></a>verifyExtends<span class="op">&lt;</span>(number <span class="op">|</span> Person) <span class="op">&amp;</span> (string <span class="op">|</span> Person)<span class="op">,</span> Person<span class="op">&gt;</span>()</span></code></pre></div>
<p>However this does not compile, and it does look like a bug (see second line of the error message):</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a><span class="co">//Type '(1 | &quot;boo&quot;) &amp; (&quot;boo&quot; | Person)' does not satisfy the constraint '&quot;boo&quot;'.</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true"></a><span class="co">//  Type '1 &amp; Person' is not assignable to type '&quot;boo&quot;'.ts(2344)</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true"></a>verifyExtends&lt;(<span class="dv">1</span> | <span class="st">&quot;boo&quot;</span>) &amp; (<span class="st">&quot;boo&quot;</span> | Person), <span class="st">&quot;boo&quot;</span>&gt;()</span></code></pre></div>
<p><em>Complexity is a super food for bugs.</em></p>
<p>Here is my quick summary: subtyping is complex and it weakens type safety. TS tries to recover the safety by building complex narrowing semantics around a selected set of JS operators. There are many inconsistencies in both the implementation of subtyping and the implementation of narrowing semantics.</p>
<h3 id="comparative-complexity-rant">Comparative complexity rant</h3>
<p>A “type enthusiast” will associate types with correctness, even formal verification. To me, the words “messy” and “type” are self contradictory. TS “types” support some interesting features but are a mess.</p>
<p>I want to contrast the above <code>===</code> and <code>eq</code> examples against a programming language that has been designed around types from the beginning. An example could be an FP language like Elm, PureScript, or Haskell (I am not that familiar with ReasonML or OCaml)<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.<br />
These languages have much simpler types. The safety around equality does not require any special narrowing semantics. You get it for free in any DIY function that has 2 arguments sharing the same generic type (only they call it polymorphic not generic).</p>
<p>One underlying reason for this is the lack of complex subtyping and OO features. <code>eq(x,y)</code> will not compile if <code>x</code> and <code>y</code> have different types. There is no way to unify <code>x</code> and <code>y</code> to some supertype because there are no subtypes or supertypes.<br />
But, you may say, JS object polymorphism is very useful. All the 3 languages listed above provide support for polymorphic record types<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>, only they use much simpler techniques than subtyping to achieve it.<br />
These languages also come with well thought out semantic rules that are often formalized and come with soundness proofs.<br />
The types in these languages are much simpler (not necessarily easier but simpler).</p>
<p>Type complexity translates to a confused type checker and to a confused developer.<br />
<em>Programming in a language in which I do not fully understand the types equates to me writing programs I do not fully understand.</em></p>
<p>It is worth noting that TypeScript has over a million users. FP languages have tens of thousands of users (if combined). TypeScript has more resources to improve. What makes for fewer bugs, lots of dollars or clean types?<br />
I do not think there is a clear answer to this question. However, resources can’t solve all the problems. Programming languages are almost paranoid about backward compatibility and backward compatibility does not like changing things, even if the change is fixing bugs.<br />
So I am afraid, a simple language like Elm will always be cleaner and more robust.</p>
<p>Forgetting about the popularity context, I view it as a trade-off: suffer because of the type complexity and reduced type safety but see a readable JavaScript and trivially integrate with the rest of JS ecosystem <em>vs</em> introduce a language that has nicer types, greater type safety, predictable compiler, but lose generated JS code clarity and suffer when integrating JS libraries.<br />
This trade-off is IMO not trivial and very project dependent. Clean types vs clean JS, I typically select the clean types. The ecosystem compatibility issue is a little harder to ignore and the main reason I am writing code in TS. Projects with a high correctness requirement, IMO, should select an FP language, the optimal choice for other projects is less clear.</p>
<h3 id="variance-problems">Variance problems</h3>
<p>I will finish with some examples that may feel even more surprising.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true"></a><span class="kw">const</span> bye <span class="op">=</span> {<span class="dt">bye</span><span class="op">:</span> <span class="st">&quot;world&quot;</span>}</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true"></a><span class="kw">const</span> hello <span class="op">=</span> {<span class="dt">hello</span><span class="op">:</span> <span class="st">&quot;world&quot;</span>}</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true"></a></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true"></a>declare <span class="kw">function</span> eqArrays<span class="op">&lt;</span>T<span class="op">&gt;</span>(t1<span class="op">:</span> T[]<span class="op">,</span> t2<span class="op">:</span> T[])<span class="op">:</span> boolean</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true"></a></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true"></a><span class="fu">eqArrays</span>([{<span class="dt">bye</span><span class="op">:</span> <span class="st">&quot;world&quot;</span>}]<span class="op">,</span> [{<span class="dt">hello</span><span class="op">:</span> <span class="st">&quot;world&quot;</span>}]) <span class="co">//compiles</span></span></code></pre></div>
<div class="sourceCode" id="cb32"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true"></a><span class="co">//Compilation error</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true"></a><span class="co">//Property 'bye' is missing in type '{ hello: string; }' but required in type '{ bye: string; }'.ts(2741)</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true"></a><span class="fu">eqArrays</span>([bye], [hello])</span></code></pre></div>
<p>Here is another example:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true"></a><span class="kw">interface</span> Payload<span class="op">&lt;</span>T<span class="op">&gt;</span> {<span class="dt">payload</span><span class="op">:</span> T}</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true"></a></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true"></a><span class="co">// ... we would see the same behavior for:</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true"></a><span class="co">//type Payload1&lt;T&gt; = {payload: T} </span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true"></a></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true"></a>declare <span class="kw">function</span> eqPayloads<span class="op">&lt;</span>T<span class="op">&gt;</span>(t1<span class="op">:</span> Payload<span class="op">&lt;</span>T<span class="op">&gt;,</span> t2<span class="op">:</span> Payload<span class="op">&lt;</span>T<span class="op">&gt;</span>)<span class="op">:</span> boolean</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true"></a></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true"></a><span class="fu">eqPayloads</span>({<span class="dt">payload</span><span class="op">:</span> {<span class="dt">bye</span><span class="op">:</span> <span class="st">&quot;world&quot;</span>}}<span class="op">,</span> {<span class="dt">payload</span><span class="op">:</span> {<span class="dt">hello</span><span class="op">:</span> <span class="st">&quot;world&quot;</span>}})  <span class="co">//compilies</span></span></code></pre></div>
<div class="sourceCode" id="cb34"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a><span class="co">// Compilation error:</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true"></a><span class="co">// Property 'bye' is missing in type '{ hello: string; }' but required in type '{ bye: string; }'.ts(2741)</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true"></a><span class="fu">eqPayloads</span>({payload: bye}, {payload: hello})</span></code></pre></div>
<p>My first instinct was to assume that this weird behavior is caused by TS treating <code>T[]</code> and <code>Payload&lt;T&gt;</code> conservatively as invariant. Unfortunately, this is not the case. The above quirkiness looks to be just another type inference issue and there is a deeper safety problem.</p>
<p>TS implements variance incorrectly and makes both <code>T[]</code> and <code>Payload&lt;T&gt;</code> covariant (e.g. TS assumes that <code>P extends T</code> implies <code>Payload&lt;P&gt; extends Payload&lt;T&gt;</code>). Here is a well known Java language bug reimplemented in TS:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true"></a><span class="co">//how to put a string into a list of numbers</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true"></a><span class="kw">const</span> intlist<span class="op">:</span> number[] <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>]</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true"></a><span class="kw">const</span> list<span class="op">:</span> unknown[] <span class="op">=</span> intlist</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true"></a>list<span class="op">.</span><span class="fu">push</span>(<span class="st">&quot;not a number&quot;</span>) <span class="co">//compiles</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true"></a></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true"></a><span class="co">//array is incorrectly covariant</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true"></a>verifyExtends<span class="op">&lt;</span><span class="kw">typeof</span> datedHello[]<span class="op">,</span> <span class="kw">typeof</span> helloDolly[]<span class="op">&gt;</span>() <span class="co">//datedHello extends helloDolly type</span></span></code></pre></div>
<p>I see the same incorrect subtyping on the <code>Payload</code> interface:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true"></a><span class="co">//interface Payload is incorrectly covariant</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true"></a>verifyExtends<span class="op">&lt;</span>Payload<span class="op">&lt;</span><span class="kw">typeof</span> datedHello<span class="op">&gt;,</span> Payload<span class="op">&lt;</span><span class="kw">typeof</span> helloDolly<span class="op">&gt;&gt;</span>()</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true"></a>verifyExtends<span class="op">&lt;</span>Payload<span class="op">&lt;</span><span class="kw">typeof</span> datedHello<span class="op">&gt;,</span> Payload<span class="op">&lt;</span>object<span class="op">&gt;&gt;</span>()</span></code></pre></div>
<p>Implementations of <code>interface Payload&lt;T&gt;</code> do not need to behave in a covariant way.<br />
An example in the linked github repo exploits <code>interface Payload&lt;T&gt;</code> covariance and ends up passing a <code>number</code> to a function that accepts <code>string</code> input.</p>
<p>Invariance would have been a better (a more conservative) choice for both <code>interface Payload&lt;T&gt;</code> and the array.<br />
A careful reader may notice that the structurally typed <code>type Payload1&lt;T&gt; = {payload: T}</code> should also be invariant since the <code>payload</code> property is mutable (getters are covariant, setters are contravariant). TS incorrectly makes it covariant.</p>
<p>I will sound like a broken record now, subtyping is clearly very complex.</p>
<p>I did more digging into it after writing this note. It appears that the intention was to keep TS conceptually easy (<a href="https://github.com/microsoft/TypeScript/issues/1394" target="_blank">issue 1394</a>).<br />
The result may be easy but is definitely not simple.</p>
<p><em>Incorrect is never simple.</em></p>
<p> <div class="side-note"><strong>Observation (Rant Alert)</strong>: There is a tendency to focus on the common case and ignore the corner case. This tendency has a broad scope, broader than TS. What has (typically) a lower cost: resolving a problem that every user observes when opening the app or resolving a problem that affects 1% of users once a month? Are less frequently observed defects assigned a lower priority? Not really.<br />
The common approach to software and language design and the economics of software maintenance are an ill matched couple.  </div></p>
<h3 id="summary">Summary</h3>
<p>This was a very hard note to write. I rewrote it several times. How do I write about complexity and make it simple to read?<br />
Seems like a catch-22 problem.</p>
<blockquote>
<p>“One does not simply explain TS types”</p>
</blockquote>
<p><em>Boromir about TypeScript</em></p>
<p>Again, my main claims are:</p>
<ul>
<li>subtyping adds significant complexity and lowers type safety</li>
<li>ad-hoc semantic narrowing around JS operators partially recovers safety, but is complex by itself and scope limited</li>
</ul>
<p>Languages with simpler and more reliable type systems are not a superset of JS syntax and are idiomatically far from JS<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>.</p>
<p>We have observed some compilation issues and irregularities. To summarize these:</p>
<ul>
<li>issues inferring literal types widened to a union (<a href="#subtyping"><code>eq(1, "boo")</code></a>)</li>
<li>issues preventing intersecting unions involving literal types (<a href="#subtyping"><code>(1 | "boo") &amp; ("boo" | Person)</code></a>)</li>
<li>unexpected widening of literal object property types (<a href="#hidden-blooper-side-note">hidden blooper</a>)</li>
<li>inconsistent widening of function arguments (top of <a href="#variance-problems">variance problems</a>)</li>
<li>incorrect handling of variance (<a href="#variance-problems">variance problems</a>)</li>
<li><code>===</code> rejects the <code>&amp;</code> overlap of intersection types, while claiming the opposite in the error message (<a href="#semantics-rejected-overlap">rejected overlap</a>)</li>
</ul>
<p>Introduced tools</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true"></a>declare <span class="kw">function</span> unify<span class="op">&lt;</span>T<span class="op">&gt;</span>(t1<span class="op">:</span> T<span class="op">,</span> t2<span class="op">:</span> T) <span class="op">:</span> T</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true"></a><span class="kw">function</span> verifyExtends<span class="op">&lt;</span>T2 <span class="kw">extends</span> T1<span class="op">,</span> T1<span class="op">&gt;</span>() {}</span></code></pre></div>
<p>can ask TS subtyping questions.</p>
<h2 id="next-chapter">Next Chapter</h2>
<p>This post has been about the “messy” in TS. The next installment will focus on programming with type variables and will present TS in a better light. I decided to split advanced topics into 2 smaller posts. I plan to discuss phantom types, type variable scoping, a pattern emulating existential types, and rank 2 types. I consider these to be quite useful typing approaches.</p>
<p>Happy New Year to all of my readers. Thank you for reading.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p><a href="#semantics-rejected-overlap">rejected overlap</a> section explains why I call it a guess.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>All can be used for frontend development and can be compiled to JS.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>Haskell is still improving on this aspect. IMO, the need for polymorphic access to record fields is overrated. I would trade it for a capable compiler any time.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>I have not used <em>flow</em> recently, and I cannot compare TS to it. However <em>flow</em> has subtyping which I do not consider simple. Indeed, some level of subtyping support is needed to support commonly used JS idioms.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

    </section>
</article>
]]></description>
    <pubDate>Mon, 03 Jan 2022 00:00:00 UT</pubDate>
    <guid>https://rpeszek.github.io//posts/2022-01-03-ts-types-part3.html</guid>
    <dc:creator>Robert Peszek</dc:creator>
</item>
<item>
    <title>Type Enthusiast's Notes about TypeScript. Part 2. Typing Honestly</title>
    <link>https://rpeszek.github.io//posts/2021-12-24-ts-types-part2.html</link>
    <description><![CDATA[<article>
    <section class="header">
        Posted on December 24, 2021
        
            by Robert Peszek
        
        
        
        
        <div class="info">Tags: <a title="All pages tagged 'TypeScript-Notes'." href="../tags/TypeScript-Notes.html">TypeScript-Notes</a></div>
        
    </section>
    <section>

    </section>
    <section>
        <div class="toc"><div class="header">Table of Contents</div>
<ul>
<li><a href="#nutshell">Nutshell</a></li>
<li><a href="#can-i-trust-the-types">Can I trust the types?</a></li>
<li><a href="#note-about-the-any-type">Note about the <code>any</code> type</a></li>
<li><a href="#casting-casting-in-a-bad-light">Casting <em>casting</em> in a bad light</a>
<ul>
<li><a href="#improving-office.js-with-type-predicates">Improving <em>office.js</em> with type predicates</a></li>
</ul></li>
<li><a href="#note-about-the-unknown-type">Note about the <code>unknown</code> type</a></li>
<li><a href="#honest-typing-conventions">Honest typing conventions</a>
<ul>
<li><a href="#referential-transparency">Referential Transparency</a></li>
<li><a href="#types-as-documentation">Types as documentation</a></li>
</ul></li>
<li><a href="#next-chapter">Next Chapter</a></li>
</ul>
</div>
<p><em>Please Leave Feedback in: <a href="https://github.com/rpeszek/rpeszek.github.io/discussions/1" target="_blank">git discussions</a></em></p>
<p>Previous post: <a href="2021-12-12-ts-types-part1.html" target="_blank">Part 1. Typing in Anger</a>.</p>
<p><strong>DRAFT version</strong> <em>(I am sorry about any misprints. It seems I have goblins in my laptop that toy with me, remove or change words. When this note disappears, you will know that I gave up.)</em></p>
<p><strong>Disclaimers:</strong> (imagine this is a very small font, read it very fast in a half whisper)<br />
<em>I assume strict compiler flags are on, something you get by default with scaffolding, e.g. using <code>create-react-app my-project --template typescript</code> is close enough.<br />
The code examples have been tested with TypeScript v4.4.4 and v4.5.2.<br />
office.js examples are based on https://appsforoffice.microsoft.com/lib/1.1/hosted/office.js and <span class="citation" data-cites="types/office-js">@types/office-js</span><span class="citation" data-cites="1.0.221">@1.0.221</span> (these match the current scaffold for office.js/React).<br />
This post is a pandoc output of a markdown document and code examples are not interactive.<br />
Most of the code examples are published in <a href="https://github.com/rpeszek/ts-experiments/tree/master/ts-notes" target="_blank">ts-notes</a> folder in this github repo: <a href="https://github.com/rpeszek/ts-experiments" target="_blank">ts-experiments</a>.</em></p>
<p><strong>Motivating Quote for the series:</strong></p>
<blockquote>
<p>“TypeScript began its life as an attempt to bring traditional object-oriented types to JavaScript so that the programmers at Microsoft could bring traditional object-oriented programs to the web. As it has developed, TypeScript’s type system has evolved to model code written by native JavaScripters. The resulting system is <em>powerful, interesting and messy.</em>”</p>
</blockquote>
<p><em>From typescriptlang <a href="https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html" target="_blank">TypeScript for Functional Programmers</a></em></p>
<h2 id="nutshell">Nutshell</h2>
<p>This is the second post in the series devoted to types in TypeScript. In this series, I explore type-centric approaches to writing code and often push TS to its limits in doing so. I am writing these posts for like minded developers who are interested in types and either use or consider using TypeScript.</p>
<p>This post will cover TS’s type predicates, the notorious <code>any</code>, and its safer cousin the <code>unknown</code>. These are well known and heavily blogged topics. My goal is provide a little different perspective with a more type-centric view point.<br />
This series uses <em>office.js</em> as a source of code examples. This post examines the correctness of <em>office.js</em> types and fixes them using type predicates.<br />
My main code example is something I am excited about. It demonstrates a case where TS made me completely rethink a previously written JS code.<br />
I will discuss some safety concerns about <code>unknown</code> (no, this is not a typo, I mean the <code>unknown</code> type) and will set the stage for my future note about complexity of TS types.<br />
I will finish in the realm of coding conventions discussing transparent, self documenting type definitions.</p>
<h2 id="can-i-trust-the-types">Can I trust the types?</h2>
<p>I am going to discuss the obvious gotcha in a gradually typed language like TS: runtime values do not satisfy statically defined types.<br />
Despite it being an obvious concern, the issue is something a developer who spends most time in a statically typed language (e.g. me) will not have on his / her mind when working in TS.<br />
The following seem to be the prevalent reasons for why values do not match types: overconfident TS code (e.g. type casting, <code>any</code> type), issues with converted JavaScript (declaration files out of sync or containing otherwise incorrect definitions). I am going to show a real life (or close to real life) example of each.</p>
<p>The series started with an example defining the <code>Person</code> type, to avoid jumping back and forth I will repeat it here</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>type Person <span class="op">=</span> {<span class="dt">firstNm</span><span class="op">:</span> string<span class="op">,</span> <span class="dt">lastNm</span><span class="op">:</span> string} </span></code></pre></div>
<p>This will be a good conversation starter:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="co">//Questionable JSON parsing example</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="kw">const</span> p<span class="op">:</span> Person <span class="op">=</span> <span class="bu">JSON</span><span class="op">.</span><span class="fu">parse</span>(<span class="st">'&quot;John Smith&quot;'</span>)</span></code></pre></div>
<p>Your experience with consistency of JSON data may be different from mine. I rarely see JSON issues in front-end – back-end conversation. On the other hand, my experience with using 3rd party REST APIs is not exactly stellar. JSON data problems do happen.</p>
<p>The above code illustrates what I used to call ‘fail late’ and now I call ‘a type I cannot trust’ case. It is a nasty situation where runtime errors are nowhere near the actual problem. Looking at the example, <code>JSON.parse</code> function is declared to return the TS’s notorious <code>any</code> type. Using <code>any</code> bypasses type checking and the code assigns the result to <code>Person</code>. The actual run-time value of <code>p</code> will be a <code>string</code>, while the type checker is now convinced it is <code>p:Person</code>.</p>
<p>Now, look at the top rated answer in this stackoverflow: <a href="https://stackoverflow.com/questions/38688822/how-to-parse-json-string-in-typescript" target="_blank">how-to-parse-json-string-in-typescript</a>. It appears that the above code matches the top rated answer. Yes, safer approaches are available (look at less popular answers, we will discuss a much safer way as well).<br />
I am not claiming this to be a prevalent problem in TS code, but it is an interesting issue caused by the coexistence of the typed and the untyped.</p>
<p>Now, since I already may have angered a large part of the TS community (did I? I hope not.), let’s beat a little on <strong><em>office.js</em></strong>.</p>
<p><em>office.js</em> is a source of code examples for my series. Looking into <em>office.js</em> release history suggests that the bond between <em>office.js</em> and TypeScript developed very early. It looks like these projects grew up together. <em>office.js</em> might have even been one of these Microsoft projects that spearheaded the development of TS.</p>
<p><strong>Short Recap</strong> We are using <em>office.js</em> to interact with Outlook emails. <em>office.js</em> provides us with <code>item: Office.MessageRead</code> allowing us to retrieve data from an email opened in read-only mode. <strong>(Recap End)</strong></p>
<p>I imagine it is not that uncommon for a TS library to have a non-nullable property that is undefined at runtime.<br />
The IntelliSense tells me that <code>item: Office.MessageRead</code> contains an overloaded <code>item.body.getTypeAsync</code> method. I was hoping to use it to retrieve the type (plain text vs html) of the email body.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>(method) Office<span class="op">.</span><span class="at">Body</span><span class="op">.</span><span class="fu">getTypeAsync</span>(options<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncContextOptions</span><span class="op">,</span> callback<span class="op">?:</span> ((asyncResult<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncResult</span><span class="op">&lt;</span>Office<span class="op">.</span><span class="at">CoercionType</span><span class="op">&gt;</span>) <span class="kw">=&gt;</span> <span class="kw">void</span>) <span class="op">|</span> <span class="kw">undefined</span>)<span class="op">:</span> <span class="kw">void</span> (<span class="op">+</span><span class="dv">1</span> overload)</span></code></pre></div>
<p><code>getTypeAsync</code> is undefined at runtime. It looks to me like the TS declaration files are not in sync with JavaScript. My hypothesis seems to be confirmed by the <a href="https://docs.microsoft.com/en-us/javascript/api/outlook/office.body?view=outlook-js-preview#getTypeAsync_callback_" target="_blank"><code>item.body.getTypeAsync</code></a> documentation suggesting that this method is available when email is open in compose mode (not when using <code>Office.MessageRead</code>). (I am using office online and the latest <em>office.js</em> as of the time of this writing.)<br />
<em>Please message me in git discussions if you think I am misrepresenting it.</em></p>
<p><em>It seems like <em>office.js</em> types are a little off.</em></p>
<p>We should look at the type definition of the <em>office.js</em> <a href="https://docs.microsoft.com/en-us/javascript/api/outlook/office.item?view=outlook-js-preview" target="_blank"><code>Office.context.mailbox.item</code></a> a little closer.<br />
This property is overloaded to be one of the following types (let me call them <em>facets</em>):</p>
<blockquote>
<p><code>Office.AppointmentCompose</code> (composing calendar entry)<br />
<code>Office.AppointmentRead</code> (read-only calendar entry)<br />
<code>Office.MessageCompose</code> (composing email)<br />
<code>Office.MessageRead</code> (read-only email)</p>
</blockquote>
<p>These <em>facet</em> types are all different. For example, to get email subject you use <code>item.subject:string</code> if you are working with <code>Office.MessageRead</code> or <code>item.subject:Office.Subject</code> if you are working with <code>Office.MessageCompose</code>.<br />
<code>Office.Subject</code> contains <code>getAsync</code>, <code>setAsync</code> methods and is absolutely not a <code>string</code>.</p>
<p>The type of <code>item</code> provided by <em>office.js</em> is not, as I would expect:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="co">//Type I expected</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>AppointmentCompose <span class="op">|</span> AppointmentRead <span class="op">|</span> MessageCompose <span class="op">|</span> MessageRead</span></code></pre></div>
<p>Rather it is closer (I have not listed all the <code>&amp;</code>-s) to:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="co">//Actual Type with some &amp; parts removed </span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>AppointmentCompose <span class="op">&amp;</span> AppointmentRead <span class="op">&amp;</span> MessageCompose <span class="op">&amp;</span> MessageRead</span></code></pre></div>
<p>Basically, the type <em>office.js</em> chose for <code>item</code> mashes all the available properties, methods, overloads into one type. This is simply an incorrect type for the <code>item</code> property. Runtime values do not satisfy the <em>intersection</em> type, they satisfy the <em>union</em> type. Type checked programs will fail at runtime. <em>office.js</em> type declarations are incorrect.</p>
<p><em>office.js types are off for sure.</em></p>
<p>In a weird way, this explains why the undefined <code>item.body.getTypeAsync</code> has not been noticed. Without a corrective reassignment to, say, <code>Office.MessageRead</code> many other methods are <code>undefined</code> at runtime and it is harder to single this particular one out.</p>
<p>Gradual typing over the wild-west JS has to come with maintenance challenges.<br />
Nonetheless this is surprising. What are the types good for if they’re not accurate?</p>
<blockquote>
<p>“You take the blue pill — the story ends, you wake up in your bed and believe whatever you want to believe.<br />
You take the red pill — you stay in Wonderland, and I show you how deep the rabbit hole goes”</p>
</blockquote>
<p><em>Morpheus about not believing types in a gradually typed language</em><br />
<em>… nightmares of JavaScript running on my walls and ceilings make me wake up screaming</em></p>
<h2 id="note-about-the-any-type">Note about the <code>any</code> type</h2>
<p>My first example in this post used the infamous <code>any</code> type. Let’s have a closer look.</p>
<p><code>any</code> type is crazy. It behaves like the <em>top</em> (you can assign any other type to it). It also behaves like the <em>bottom</em> (it can be assigned to any other type, maybe except of <em>never</em>). Ideally, the bottom type is empty, this one clearly is not.</p>
<p><em>As a result, any value can have any type.</em></p>
<p>We should have some fun with this.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="co">//express yourself with _any_ (notice no casting, only assignments)</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="kw">const</span> sad<span class="op">:</span> any <span class="op">=</span> <span class="st">&quot;emptiness and sadness&quot;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a><span class="kw">const</span> sadVoid<span class="op">:</span> <span class="kw">void</span> <span class="op">=</span> sad</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a><span class="kw">const</span> myCallback <span class="op">=</span> (n<span class="op">:</span> number)<span class="op">:</span> <span class="kw">void</span> <span class="kw">=&gt;</span> {</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>    <span class="cf">return</span> sadVoid<span class="op">;</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>}</span></code></pre></div>
<p>You can have your own favorite <code>null</code> that is not <code>null</code> value, you can <em>define</em> your own <code>undefined</code>. Sky and your creativity are the limits. I will spoil this party and say that I do not recommend doing it. Oh, maybe just a little. Well OK, one more:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">const</span> sassy<span class="op">:</span> any <span class="op">=</span> {<span class="dt">netWorth</span><span class="op">:</span> <span class="st">&quot;billion dollars&quot;</span><span class="op">,</span> <span class="dt">popularityLevel</span><span class="op">:</span> <span class="st">&quot;celebrity&quot;</span>}</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="kw">const</span> sassyNull<span class="op">:</span> <span class="kw">null</span> <span class="op">=</span> sassy</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a><span class="kw">const</span> p<span class="op">:</span> Person <span class="op">|</span> <span class="kw">null</span> <span class="op">=</span> sassyNull</span></code></pre></div>
<p>A bottom that is not empty will cause the language to be unsound. Allowing all values in a bottom type, I would call it insane.<br />
However, using an <em>any</em> type similar to TS’s seems to be a common practice in gradually typed languages (e.g. Python does it too).<br />
Using <code>any</code> is like saying “hey, TS, please suspend type checking, I know what I am doing”. This is the antithesis of type safety, but what else can TS do and maintain JS compatibility?</p>
<p>Actually, TS has a very clever solution for this, it is described in the following sections.<br />
I view <code>any</code> as a form of type coercion or casting.</p>
<h2 id="casting-casting-in-a-bad-light">Casting <em>casting</em> in a bad light</h2>
<p>I will use the term casting and type coercion interchangeably. TypeScript documentation also uses the term <em>type assertion</em>. I view the <code>any</code> type to be in the same boat as well (an implicit type coercion).<br />
TS uses the <code>t as T</code> or <code>&lt;T&gt; t</code> syntax to cast expression <code>t</code> into type <code>T</code>, e.g. <code>iAmSureIsString as string</code>.<br />
(IMO, the second notation, <code>&lt;T&gt; t</code>, is somewhat unfortunate as it is very similar to type application and generic function declaration e.g. <code>const f = &lt;T&gt;():T</code> declares, <code>&lt;T&gt;f()</code> casts, <code>f&lt;T&gt;()</code> applies. I recommend the <code>v as T</code> syntax to make casting more explicit and searchable in your code.)</p>
<p> <div class="side-note"><strong>Type enthusiast’s note on casting at large:</strong><br />
Typically (and rightly) casting is considered to be a last resort, <em>only cast if you must</em>.</p>
<p>With more involved types it is often harder to write code that type checks. That increases the appeal of casting or finding some other alternatives for nudging the type checker into agreeing.<br />
Some languages offer the ability to write a program to persuade the type checker about type equality (write actual <em>proof of type equality</em>). This is an advanced feature and is available in only a few languages (e.g. Coq, Idris, Haskell). Writing such programs is often challenging or even impossible. (I consider writing such proofs to be one of the highest level “type games” that a developer can play. It is both a challenge and fun. A great intro is <a href="https://www.manning.com/books/type-driven-development-with-idris" target="_blank">TDD with Idris</a>)</p>
<p>There is an alternative to type coercion that allows programs to type check but will throw an exception when executed.<br />
This can be useful for interacting with the type checker when writing code. We have seen a TS version of this already, function <a href="2021-12-12-ts-types-part1.html#type-holes" target="_blank"><code>_&lt;T&gt;(): T</code></a>, defined in my previous post and stolen from <a href="https://dev.to/gcanti/type-holes-in-typescript-2lck" target="_blank">Type holes in TS</a>. Such programming practice is foreign to most languages but becomes very convenient when working with more involved types. We are using it in this series.  </div></p>
<p>Let’s beat on <em>office.js</em> some more. <a href="https://docs.microsoft.com/en-us/javascript/api/outlook/office.item" target="_blank">Here</a> is a piece <em>office.js</em> documentation about (you guessed it, this post is so very predictable) the <a href="https://docs.microsoft.com/en-us/javascript/api/outlook/office.item" target="_blank"><code>Office.context.mailbox.item</code></a>:</p>
<blockquote>
<p>If you want to see IntelliSense for only a specific type or mode, <strong>cast</strong> this item to one of the following:<br />
<code>AppointmentCompose</code><br />
<code>AppointmentRead</code> …</p>
</blockquote>
<p>TS offers a neat alternative to casting. I will explain it by <em>not</em> following the <em>office.js</em> documentation ;)</p>
<p>As I indicated already, I can interact with outlook email using <code>Office.context.mailbox.item</code>. However, <code>item</code> property is overloaded into several types discussed in the previous section (I called them <em>facets</em>):</p>
<p>The legacy code I am currently re-implementing at work is retrieving the email subject using <code>item.subject</code> and checking what kind of <code>item.subject</code> it is (a string, has asyc methods, etc) and using it accordingly. It does a similar <em>“check before you use”</em> game to retrieve <code>to</code>, <code>from</code>, <code>cc</code> and other email information.<br />
Such an approach is typical, almost idiomatic to JS. It is also hard to maintain as making changes directed at one facet can easily break the other facets. And you can test your heart out on all emails you can think about and your app will still crash and burn if used with an office calendar appointment.</p>
<p>So what is the new TS-idiomatic way to do it?  TS has the <code>is</code> types.</p>
<h3 id="improving-office.js-with-type-predicates">Improving <em>office.js</em> with type predicates</h3>
<div class="sourceCode" id="cb8"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="im">export</span> <span class="kw">const</span> isMessageRead <span class="op">=</span> (item<span class="op">:</span> any)<span class="op">:</span> item is Office<span class="op">.</span><span class="at">MessageRead</span> <span class="kw">=&gt;</span> {</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>    <span class="cf">return</span> (item<span class="op">.</span><span class="at">itemType</span> <span class="op">===</span> Office<span class="op">.</span><span class="at">MailboxEnums</span><span class="op">.</span><span class="at">ItemType</span><span class="op">.</span><span class="at">Message</span>) <span class="op">&amp;&amp;</span> item<span class="op">.</span><span class="at">getAttachmentsAsync</span> <span class="op">===</span> <span class="kw">undefined</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>} </span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>  </span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a><span class="im">export</span> <span class="kw">const</span> isMessageCompose <span class="op">=</span> (item<span class="op">:</span> any)<span class="op">:</span> item is Office<span class="op">.</span><span class="at">MessageCompose</span> <span class="kw">=&gt;</span> {</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>    <span class="cf">return</span> (item<span class="op">.</span><span class="at">itemType</span> <span class="op">===</span> Office<span class="op">.</span><span class="at">MailboxEnums</span><span class="op">.</span><span class="at">ItemType</span><span class="op">.</span><span class="at">Message</span>) <span class="op">&amp;&amp;</span> item<span class="op">.</span><span class="at">getAttachmentsAsync</span> <span class="op">!==</span> <span class="kw">undefined</span> </span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a>} </span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a>declare <span class="kw">function</span> <span class="fu">doSomethingWithViewedEmail</span>(item<span class="op">:</span> Office<span class="op">.</span><span class="at">MessageRead</span>)<span class="op">:</span> <span class="kw">void</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a>declare <span class="kw">function</span> <span class="fu">doSomethingWithComposedEmail</span>(item<span class="op">:</span> Office<span class="op">.</span><span class="at">MessageCompose</span>)<span class="op">:</span> <span class="kw">void</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a>declare <span class="kw">function</span> <span class="fu">onlyEmailEntriesAreSupported</span>()<span class="op">:</span> <span class="kw">void</span></span></code></pre></div>
<p>(OK, checking <code>getAttachmentsAsync</code> is ugly, office.js could provide some nicer and more stable way to identify the exact <code>item</code> type. This is still not bad. Let’s move on.)</p>
<p><code>doSomethingWithViewedEmail</code> and <code>doSomethingWithComposedEmail</code> can now be coded with confidence (if I trust <em>office.js</em> types) following the corresponding <code>MessageRead</code> or <code>MessageCompose</code> types. IntelliSense makes writing these a breeze and the code is very clean. E.g., <code>subject</code> is just a <code>string</code> in <code>MessageRead</code>.</p>
<p>I can use these without any casting:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="co">//'unknown' replaces incorrect office.js type (see previous section). </span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a><span class="kw">const</span> item<span class="op">:</span> unknown <span class="op">=</span> Office<span class="op">.</span><span class="at">context</span><span class="op">?.</span><span class="at">mailbox</span><span class="op">?.</span><span class="at">item</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a><span class="cf">if</span>(<span class="fu">isMessageRead</span>(item)) {</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>  <span class="co">//doSomethingWithComposedEmail(item) //this will not type check!</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>  <span class="fu">doSomethingWithViewedEmail</span>(item)    </span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>} <span class="cf">else</span> <span class="cf">if</span> (<span class="fu">isMessageCompose</span>(item)) {</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>  <span class="co">//doSomethingWithViewedEmail(item) //this will not type check!</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a>  <span class="fu">doSomethingWithComposedEmail</span>(item)  </span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a>} <span class="cf">else</span> {   </span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true"></a>  <span class="fu">calendarEntriesAreNotSupported</span>()</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true"></a>}</span></code></pre></div>
<p>This is a really nice, bravo TypeScript! Simple to use, yet very useful.</p>
<p>It is also IMO a very interesting case of TS making a bigger impact on how we actually code. <em>“Check before you use”</em> game becomes type assisted and happens on a larger scale of <code>item</code> types instead of single (e.g. the email <em>subject</em>, <em>from</em>, <em>cc</em>, etc.) properties.<br />
This adds a lot of clarity to the code. TS types not just check my code, types change how I code!</p>
<p><code>t is T</code> type is one of the TypeScript <a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html" target="_blank">narrowing</a> tools. The documentation refers to it as a <em>type predicate</em> or a <em>type guard</em> (a more general term).<br />
IMO, the idea of a middle ground between type checked safety and unsafe type coercion is brilliant.<br />
It is something that sits a half way between a cast and a type equality proof.<br />
This will probably influence other languages (e.g. here is <a href="https://www.python.org/dev/peps/pep-0647/" target="_blank">enhancement proposal for Python</a>).</p>
<p>The syntax <code>t is T</code> is interesting, it clearly borrows from dependently typed languages. The value <code>t</code> appears next to the type <code>T</code> and comes from the earlier part of the declaration. This also somewhat justifies the existence of otherwise cumbersome parameter names in type definitions (something I complained about in my <a href="2021-12-12-ts-types-part1.html#office.js.-using-ts-in-anger" target="_blank">previous post</a>).</p>
<p>I hope the TS community develops a healthy aversion to casting. Why would you use a type checker if you keep subverting it? I also hope that exporting functions returning type predicates will become a standard practice for APIs.</p>
<p><strong>Use of <code>any</code> in type predicates</strong><br />
Arguably, a safer approach was to define <code>isMessageRead</code> and <code>isMessageCompose</code> using a parameter type that is more restrictive than <code>any</code>.<br />
My goal was to keep this example very simple and avoid introducing a <code>CorrectedOfficeItem</code> type to fix <em>office.js</em> typing. In real code, I would opt in for introducing the corrected type. Linked github repo defines and uses <code>CorrectedOfficeItem</code>.<br />
However, using <code>any</code> in type predicate implementations appears to be a common practice. Implementing a type predicate typically requires checking for existence of object properties and <code>any</code> provides access to these.<br />
My suggestion is to avoid type guards in certain places, e.g. in generics. We want generics to be generic.</p>
<h2 id="note-about-the-unknown-type">Note about the <code>unknown</code> type</h2>
<p>This post started with unsafe use of <code>JSON.parse</code>. I am quite sure that if TypeScript could travel back in time <code>JSON.parse</code> would return <code>unknown</code> instead of <code>any</code>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="im">export</span> <span class="kw">const</span> safeParseJSON <span class="op">:</span> (_<span class="op">:</span> string) <span class="kw">=&gt;</span> unknown <span class="op">=</span> <span class="bu">JSON</span><span class="op">.</span><span class="fu">parse</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a><span class="kw">const</span> isPerson <span class="op">=</span> (p<span class="op">:</span> any)<span class="op">:</span> p is Person <span class="kw">=&gt;</span> </span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>        <span class="kw">typeof</span> p<span class="op">.</span><span class="at">firstNm</span> <span class="op">===</span> <span class="st">'string'</span> <span class="op">&amp;&amp;</span> <span class="kw">typeof</span> p<span class="op">.</span><span class="at">lastNm</span> <span class="op">===</span> <span class="st">'string'</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a><span class="kw">const</span> possiblyPerson <span class="op">=</span> <span class="fu">safeParseJSON</span>(<span class="st">'&quot;John Smith&quot;'</span>) </span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a><span class="cf">if</span> (<span class="fu">isPerson</span>(possiblyPerson)) {</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a>    <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(possiblyPerson<span class="op">.</span><span class="at">firstNm</span>)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true"></a>} <span class="cf">else</span> {</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true"></a>    <span class="co">// console.log(possiblyPerson.firstNm) //does not compile</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true"></a>}</span></code></pre></div>
<p><code>unknown</code> is a newer and a safer alternative to <code>any</code>.</p>
<p><code>unknown</code> type is (only) the top type (you can assign anything to it but you cannot assign it to anything else, maybe except for <code>any</code>). This is a much better safety than being both the <em>top</em> and the <em>bottom</em>. Compared to <code>any</code> it is more cumbersome to use but significantly safer.</p>
<p>A rough view (IMO) of what type safety is: an ability to <em>separate apples from oranges</em>. If you can assign both an apple to <code>unknown</code> and an orange to <code>unknown</code> then they are no longer separated.<br />
What makes this worse in TS, is its occasional tendency to widen return types to <code>unknown</code>. TS tends to do that if it cannot find a more precise return type or when it gets confused. We saw two examples of this in the last post:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="co">//compilation bug allows this incorrect code to compile with</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a><span class="co">// emailBody4: unknown</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a><span class="co">//this code will accutally work at runtime because 'crazyConfig' ends up not being used </span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a><span class="kw">const</span> crazyConfig <span class="op">:</span> (_<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncResult</span><span class="op">&lt;</span>string<span class="op">&gt;</span>) <span class="kw">=&gt;</span> <span class="kw">void</span> <span class="op">=</span> x <span class="kw">=&gt;</span> <span class="st">&quot;&quot;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a><span class="kw">const</span> emailBody4 <span class="op">=</span> <span class="cf">await</span> <span class="fu">officePromise</span> (<span class="fu">curry3</span>(item<span class="op">.</span><span class="at">body</span><span class="op">.</span><span class="at">getAsync</span>)(Office<span class="op">.</span><span class="at">CoercionType</span><span class="op">.</span><span class="at">Html</span>)(crazyConfig)) </span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a><span class="co">//test: (a: unknown) =&gt; (b: unknown) =&gt; unknown</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a><span class="kw">const</span> test <span class="op">=</span> <span class="fu">curry</span>({} <span class="im">as</span> any)</span></code></pre></div>
<p>Also, notice <code>unknown</code> in some <a href="2021-12-12-ts-types-part1.html#compilation-bloopers" target="_blank">blooper</a> examples from the previous post:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="co">//these should not compile but they do. Names are consitent with previous post and the linked github repo</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a><span class="co">//const nonsense2: &lt;T1, T2, R&gt;(a: (ax: T1, bx: T2) =&gt; R) =&gt; (b: unknown) =&gt; (a: T1) =&gt; (b: T2) =&gt; R</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a><span class="kw">const</span> nonsense2 <span class="op">=</span> <span class="fu">curry</span>(curry) </span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a><span class="co">//const nonsense3: &lt;T1, T2, T3, R&gt;(a: (ax: T1, bx: T2, cx: T3) =&gt; R) =&gt; (b: unknown) =&gt; (a: T1) =&gt; (b: T2) =&gt; (c: T3) =&gt; R</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a><span class="kw">const</span> nonsense3 <span class="op">=</span> <span class="fu">curry</span>(curry3)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a><span class="co">//const nonsense4: &lt;T1, T2, R&gt;(a: (ax: T1, bx: T2) =&gt; R) =&gt; (b: unknown) =&gt; (b: unknown) =&gt; (a: T1) =&gt; (b: T2) =&gt; R</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a><span class="kw">const</span> nonsense4 <span class="op">=</span> <span class="fu">curry</span>(<span class="fu">curry</span>(curry))</span></code></pre></div>
<p>and we will encounter more examples of <em>unsafe widening</em> in future notes. It seems like TS tends to widen types to <code>unknown</code> instead of reporting a compilation error. This, in turn, makes things less safe.</p>
<p>I really love the fact that this code (a contrived example but generalizes easily to real situations) does not compile:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="co">//Compilation error:</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a><span class="co">//This condition will always return 'false' since the types 'string' and 'number' have no overlap.</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a><span class="st">&quot;some email body&quot;</span> === <span class="dv">1</span> </span></code></pre></div>
<p>However, this does compile:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a>(<span class="st">&quot;some email body&quot;</span> <span class="im">as</span> unknown) <span class="op">===</span> <span class="dv">1</span></span></code></pre></div>
<p>and so does this:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a>emailBody4 <span class="op">===</span> <span class="dv">1</span></span></code></pre></div>
<p>Let’s bring in the type hole <a href="2021-12-12-ts-types-part1.html#type-holes" target="_blank"><code>_&lt;T&gt;(): T</code></a> from the last post. The type hole is a convenient way to ask the compiler type questions.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="co">//hovering over res and _ allows me to see the typing of '===`</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a><span class="kw">const</span> res <span class="op">=</span> <span class="fu">_</span>() <span class="op">===</span> <span class="fu">_</span>()</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>(<span class="dv">1</span> <span class="im">as</span> <span class="dv">1</span>) <span class="op">===</span> <span class="fu">_</span>()</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a><span class="fu">_</span>() <span class="op">===</span> (<span class="dv">1</span> <span class="im">as</span> <span class="dv">1</span>)</span></code></pre></div>
<p>So the type signature of <code>===</code> is:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>declare <span class="kw">function</span> <span class="fu">eqeqeq</span>(a<span class="op">:</span> unknown<span class="op">,</span> b<span class="op">:</span> unknown)<span class="op">:</span> boolean</span></code></pre></div>
<p>Except</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="fu">eqeqeq</span>(<span class="st">&quot;some text&quot;</span><span class="op">,</span> <span class="dv">1</span>) <span class="co">//compiles</span></span></code></pre></div>
<div class="sourceCode" id="cb19"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="st">&quot;some text&quot;</span> <span class="op">===</span> <span class="dv">1</span> <span class="co">//does not compile</span></span></code></pre></div>
<p>In fact, <code>===</code> <em>does not have a type</em>. It is a built-in JS operator. TS applies semantic narrowing rules to the code that uses it.<br />
This complex approach is needed to provide type safety while maintaining compatibility with JS.<br />
TS’s semantic rules prevent certain types like <code>someText === someNumber</code> from compiling, except, this safety is somewhat fragile and breaks when <code>someText</code> or <code>someNumber</code> are accidentally widened to <code>unknown</code> by the type inference. TS uses a similar approach for other built-in JS operators. (We will discuss <code>===</code> semantics in a deeper detail in the next post.)</p>
<p><strong>General safety concerns about the top:</strong> Developers, like me, who had spent decades working in languages like Java and then switched to a typed FP language see immediate safety benefits just because there isn’t any top type. The concern about <code>unknown</code> is that it can be used with many JS functions and operators. Such use is not type safe, similarly to how Java’s <code>Object</code> methods are not type safe.<br />
From the type safety point of view, these JS functions and operators are not implemented well either. Consider for example <code>JSON.stringify</code> which accepts <code>any</code>. Does this expression (it returns <code>undefined</code>) make much sense to you: <code>JSON.stringify(() =&gt; {})</code>?<br />
Generic functions lose safety too, generics are not <em>generic</em> if a generically typed function parameter can use a <em>specific</em> JS function.</p>
<p>Something like <code>unknown</code> is probably the only way for TS to achieve JS compatibility, nonetheless <code>unknown</code> is not ideal.</p>
<p>I will come back to this discussion again, I plan to discuss the complexity of TS types. I will also return to the <code>unknown</code> type itself in the future in a more theoretical setting.</p>
<h2 id="honest-typing-conventions">Honest typing conventions</h2>
<p>These notes will be a little ranty (you’ll probably ask: “Did you read your other notes?”). Any coding convention is effectively a hand waving rant. That is why we use types, so we can rant less!</p>
<p>One of my former colleagues liked to use the phrase “gentlemen’s agreement”. It means an agreement between developers to self impose certain limitations on the code they write. These limitations are not enforced by the compiler, only by developers who agree to abide by the set rules. Coding guidelines, design patterns, you know what I am talking about.</p>
<p>There is a term in Programming Language Theory called <em>parametricity</em>. Roughly speaking, a language that supports <em>parametricity</em> can assure that a generic function cannot discover what is the type behind a type variable. Remove the top and the bottom from the language too. You are left with very precise types. As an example,</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a>declare <span class="kw">function</span> someName<span class="op">&lt;</span>T<span class="op">&gt;</span>(t<span class="op">:</span>T)<span class="op">:</span> T</span></code></pre></div>
<p>could be only implemented as an identity. Incidentally, there are a few languages that support strict parametricity and a few that come very close.</p>
<p>Can you write a whole single page app in TS and give it that signature? I bet you can.<br />
We would probably not call it a type-lie. Calling it not descriptive would probably be more accurate. Or, maybe just not the best design?<br />
If some type definitions are better than others, which of them are better? Apps are written so the decisions are being made, but based on what?</p>
<p>I will give you my very type centric view of programming:</p>
<ol type="1">
<li>Well written program means well typed. Well typed means the types express what is happening.<br />
</li>
<li>Types are more fundamental than a programming language.</li>
<li>Coding conventions supplement the language in implementing typing concepts.</li>
<li>TS (or any programming language) programming needs a balancing act. My approach for writing TS is to balance principled and safe with approachable and informative. That balance is subjective and project specific, my balance point may differ from yours.</li>
</ol>
<p><strong>Expanding on 2:</strong><br />
TS type checks my code, I type check TS (last post). A library (e.g. <em>office.js</em>) provides types, I type check these types and fix some of them (this post). Developer interventions are needed. Understanding of types does not change with a programming language environment. The cumbersomeness of their use does. TS is, comparatively speaking, not that bad.</p>
<p><strong>Expanding on 3:</strong><br />
In TS, almost any program can have almost any type. I can implement</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="kw">function</span> <span class="fu">program</span>()<span class="op">:</span> <span class="kw">void</span> {<span class="op">...</span>}</span></code></pre></div>
<p>and do almost anything I want in that code.<br />
It would not be very clear if most of my types looked like this. There needs to be some coding convention that discourages such code.<br />
Enforcing some level of parametricity when implementing generics would be another example of a coding convention.</p>
<p><em>The goal is to move from designing programs to designing types.</em><br />
<em>This post suggests that types are used to define coding conventions.</em></p>
<p>Here are some bootstrapping ideas.</p>
<h3 id="referential-transparency">Referential Transparency</h3>
<p>Referential Transparency is an FP topic but is also very relevant to types and crucially important to the discussion of “type honesty”.</p>
<p>A function is referentially transparent if it does the same thing every time it is called. Referential transparency comes with clear type signatures. The output needs to be a function of the inputs and of nothing else. You can do things like curry or partially apply, but you cannot say, retrieve the current time and act on it (that time parameter would need to be provided as input).<br />
The above <code>program:() =&gt; void</code> would be referentially transparent only if it did not do anything, just returned.<br />
IMO well written programs identify and separate the referentially transparent parts.</p>
<p>In TS, referential transparency is a coding convention. I will use <em>React.js</em> example to demonstrate this. Readers not familiar with React should think about creating a function from some model (<code>Person</code> in this example) to an actual part of the HTML DOM. Here is my example of a vanilla React component type (I like React to be vanilla as much as possible)</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="kw">const</span> PersonCard<span class="op">:</span> ({ model<span class="op">,</span> onChange }<span class="op">:</span> {</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a>    <span class="dt">model</span><span class="op">:</span> Person<span class="op">;</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a>    <span class="dt">onChange</span><span class="op">:</span> (<span class="dt">_</span><span class="op">:</span> Person) <span class="kw">=&gt;</span> <span class="kw">void</span><span class="op">;</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a>}) <span class="kw">=&gt;</span> JSX<span class="op">.</span><span class="at">Element</span></span></code></pre></div>
<p>Hopefully, the implementation does not use any hooks, it only uses the parameters (I call them setters and getters) to create bits of HTML with event handlers. This would be an example of a referentially transparent React type. It also would be an example of a very explicit type that is very “honest”.</p>
<p> <div class="side-note"><strong>FP side notes:</strong> Such approach is not novel at all (e.g. Elm uses a similar approach, only not as a coding style but as its architecture).<br />
Lenses can be used as just a coding convention too.  </div></p>
<p>Many developers will very much disagree with me on this. E.g. many will prefer to encapsulate state handling inside components. I do not intend to argue which approach is better. I will just point out that encapsulation is secretive in the type definition and I am looking for transparency. Many parts of React will require some use of hooks, my approach is to do that only when I have to, not when I want to. The goal is to make things very type-explicit. It is an IMO.</p>
<p>Such type is also self documenting.</p>
<p><strong>Expanding on my point 4:</strong> IMO, the best communication tools for developers and the best documenting tools for the code, in that order, are: <em>types and tests</em>. I will only focus on the first.</p>
<h3 id="types-as-documentation">Types as documentation</h3>
<p>When I write TS, I want my types to be very informative. For example, compare these two slightly modified versions of the above React component:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="kw">const</span> PersonCard<span class="op">:</span> React<span class="op">.</span><span class="at">FC</span><span class="op">&lt;</span>{</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a>    <span class="dt">model</span><span class="op">:</span> Person<span class="op">;</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a>    <span class="dt">onChange</span><span class="op">:</span> (<span class="dt">_</span><span class="op">:</span> Person) <span class="kw">=&gt;</span> <span class="kw">void</span><span class="op">;</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a>}<span class="op">&gt;</span></span></code></pre></div>
<p>vs:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="kw">const</span> PersonCard<span class="op">:</span> React<span class="op">.</span><span class="at">FC</span><span class="op">&lt;</span>Props<span class="op">&gt;</span> <span class="co">//Commonly used 'Props' type alias defined next to 'PersonCard'</span></span></code></pre></div>
<p>I like the first one better.<br />
And, I am not suggesting the names for the setters and getters here. I would be equally happy with this:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a><span class="kw">const</span> PersonCard<span class="op">:</span> React<span class="op">.</span><span class="at">FC</span><span class="op">&lt;</span>{</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a>    <span class="dt">get</span><span class="op">:</span> Person<span class="op">;</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a>    <span class="dt">set</span><span class="op">:</span> (<span class="dt">_</span><span class="op">:</span> Person) <span class="kw">=&gt;</span> <span class="kw">void</span><span class="op">;</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true"></a>}<span class="op">&gt;</span></span></code></pre></div>
<p>My focus is on types, not values. There is no safety benefit in doing this. Communication, documentation and accessibility are the only goals.<br />
In a modernized interpretation of the KISS principle I think of “Simple” as a lot of very transparent types.</p>
<h2 id="next-chapter">Next Chapter</h2>
<p>There are parts of TS that I absolutely adore and I will talk about them. The complexity of TS types is another big topic to discuss. Complexity causes compilation issues (we will encounter some new bloopers) and makes the language hard to use. <del>This will take me a few weeks to finish.</del><br />
Here is the link: <a href="2022-01-03-ts-types-part3.html" target="_blank">Part 3</a>.</p>
<p>I am working on these notes during the 2021 holiday season. <em>Merry Christmas, Happy New Year!</em> Stay happy and healthy!</p>

    </section>
</article>
]]></description>
    <pubDate>Fri, 24 Dec 2021 00:00:00 UT</pubDate>
    <guid>https://rpeszek.github.io//posts/2021-12-24-ts-types-part2.html</guid>
    <dc:creator>Robert Peszek</dc:creator>
</item>
<item>
    <title>Type Enthusiast's Notes about TypeScript. Part 1. Typing in Anger</title>
    <link>https://rpeszek.github.io//posts/2021-12-12-ts-types-part1.html</link>
    <description><![CDATA[<article>
    <section class="header">
        Posted on December 12, 2021
        
            by Robert Peszek
        
        
        
        <div class="changelog"> <div>Revision History: <ul> <li> (2021.12.24) modified historical note about office.js. Linked Part 2. Planned future content adjustment.</li> <li> (2021.12.26) <a href="#fn1">footnote [1]</a> <li> (2022.01.03) Linked Part 3. </ul> </div></div>
        
        
        <div class="info">Tags: <a title="All pages tagged 'TypeScript-Notes'." href="../tags/TypeScript-Notes.html">TypeScript-Notes</a></div>
        
    </section>
    <section>

    </section>
    <section>
        <div class="toc"><div class="header">Table of Contents</div>
<ul>
<li><a href="#introduction-to-the-series">Introduction to the series</a></li>
<li><a href="#typescript-is-great">TypeScript is great!</a></li>
<li><a href="#office.js.-using-ts-in-anger"><em>office.js</em>. Using TS in anger</a>
<ul>
<li><a href="#happy-path">Happy path</a></li>
<li><a href="#bumps-on-the-path">Bumps on the path</a></li>
<li><a href="#bump-leveling-tools">Bump leveling tools</a></li>
<li><a href="#compilation-bloopers">Compilation bloopers</a></li>
<li><a href="#its-all-worth-it">It’s all worth it</a></li>
</ul></li>
<li><a href="#next-chapter">Next Chapter</a></li>
</ul>
</div>
<p><em>Please Leave Feedback in: <a href="https://github.com/rpeszek/rpeszek.github.io/discussions/1" target="_blank">git discussions</a></em></p>
<p><strong>DRAFT version</strong> <em>(I am sorry about any misprints. It seems I have goblins in my laptop that toy with me, remove or change words. When this note disappears, you will know that I gave up.)</em></p>
<p><strong>Disclaimers:</strong> (imagine this is a very small font, read it very fast in a half whisper)<br />
<em>I assume strict compiler flags are on, something you get by default with scaffolding, e.g. using <code>create-react-app my-project --template typescript</code> is close enough.<br />
The code examples have been tested with TypeScript v4.4.4 and v4.5.2.<br />
office.js examples are based on https://appsforoffice.microsoft.com/lib/1.1/hosted/office.js and <span class="citation" data-cites="types/office-js">@types/office-js</span><span class="citation" data-cites="1.0.221">@1.0.221</span> (these match the current scaffold for office.js/React).<br />
This post is a pandoc output of a markdown document and code examples are not interactive.<br />
Most of the code examples are published in <a href="https://github.com/rpeszek/ts-experiments/tree/master/ts-notes" target="_blank">ts-notes</a> folder in this github repo: <a href="https://github.com/rpeszek/ts-experiments" target="_blank">ts-experiments</a>.</em></p>
<h2 id="introduction-to-the-series">Introduction to the series</h2>
<blockquote>
<p>“TypeScript began its life as an attempt to bring traditional object-oriented types to JavaScript so that the programmers at Microsoft could bring traditional object-oriented programs to the web. As it has developed, TypeScript’s type system has evolved to model code written by native JavaScripters. The resulting system is <em>powerful, interesting and messy.</em>”</p>
</blockquote>
<p><em>From typescriptlang <a href="https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html" target="_blank">TypeScript for Functional Programmers</a></em></p>
<p>I wanted to write a short post about my experience with TS types, I ended up with a draft the size of a short book. I decided to split it into digestible installments and publish it as a series of shorter posts. The series will be about the <em>powerful, interesting and messy</em> types in TS. This post is the first in that series.</p>
<p>Here is my plan:</p>
<ul>
<li>Part 1 (this post). Is a warm-up. Part 1 has been motivated by a current project at my work that uses TS. I will show code examples that are hard to compile. I will discuss strategies and methods for resolving compilation issues. Part 1 will present code examples that compile but really, really should not, and code examples that should compile but surprisingly don’t. I will also summarize my overall experience of working with TS.<br />
This series needed a JS library with TS bindings to draw examples from, I decided to use <em>office.js</em> and Part 1 will introduce it.</li>
<li><a href="2021-12-24-ts-types-part2.html" target="_blank">Part 2</a>. Will be about keeping types honest. Are runtime values consistent with the types? We hope they always are but, especially in a gradually typed language like TS, types will sometimes lie. We will see concrete examples of type dishonesty from <em>office.js</em>. Part 2 will cover the notorious <code>any</code> and its safer cousin <code>unknown</code>, the type coercion (casting), and TS’s type guards. I will also discuss (or rather rant about) coding conventions for transparent, self documenting types.</li>
<li><a href="2022-01-03-ts-types-part3.html" target="_blank">Part 3</a>. Will cover some of the TS type safety features that I absolutely love. Throughout the series, we will encounter several examples where TS compiler does not work as expected. One of my notes will argue that what TS is and does it quite complex.</li>
<li>Part 4, Part 5. Will be more theoretical. Notes in Parts 4-5 will discuss topics such as TS’s structural, recursive types, subtyping, phantom types, type variable scoping, higher-rank polymorphism (TS supports a version of it!), and type level programming.</li>
<li>Part 6. Will be a wrap-up with some final thoughts.</li>
</ul>
<p><strong>Why am I writing these notes?</strong><br />
To be honest, it is because I am really impressed and excited about some of the type safety features in TS.</p>
<p>Despite being a superset of JavaScript, TS stands out among mainstream languages as one that supports some interesting types.<br />
There is a tiny but important feedback loop: the more we play with types the more they will end up being used.<br />
So, to be perfectly honest, the goal of these notes is to simply play with some interesting types and see how the compiler reacts.</p>
<p>IMO, to master something is to understand its limitations.<br />
So, to be brutally honest, the goal of these notes is to explore and handle the TS compiler limitations.</p>
<p>These notes will focus on the experience of using types. Not so much on explaining the types themselves.</p>
<p><strong>Target audience and prerequisites.</strong> I assume that the reader is interested in types and either uses or considers using TypeScript.<br />
Types tend to be related to FP. There will not be much FP in these notes. However, I will use some basic functional programming concepts, like currying, without explaining them.<br />
TypeScript is a superset of JavaScript with type syntax very similar to any other C-like language. These notes will probably be hard to read without some experience with JavaScript or ability to read C-like types.</p>
<p><strong>About the author.</strong> I am spearheading a rewrite of a legacy front-end component at work, the goal is to rewrite it using the new React.js and TypeScript. In recent years, I have been spending all of my time in the back-end designing, writing, and maintaining Haskell programs. Haskell code has a lot of types. Thus, I use types a lot. Types allow me to code faster, safer, and with much more confidence.<br />
I wear a hat with types on it when writing TS.<br />
I love Programming Language Theory and have some experience and lots of interest in all things compiler related.<br />
I wear a very thin headband with PLT symbols on it under my hat (should be mostly invisible in this series).<br />
All of this gives me a different (compared to most typescripters) perspective and a reason to write these posts. For some readers, parts of these posts will feel strange. Established practices like overloading will be considered a bad thing, writing experimental code (that won’t even run) to answer <em>type questions</em> will be a good thing. Strange is a corollary of different.</p>
<p><strong>What is TypeScript for?</strong> Is it just a JavaScript add-on used to prevent typos and trivial code errors?<br />
Or, will TypeScript more fundamentally change the way the code is written?<br />
Please have these questions in mind when reading these notes.</p>
<p>We will cover a lot of topics.</p>
<blockquote>
<p>“And we never say anything unless it is worth taking a long time to say.”</p>
</blockquote>
<p><em>J.R.R Tolkien and Treebeard about discussing types in TypeScript</em></p>
<h2 id="typescript-is-great">TypeScript is great!</h2>
<p>It literally took me less than one minute of playing with TS to get excited about it.<br />
Just look at the union types (using a somewhat contrived example):</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>type Person <span class="op">=</span> {<span class="dt">firstNm</span><span class="op">:</span> string<span class="op">,</span> <span class="dt">lastNm</span><span class="op">:</span> string} </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>type NullablePerson <span class="op">=</span> Person <span class="op">|</span> <span class="kw">null</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="kw">const</span> getName <span class="op">=</span> (p<span class="op">:</span>NullablePerson)<span class="op">:</span> string <span class="kw">=&gt;</span> {</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>    <span class="co">//const tst1 = p.firstNm //does not compile</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>    <span class="cf">if</span>(p<span class="op">===</span><span class="kw">null</span>){</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>        <span class="co">//const tst2 = p.firstNm //does not compile</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>        <span class="cf">return</span> <span class="st">&quot;John Smith&quot;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>    } <span class="cf">else</span> {</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a>        <span class="cf">return</span> p<span class="op">.</span><span class="at">firstNm</span> <span class="op">+</span> <span class="st">&quot; &quot;</span> <span class="op">+</span> p<span class="op">.</span><span class="at">lastNm</span> <span class="co">//compiles</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a>    }</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a>}</span></code></pre></div>
<p>How cool!</p>
<p>Talking about my “literal” excitement, my next play example implements <code>Either</code> (I am not trying to implement my own Either type, only to play with the language):</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>type Either<span class="op">&lt;</span>A<span class="op">,</span>B<span class="op">&gt;</span> <span class="op">=</span> </span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="op">|</span> {<span class="dt">type</span><span class="op">:</span> <span class="st">&quot;left&quot;</span><span class="op">,</span> <span class="dt">content</span><span class="op">:</span> A}</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="op">|</span> {<span class="dt">type</span><span class="op">:</span> <span class="st">&quot;right&quot;</span><span class="op">,</span> <span class="dt">content</span><span class="op">:</span> B}</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a><span class="kw">const</span> x1<span class="op">:</span> Either<span class="op">&lt;</span>number<span class="op">,</span> string<span class="op">&gt;</span> <span class="op">=</span> {<span class="dt">type</span><span class="op">:</span> <span class="st">&quot;left&quot;</span><span class="op">,</span> <span class="dt">content</span><span class="op">:</span> <span class="dv">1</span>}</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a><span class="kw">const</span> xone<span class="op">:</span> Either<span class="op">&lt;</span>number<span class="op">,</span> string<span class="op">&gt;</span> <span class="op">=</span> {<span class="dt">type</span><span class="op">:</span> <span class="st">&quot;right&quot;</span><span class="op">,</span> <span class="dt">content</span><span class="op">:</span> <span class="st">&quot;one&quot;</span>}</span></code></pre></div>
<div class="sourceCode" id="cb3"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="dt">const</span> wrong: Either&lt;number, string&gt; = {type: <span class="st">&quot;left&quot;</span>, content: <span class="st">&quot;one&quot;</span>} <span class="co">// does not compile</span></span></code></pre></div>
<p>it almost looks like dependent types! TS calls these literal types. (In this example, <code>"left"</code> is a type with a single value <code>"left": "left"</code>.)<br />
TypeScript calls this programming pattern <em>Discriminated Unions</em>.</p>
<p>And, TS is serious about string property names too:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">const</span> y<span class="op">:</span> Either<span class="op">&lt;</span>number<span class="op">,</span> string<span class="op">&gt;</span> <span class="op">=</span> {<span class="st">&quot;type&quot;</span><span class="op">:</span> <span class="st">&quot;left&quot;</span><span class="op">,</span> <span class="st">&quot;content&quot;</span><span class="op">:</span> <span class="dv">1</span>}</span></code></pre></div>
<div class="sourceCode" id="cb5"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="dt">const</span> wrong: Either&lt;number, string&gt; = {<span class="st">&quot;type&quot;</span>: <span class="st">&quot;left&quot;</span>, <span class="st">&quot;content&quot;</span>: <span class="st">&quot;one&quot;</span>} <span class="co">// does not compile</span></span></code></pre></div>
<p>TypeScript <a href="https://www.npmjs.com/package/ts-pattern" target="_blank"><em>ts-pattern</em></a> library uses discriminated unions to implement <em>pattern matching</em>. Exhaustive check is part of it.<br />
Again, really cool. All of these are really exciting developments to me.</p>
<p>Continuing with play examples, here is the full JSON grammar defined in TS.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>type JsonVal <span class="op">=</span> </span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="op">|</span> {<span class="dt">type</span><span class="op">:</span> <span class="st">&quot;object&quot;</span><span class="op">,</span> <span class="dt">val</span><span class="op">:</span> <span class="bu">Map</span><span class="op">&lt;</span>string<span class="op">,</span> JsonVal<span class="op">&gt;</span>}</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a><span class="op">|</span> {<span class="dt">type</span><span class="op">:</span> <span class="st">&quot;array&quot;</span><span class="op">,</span> <span class="dt">val</span><span class="op">:</span> JsonVal[]}</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a><span class="op">|</span> {<span class="dt">type</span><span class="op">:</span> <span class="st">&quot;string&quot;</span><span class="op">,</span> <span class="dt">val</span><span class="op">:</span> string}</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a><span class="op">|</span> {<span class="dt">type</span><span class="op">:</span> <span class="st">&quot;number&quot;</span><span class="op">,</span> <span class="dt">val</span><span class="op">:</span> number}</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a><span class="op">|</span> {<span class="dt">type</span><span class="op">:</span> <span class="st">&quot;bool&quot;</span><span class="op">,</span> <span class="dt">val</span><span class="op">:</span> boolean}</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a><span class="op">|</span> {<span class="dt">type</span><span class="op">:</span> <span class="st">&quot;null&quot;</span>}</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a><span class="kw">const</span> tstj<span class="op">:</span> JsonVal <span class="op">=</span> {<span class="dt">type</span><span class="op">:</span><span class="st">&quot;array&quot;</span><span class="op">,</span> <span class="dt">val</span><span class="op">:</span>[{<span class="dt">type</span><span class="op">:</span> <span class="st">&quot;null&quot;</span>}<span class="op">,</span> {<span class="dt">type</span><span class="op">:</span> <span class="st">&quot;number&quot;</span><span class="op">,</span> <span class="dt">val</span><span class="op">:</span> <span class="dv">5</span>}]} <span class="co">//compiles</span></span></code></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="dt">const</span> wrong: JsonVal = {type: <span class="st">&quot;number&quot;</span>, val: {type: <span class="st">&quot;string&quot;</span>, val: <span class="st">&quot;5&quot;</span>}} <span class="co">//does not compile, number cannot a nested string</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="dt">const</span> wrong2: {type: <span class="st">&quot;object&quot;</span>,  val:[{type: <span class="st">&quot;null&quot;</span>}, {type: <span class="st">&quot;number&quot;</span>, val: <span class="dv">5</span>}]} <span class="co">//does not compile, object is not an array</span></span></code></pre></div>
<p>This could have been expressed with OO classes, but it would not be very easy, would it?<br />
I wrote the <code>JsonVal</code> definition without thinking, I have committed <code>Data.Aeson.Value</code> (Haskell’s commonly used type for JSON values) definition to memory and I just mimicked it. Then I looked at it again … holly … TS supports complex recursive definitions! We will discuss recursive types later in this series.</p>
<p>TypeScript has an ability to do type level programming that goes beyond the demonstrated uses of literal types. All of this is oriented toward creating type safety over various kinds of idiomatic JS code and is limited in scope. It is nonetheless interesting. We will return to this topic in the future as well.</p>
<p>As far as mainstream languages go (I consider <em>Scala</em> or <em>Reason ML</em> a border line just outside the mainstream), TypeScript could be the most interesting choice today IMO.</p>
<p>This was my trailer/preview section. If the code that excited me feels interesting to you, you may enjoy reading these notes. There will be some gory details (not a lot violence). You have to decide if type safety is your genre.<br />
Developers are divided into 2 camps: Those who use types because that is the most effective way to write software and those who do not use types because that is the most effective way to write software. Since you are still reading, I assume you are in camp 1.</p>
<h2 id="office.js.-using-ts-in-anger"><em>office.js</em>. Using TS in anger</h2>
<p>I will use <em>office.js</em> library as a source of examples for this series. It is a Microsoft product (like TypeScript). It comes with TypeScript type definitions (this series uses <span class="citation" data-cites="types/office-js">@types/office-js</span><span class="citation" data-cites="1.0.221">@1.0.221</span>).<br />
Looking into the <em>office.js</em> revision history suggests that the bond between <em>office.js</em> and TypeScript developed very early. It almost looks like these projects grew up together. <em>office.js</em> seems like a good ‘comprehensive’ example for examining the benefits (and frustrations) of using TS in anger.<br />
Despite some hardships, TS makes working with office.js much, much easier!</p>
<p>As the name suggests, <em>office.js</em> provides an API for working with <em>Microsoft Office</em>. It allows implementing custom apps that work inside the office suite of products (Microsoft calls these apps add-ins).<br />
This is not an office.js tutorial but, I hope, the code should be clear to follow.</p>
<p>As a working example, we will play with code that extracts data from an email opened in Outlook. To start, I want to extract the email body.<br />
To access data, <em>office.js</em> often uses an old style <code>getAsync</code> methods that I will modernize using a custom conversion to a <code>Promise</code>. Node’s <code>util.promisify</code> will not work well for this task. This is how this could be done in TS:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="co">/* Utility to convert office functions to promises */</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="im">export</span> <span class="kw">const</span> officePromise <span class="op">=</span> <span class="op">&lt;</span>T<span class="op">&gt;</span> (getasync<span class="op">:</span> (fx<span class="op">:</span> (r<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncResult</span><span class="op">&lt;</span>T<span class="op">&gt;</span>) <span class="kw">=&gt;</span> <span class="kw">void</span>) <span class="kw">=&gt;</span> <span class="kw">void</span>)<span class="op">:</span> <span class="bu">Promise</span><span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="kw">=&gt;</span> {</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>    <span class="cf">return</span> <span class="kw">new</span> <span class="bu">Promise</span>((resolve<span class="op">,</span> reject) <span class="kw">=&gt;</span> {</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>      <span class="fu">getasync</span>((<span class="dt">res</span><span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncResult</span><span class="op">&lt;</span>T<span class="op">&gt;</span>) <span class="kw">=&gt;</span> {</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>        <span class="cf">if</span>(res<span class="op">.</span><span class="at">status</span><span class="op">===</span>Office<span class="op">.</span><span class="at">AsyncResultStatus</span><span class="op">.</span><span class="at">Succeeded</span>){</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>          <span class="fu">resolve</span>(res<span class="op">.</span><span class="at">value</span>)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a>      } <span class="cf">else</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a>          <span class="fu">reject</span>(res<span class="op">.</span><span class="at">error</span>)</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a>      })</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a>   })</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a>  }</span></code></pre></div>
<p> <div class="side-note"><strong>Side Note</strong><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>: Here is my first criticism of TS. The ergonomics of function type definitions is IMO really poor. These definitions are hard to read and cumbersome to write. This syntax does not scale well to more involved types and makes reasoning about types harder.<br />
E.g. in the above example parameters <code>fx:</code> and <code>r:</code> cannot be used anywhere (are outside of the lexical scope) and serve only a documentation purpose. This simple example needs 6 parentheses. The use of <code>:</code> and <code>=&gt;</code> is confusing. Function form <code>A</code> to <code>B</code> is (depending where in the declaration) either <code>(a: A) =&gt; B</code> or <code>(a: A): B</code>. I admit it took me a long time to figure out how to write these and it still takes me forever to read some of these types.<br />
Later in this post, I will show some work-arounds that simplify type definitions like this one.<br />
I am adding a big fat <strong>IMO</strong> to this side note, readability is in the eye of … well the reader. But seriously…<br />
 </div></p>
<p>Properly initialized office add-in will have access to <code>Office.context.mailbox.item: Office.MessageRead</code>.<br />
This <code>item</code> object allows access to the email data. (The situation is just slightly more complicated since the <code>item</code> property is overloaded but that is not important for now.) To retrieve the email body I need to use <code>item.body.getAsync</code>. But wait, the type for that version of <code>getAsync</code> accepts not only a callback function but also a “body type” parameter.</p>
<p>I am going to resist the temptation to overload <code>officePromise</code>. Instead I will move in a direction that is more fundamental.</p>
<p>Assume that we want ‘html’ body format, the code can look something like this:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="co">//retrieving email body, 1st attempt</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a><span class="kw">const</span> bodyType <span class="op">=</span> Office<span class="op">.</span><span class="at">CoercionType</span><span class="op">.</span><span class="at">Html</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a> </span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a><span class="kw">const</span> partiallyAppliedBodyFn <span class="op">=</span> (fn<span class="op">:</span> ((res<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncResult</span><span class="op">&lt;</span>string<span class="op">&gt;</span>) <span class="kw">=&gt;</span> <span class="kw">void</span>)) <span class="kw">=&gt;</span> </span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>     item<span class="op">.</span><span class="at">body</span><span class="op">.</span><span class="fu">getAsync</span>(bodyType<span class="op">,</span> fn) </span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>  </span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a><span class="kw">const</span> body  <span class="op">=</span> <span class="cf">await</span> officePromise<span class="op">&lt;</span>string<span class="op">&gt;</span> (partiallyAppliedBodyFn) <span class="co">// body: string</span></span></code></pre></div>
<p>I had to fully specify the <code>partiallyAppliedBodyFn</code> type for this to work. That looks like a lot of code to just partially apply <code>item.body.getAsync</code>!</p>
<h3 id="happy-path">Happy path</h3>
<p>There are some libraries that offer a <code>curry</code> function conversion, but these are typically JS not TS. So I wrote it myself (again, note the type signature is somewhat hard to read):</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="im">export</span> <span class="kw">const</span> curry <span class="op">=</span> <span class="op">&lt;</span>T1<span class="op">,</span> T2<span class="op">,</span> R<span class="op">&gt;</span> (fn<span class="op">:</span> (ax<span class="op">:</span> T1<span class="op">,</span> bx<span class="op">:</span> T2) <span class="kw">=&gt;</span> R)<span class="op">:</span> (a<span class="op">:</span> T1) <span class="kw">=&gt;</span> (b<span class="op">:</span> T2) <span class="kw">=&gt;</span> R <span class="kw">=&gt;</span> {</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>    <span class="kw">const</span> res <span class="op">=</span> (<span class="dt">a</span><span class="op">:</span> T1) <span class="kw">=&gt;</span> (<span class="dt">b</span><span class="op">:</span> T2) <span class="kw">=&gt;</span> <span class="fu">fn</span>(a<span class="op">,</span> b)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>    <span class="cf">return</span> res</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a> }</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a><span class="kw">const</span> addtst <span class="op">=</span> (a<span class="op">:</span>number<span class="op">,</span> b<span class="op">:</span> number) <span class="kw">=&gt;</span> a <span class="op">+</span> b</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a><span class="kw">const</span> curriedAdd <span class="op">=</span> <span class="fu">curry</span>(addtst) <span class="co">//const curriedAdd: (a: number) =&gt; (b: number) =&gt; number</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a><span class="kw">const</span> tst <span class="op">=</span> <span class="fu">curry</span>(addtst)(<span class="dv">1</span>) <span class="co">//const tst: (b: number) =&gt; number</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a><span class="kw">const</span> tst2 <span class="op">=</span> <span class="fu">curry</span>(addtst)(<span class="dv">1</span>)(<span class="dv">2</span>) <span class="co">//tst2 = 3</span></span></code></pre></div>
<p>And I have a much simpler code that compiles right off the bat:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="co">//Happy path one liner to get email body</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a><span class="co">//body2: string</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a><span class="kw">const</span> body2 <span class="op">=</span> <span class="cf">await</span> <span class="fu">officePromise</span> (<span class="fu">curry</span>(item<span class="op">.</span><span class="at">body</span><span class="op">.</span><span class="at">getAsync</span>)(Office<span class="op">.</span><span class="at">CoercionType</span><span class="op">.</span><span class="at">Html</span>)) </span></code></pre></div>
<p>This worked out quite well and the type checker was able to infer the types!<br />
This ended up being a happy path.</p>
<h3 id="bumps-on-the-path">Bumps on the path</h3>
<p>In practice, the type checker will often need some help. Even more often, the programmer (me) will need help figuring why the code is not compiling.</p>
<p>For example, <code>item.body.getAsync</code> offers a 3 parameter overload which accepts additional <code>Office.AsyncContextOptions</code>. Using it is much harder. (I will not delve into what the extra argument is for, I just want to see if my code will compile with 3 parameters)</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="co">//boilerplate 'curry3' implementation is not shown (available in the linked github project), </span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a><span class="co">//it is almost identical to `curry` but accepts a 3 parameter function  </span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a><span class="co">//trying to pass extra parameter to body.getAsync</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a><span class="kw">const</span> emptyConfig<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncContextOptions</span> <span class="op">=</span> {}</span></code></pre></div>
<div class="sourceCode" id="cb13"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="co">//body3 does not compile: &quot;Argument of type 'AsyncContextOptions' is not assignable to parameter of type '(asyncResult: AsyncResult&lt;string&gt;) =&gt; void'.&quot; </span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a><span class="dt">const</span> body3  = await <span class="fu">officePromise</span> (<span class="fu">curry3</span>(item.<span class="fu">body</span>.<span class="fu">getAsync</span>)(Office.<span class="fu">CoercionType</span>.<span class="fu">Html</span>)(emptyConfig)) </span></code></pre></div>
<p>To understand what is happening, I sometimes need to spend time annotating things, or picking up the exact overload I want. E.g.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="kw">const</span> useThisAsync <span class="op">=</span> (coercionType<span class="op">:</span> Office<span class="op">.</span><span class="at">CoercionType</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>                     <span class="op">,</span> options<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncContextOptions</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>                     <span class="op">,</span> callback<span class="op">:</span> (asyncResult<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncResult</span><span class="op">&lt;</span>string<span class="op">&gt;</span>) <span class="kw">=&gt;</span> <span class="kw">void</span>)<span class="op">:</span> <span class="kw">void</span> <span class="kw">=&gt;</span> {</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a>      item<span class="op">.</span><span class="at">body</span><span class="op">.</span><span class="fu">getAsync</span>(coercionType<span class="op">,</span> options<span class="op">,</span> callback)</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>    }</span></code></pre></div>
<p>This can be tedious, but it typically gets the job done. In this particular case, using <code>curry3(useThisAsync)</code> fixes the <code>body3</code> (or the “3 body”, I just had to pun this) problem. So, the issue with <code>body3</code> code appears to be related to overloading.</p>
<p>Looking closer at the types, I notice that not only <code>item.body.getAsync</code> has two overloads, but the one I want is accepting a union type argument and the callback is optional:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="co">//from office.js documentation</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a><span class="co">//2 parameter overload used in happy path</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a><span class="fu">getAsync</span>(coercionType<span class="op">:</span> Office<span class="op">.</span><span class="at">CoercionType</span> <span class="op">|</span> string</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a>  <span class="op">,</span> callback<span class="op">?:</span> (asyncResult<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncResult</span><span class="op">&lt;</span>string<span class="op">&gt;</span>) <span class="kw">=&gt;</span> <span class="kw">void</span>)<span class="op">:</span> <span class="kw">void</span><span class="op">;</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true"></a><span class="co">//3 parameter overload we are trying to use now</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true"></a><span class="fu">getAsync</span>(coercionType<span class="op">:</span> Office<span class="op">.</span><span class="at">CoercionType</span> <span class="op">|</span> string<span class="op">,</span> </span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true"></a>        options<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncContextOptions</span><span class="op">,</span> </span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true"></a>        callback<span class="op">?:</span> (asyncResult<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncResult</span><span class="op">&lt;</span>string<span class="op">&gt;</span>) <span class="kw">=&gt;</span> <span class="kw">void</span>)<span class="op">:</span> <span class="kw">void</span><span class="op">;</span></span></code></pre></div>
<p>So there are sort of <em>overloads on top of overloads</em> and the type checker probably gets confused.<br />
The compilation error suggests that the compiler gets stuck on a wrong (the 2 parameter) version of <code>getAsync</code> despite the use of the 3 parameter <code>curry3</code>. I will also confirm this hypothesis using a <em>type hole</em> (we will learn what that is) in the next section.<br />
I expect the type checker to backtrack and try the next overload, but for some reason it does not want to do that on its own.<br />
I do not blame TS, overloading gives me a headache too.<br />
Overloading is known for being not type inference friendly (incidentally, that is the reason why Haskell does not overload names).</p>
<p> <div class="side-note"><strong>Side note:</strong> Acting on my hypothesis of what is wrong with <code>body3</code>, I can push this code to a ridiculous limit:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="co">//this compiles by using a wrong input parameter type and returns 'unknown'</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a><span class="kw">const</span> crazyConfig <span class="op">:</span> (_<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncResult</span><span class="op">&lt;</span>string<span class="op">&gt;</span>) <span class="kw">=&gt;</span> <span class="kw">void</span> <span class="op">=</span> x <span class="kw">=&gt;</span> <span class="st">&quot;&quot;</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a><span class="kw">const</span> body4 <span class="op">=</span> <span class="cf">await</span> <span class="fu">officePromise</span> (<span class="fu">curry3</span>(item<span class="op">.</span><span class="at">body</span><span class="op">.</span><span class="at">getAsync</span>)(Office<span class="op">.</span><span class="at">CoercionType</span><span class="op">.</span><span class="at">Html</span>)(crazyConfig)) </span></code></pre></div>
<p>Besides this being completely wrong, I do not understand what causes the widening of <code>body4</code> type to <code>unknown</code>. There is enough information in the overloaded <code>item.body.getAsync</code> method for the type checker to infer the <code>string</code>. My guesswork is too hypothetical to discuss it here.<br />
Especially for the return types, any widening to <code>unknown</code> would IMO be better served as a compilation error. We want these to be narrow, not wide. I will show more examples of such widening and I will discuss safety concerns related to the <code>unknown</code> type in future notes.<br />
 </div></p>
<p>There is something worryingly asymmetric about a 2 parameter overload compiling without additional help and a 3 parameter overload needing a developer intervention. Should I worry that a future version of TS will flip this preference and all of my code that uses the 2 parameter overload will stop compiling? How stable is this arbitrary complexity?</p>
<p><em>If you are an API owner, my advice is to not overload. IntelliSense works better, type inference works better, developer head hurts less without overloads.</em></p>
<p>One type that is notorious for needing annotations is the TypeScript’s <em>tuple</em>. Typescript overloads array syntax <code>[]</code> to define tuples (some readers may prefer the term heterogeneous lists). This is an example of a tuple: <code>[2,"two"]: [number, string]</code>. The syntax overloading probably does not help TS in inferring the type and the type checker often gives up or infers the array type.</p>
<p>I am concerned that <strong>many developers will give up</strong> trying to write this type of code. My concern is also that developers will resort to unsafe type coercion / type casting. There will be a lot of <code>myvar as IWantIt</code>, or a lot of the <code>any</code> type.</p>
<p>Was this enough gore for you? You say it was not? I say you did not see the content of that email!</p>
<h3 id="bump-leveling-tools">Bump leveling tools</h3>
<h4 id="readable-type-definitions">Readable Type Definitions</h4>
<p>Cumbersome type annotations are not a good excuse to give up! There is a way to simplify function type definitions. For example, I can define a helper alias:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="co">//DIY reusable type for Office getAsync callbacks</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a><span class="im">export</span> type OfficeCallack<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">=</span> (_<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncResult</span><span class="op">&lt;</span>T<span class="op">&gt;</span>) <span class="kw">=&gt;</span> <span class="kw">void</span></span></code></pre></div>
<p>Here is how this simplifies the previously defined <code>partiallyAppliedBodyFn</code>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="co">//before:</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a><span class="kw">const</span> partiallyAppliedBodyFn1 <span class="op">=</span> (fn<span class="op">:</span> ((res<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncResult</span><span class="op">&lt;</span>string<span class="op">&gt;</span>) <span class="kw">=&gt;</span> <span class="kw">void</span>)) <span class="kw">=&gt;</span> item<span class="op">.</span><span class="at">body</span><span class="op">.</span><span class="fu">getAsync</span>(Office<span class="op">.</span><span class="at">CoercionType</span><span class="op">.</span><span class="at">Html</span><span class="op">,</span> fn) </span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a><span class="co">//after:</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a><span class="kw">const</span> partiallyAppliedBodyFn2 <span class="op">=</span> (fn<span class="op">:</span> OfficeCallack<span class="op">&lt;</span>string<span class="op">&gt;</span>) <span class="kw">=&gt;</span> item<span class="op">.</span><span class="at">body</span><span class="op">.</span><span class="fu">getAsync</span>(Office<span class="op">.</span><span class="at">CoercionType</span><span class="op">.</span><span class="at">Html</span><span class="op">,</span> fn)</span></code></pre></div>
<p>Notice <strong>no more redundant parameter definitions</strong> in the type signature and a much easier to read syntax.<br />
The next version is <strong>my personal preference</strong> (it nicely separates the type and the implementation):</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="kw">const</span> partiallyAppliedBodyFn3<span class="op">:</span> (_<span class="op">:</span> OfficeCallack<span class="op">&lt;</span>string<span class="op">&gt;</span>) <span class="kw">=&gt;</span> <span class="kw">void</span> <span class="op">=</span> </span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a>  fn <span class="kw">=&gt;</span> item<span class="op">.</span><span class="at">body</span><span class="op">.</span><span class="fu">getAsync</span>(Office<span class="op">.</span><span class="at">CoercionType</span><span class="op">.</span><span class="at">Html</span><span class="op">,</span> fn)</span></code></pre></div>
<h4 id="type-application">Type Application</h4>
<p>Returning to my failed <code>body3</code> example, instead of trying to type annotate with full type signatures, it is sometimes more convenient to apply the types. Here, I have the “generic” (or polymorphic) <code>curry3</code> function that I can apply the types <code>CoercionType</code>, <code>AsyncContextOptions</code>, <code>OfficeCallack&lt;string&gt;</code>, and <code>void</code> to:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="co">//type applied version, it just compiles!</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a><span class="kw">const</span> emptyConfig<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncContextOptions</span> <span class="op">=</span> {}</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a><span class="kw">const</span> body3  <span class="op">=</span> <span class="cf">await</span> officePromise<span class="op">&lt;</span>string<span class="op">&gt;</span> (</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a>  curry3<span class="op">&lt;</span>Office<span class="op">.</span><span class="at">CoercionType</span><span class="op">,</span> Office<span class="op">.</span><span class="at">AsyncContextOptions</span><span class="op">,</span> OfficeCallack<span class="op">&lt;</span>string<span class="op">&gt;,</span> <span class="kw">void</span><span class="op">&gt;</span> <span class="co">//explicity specified type parameters</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a>     (item<span class="op">.</span><span class="at">body</span><span class="op">.</span><span class="at">getAsync</span>)</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true"></a>     (Office<span class="op">.</span><span class="at">CoercionType</span><span class="op">.</span><span class="at">Html</span>)</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true"></a>     (emptyConfig)</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true"></a>  ) </span></code></pre></div>
<p>That is so much easier than specifying the exact <code>useThisAsync</code> overload!</p>
<h4 id="type-holes">Type Holes</h4>
<p>A DIY type hole technique is sometimes useful to help figure out stubborn types (see <a href="https://dev.to/gcanti/type-holes-in-typescript-2lck" target="_blank">Type holes in TS</a>).</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="co">//genric (why not say polymorphic) bottom function will allow me to ask type questions</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a><span class="im">export</span> <span class="kw">const</span> _ <span class="op">=</span> <span class="op">&lt;</span>T<span class="op">&gt;</span>()<span class="op">:</span> T <span class="kw">=&gt;</span> {</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a>    <span class="cf">throw</span> <span class="kw">new</span> <span class="bu">Error</span>(<span class="st">&quot;hole&quot;</span>)<span class="op">;</span> </span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a>}</span></code></pre></div>
<p>A type hole allows me to ask the compiler <em>type questions</em>.<br />
You can learn a lot about how the type checker works using it. E.g. using my <code>Either</code> type as an example:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="kw">const</span> tstnum<span class="op">:</span> Either<span class="op">&lt;</span>number<span class="op">,</span> string<span class="op">&gt;</span> <span class="op">=</span> {<span class="dt">type</span><span class="op">:</span> <span class="st">&quot;left&quot;</span><span class="op">,</span> <span class="dt">content</span><span class="op">:</span> <span class="fu">_</span>()}</span></code></pre></div>
<p>if you hover over <code>_</code> you will see</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a>(alias) _<span class="op">&lt;</span>number<span class="op">&gt;</span>()<span class="op">:</span> number</span></code></pre></div>
<p>Nice! If you hover over <code>_</code> in this expression</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="kw">const</span> str <span class="op">=</span> <span class="st">&quot;Hello &quot;</span> <span class="op">+</span> <span class="fu">_</span>()</span></code></pre></div>
<p>you will see</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a>(alias) _<span class="op">&lt;</span>unknown<span class="op">&gt;</span>()<span class="op">:</span> unknown</span></code></pre></div>
<p>This can provide a lot of insight into types and how TS uses them!</p>
<p>I have not been very lucky in using type holes to figure out why TS is confused. Returning to my failed <code>body3</code> example:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a><span class="co">//body3 inferred type is 'unknown'</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a><span class="kw">const</span> body3  <span class="op">=</span> <span class="cf">await</span> <span class="fu">officePromise</span> (<span class="fu">curry3</span> (item<span class="op">.</span><span class="at">body</span><span class="op">.</span><span class="at">getAsync</span>)(Office<span class="op">.</span><span class="at">CoercionType</span><span class="op">.</span><span class="at">Html</span>)(<span class="fu">_</span>())) </span></code></pre></div>
<p>if I hover over the <code>_</code> function, the IntelliSense suggests this completely wrong type:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a>(alias) _<span class="op">&lt;</span>((asyncResult<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncResult</span><span class="op">&lt;</span>string<span class="op">&gt;</span>) <span class="kw">=&gt;</span> <span class="kw">void</span>) <span class="op">|</span> <span class="kw">undefined</span><span class="op">&gt;</span>()<span class="op">:</span> ((asyncResult<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncResult</span><span class="op">&lt;</span>string<span class="op">&gt;</span>) <span class="kw">=&gt;</span> <span class="kw">void</span>) <span class="op">|</span> <span class="kw">undefined</span></span></code></pre></div>
<p>The type hole confirms that the compiler is trying to match against the two parameter overload of <code>item.body.getAsync</code>. This verifies my hypothesis from the last section. There are a few things to note here:</p>
<ul>
<li>We are asking TS “why are you confused?” and that is a funny question.</li>
<li>This type hole did not tell us more than the compilation error message itself. However, the type hole is more targeted so it could reveal more specific information in some cases.</li>
<li>Type holes may tell us something useful in situations where the code compiles but we do not understand why.</li>
</ul>
<p>If, as before, I add the type application (<code>&lt;Office.CoercionType, Office.AsyncContextOptions, OfficeCallack&lt;string&gt;, void&gt;</code>) to <code>curry3</code> the <code>_()</code> will show the type correctly:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a>(alias) _<span class="op">&lt;</span>Office<span class="op">.</span><span class="at">AsyncContextOptions</span><span class="op">&gt;</span>()<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncContextOptions</span></span></code></pre></div>
<p><strong>Unfortunate limitation</strong><br />
Sadly, the <code>_&lt;T&gt;(): T</code> is not universally useful, e.g. this will not compile:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a><span class="co">//compilation error: </span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true"></a><span class="co">//       Argument of type '(ax: never, bx: never) =&gt; never' is not assignable </span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true"></a><span class="co">//       to parameter of type '(ax: unknown, bx: unknown) =&gt; unknown'.</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true"></a><span class="dt">const</span> testfn = <span class="fu">curry</span>(_()) </span></code></pre></div>
<div class="sourceCode" id="cb30"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a><span class="co">//interestingly the following compiles as curry&lt;unknown, unknown, unknown&gt;</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true"></a><span class="kw">const</span> testfn <span class="op">=</span> <span class="fu">curry</span>({} <span class="im">as</span> any)</span></code></pre></div>
<p>This looks to me like growing pains, it should work, and probably will in future versions of TS. It is an example of code that really should compile but it does not.</p>
<p>There is an interesting relationship between the <code>never</code> type and <code>_&lt;T&gt;(): T</code>. There will be a future note about it.<br />
The type hole <code>_</code> function is a useful tool and we will keep using it in future type explorations.</p>
<p>Using types requires some experience, knowledge, and patience. More advanced types come with more misleading error messages, it takes experience to find the underlying cause of a misleading compilation error, and that is true in any language. Eventually, I (and you) will look at a TS compilation error and will say “ah, you really meant this: …”.</p>
<p>I am mostly left to my own devices when working with more involved types in TS. Hopefully the future will bring us mainstream grade interactive tools that allow asking type questions, browsing types, help solving type puzzles. For now it is mostly the programmer who connects the dots.<br />
The good news is that this gets easier and easier with practice. I have been working in TS for only about 2 months now and I already see a difference.</p>
<p><em>Good code requires two type checkers: TypeScript and You</em></p>
<h3 id="compilation-bloopers">Compilation bloopers</h3>
<p>We already saw “correct” programs that should have compiled but did not (E.g. <code>curry(_())</code>, <code>body3</code> example) and we will see more in the future notes. Our <code>body4</code> example compiled but was clearly wrong.<br />
This note shows other, less contrived, examples that compile but clearly should not.</p>
<p>All of these type check:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true"></a><span class="co">//annotated correct code added for reference, this code compiles</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true"></a><span class="kw">const</span> good<span class="op">:</span> (a<span class="op">:</span> Office<span class="op">.</span><span class="at">CoercionType</span>) </span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true"></a>          <span class="kw">=&gt;</span> (b<span class="op">:</span> ((asyncResult<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncResult</span><span class="op">&lt;</span>string<span class="op">&gt;</span>) <span class="kw">=&gt;</span> <span class="kw">void</span>)) </span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true"></a>          <span class="kw">=&gt;</span> <span class="kw">void</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true"></a>    <span class="op">=</span> <span class="fu">curry</span> (item<span class="op">.</span><span class="at">body</span><span class="op">.</span><span class="at">getAsync</span>)</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true"></a></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true"></a><span class="co">//compiles but it should not, compiles even with type annotation</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true"></a><span class="kw">const</span> nonsense1<span class="op">:</span> (a<span class="op">:</span> Office<span class="op">.</span><span class="at">CoercionType</span>) </span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true"></a>          <span class="kw">=&gt;</span> (b<span class="op">:</span> ((asyncResult<span class="op">:</span> Office<span class="op">.</span><span class="at">AsyncResult</span><span class="op">&lt;</span>string<span class="op">&gt;</span>) <span class="kw">=&gt;</span> <span class="kw">void</span>)) </span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true"></a>          <span class="kw">=&gt;</span> <span class="kw">void</span></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true"></a>    <span class="op">=</span> <span class="fu">curry</span> (<span class="fu">curry</span> (item<span class="op">.</span><span class="at">body</span><span class="op">.</span><span class="at">getAsync</span>)) </span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true"></a></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true"></a><span class="co">//compiles but it should not</span></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true"></a><span class="kw">const</span> nonsense2 <span class="op">=</span> <span class="fu">curry</span>(curry)</span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true"></a></span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true"></a><span class="co">//more examples in the linked github project</span></span></code></pre></div>
<p>and all, except the first one, should not.</p>
<p>I expect the type checker to be effective at rejecting nonsensical code. If a blooper happens, it should be rare, contrived code, unlikely for developers to write. My examples are somewhat surprising since higher order functions are not uncommon in JavaScript. The second example is a piece of code I accidentally wrote in my project.<br />
This is very concerning since errors like these are likely to remain uncaught and become escaped bugs.</p>
<p>No compiler is perfect, but you probably noticed by now that TS compiler seems to get in trouble a lot. Compared to other programming languages I use, TS’s rate of compilation issues is much higher, the issues are more dangerous, and these bloopers are happening on more commonly used vanilla code (well… at least commonly used by me).<br />
I have no idea what the underlying issues are but I can see one general reason for this: gradual typing on top of JS is not easy. I plan to write a note about the complexity of TS types in a future post.<br />
I am sure that TS keeps improving and fixing such issues but I expect the progress to be slow.</p>
<h3 id="its-all-worth-it">It’s all worth it</h3>
<p>One common concern related to using types (especially more advanced types) is a slowdown in the development speed.<br />
There is some truth to this in general because of things like compilation times in some language environments. I cannot comment on TS compilation times for large projects, so far it is not a problem for me. In my experience, having a type checker is a huge productivity bust. In my experience, the more types the faster the development speed. That is true even with compilation bloopers.<br />
Efficiency considerations are somewhat personal so your experience may vary.</p>
<p>I rewrote some legacy code using the techniques in this section. That effort resulted in significant size reduction and an overall big improvement in readability and correctness when compared to the code I was replacing or to code in the <em>office.js</em> documentation.<br />
A lot of the improvement comes from using <code>await</code> <code>async</code> syntax sugar but converting functions to their curried form and figuring out more terse ways to type annotate also results in added clarity and significant syntactic simplification.</p>
<p>In my book, there is just no comparing TS to JS, TS is the clear winner.<br />
How does TS compare to statically type checked front-end languages that compile to JS and have capable type checkers and solid types (e.g. ReasonML, Elm, PureScript, even Haskell)? I am not in a good position to discuss this yet.<br />
Lots of projects need to stay close to JS, my project at work falls into this group. For such projects TS is the right choice IMO.</p>
<h2 id="next-chapter">Next Chapter</h2>
<p>We are not done with <em>office.js</em>. I will use it in future notes.</p>
<p>Do statically defined types reflect the actual runtime values? How to assure that they do?<br />
We will discuss these questions in the next installment. <del>I have the draft ready and I hope to publish it in a few weeks.</del><br />
Here is the link: <a href="2021-12-24-ts-types-part2.html" target="_blank">Part 2. Typing Honestly</a></p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>I rewrote the side note and improved <code>officePromise</code> type definition based on a <a href="https://www.reddit.com/r/typescript/comments/rnougu/comment/hptsnvg/?utm_source=share&amp;utm_medium=web2x&amp;context=3" target="_blank">comment</a> from <em>u/Tubthumper8</em> on reddit. (Thanks!)<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

    </section>
</article>
]]></description>
    <pubDate>Sun, 12 Dec 2021 00:00:00 UT</pubDate>
    <guid>https://rpeszek.github.io//posts/2021-12-12-ts-types-part1.html</guid>
    <dc:creator>Robert Peszek</dc:creator>
</item>
<item>
    <title>Probability Tree Diagrams. Recursion Schemes. Why Finding the Right Solution is Sometimes Hard?</title>
    <link>https://rpeszek.github.io//posts/2021-07-18-prob-tree-scheme.html</link>
    <description><![CDATA[<article>
    <section class="header">
        Posted on July 18, 2021
        
            by Robert Peszek
        
        
          <br /> Last Modified on Jul 18, 2021
        
        
        <div class="changelog"> <div>Revision History: <ul> <li> (2021.07.24-25) Fixed/Reworked `cata` examples (per <a target="_blank" href="https://www.reddit.com/r/haskell/comments/onrhtw/probability_tree_diagrams_recursion_schemes_why/h684cpr?utm_source=share&utm_medium=web2x&context=3">r/Tarmen</a>) and changed definition of example tree. </ul> </div></div>
        
        
        <div class="info">Tags: <a title="All pages tagged 'Haskell'." href="../tags/Haskell.html">Haskell</a></div>
        
    </section>
    <section>

    </section>
    <section>
        <div class="toc"><div class="header">Table of Contents</div>
<ul>
<li><a href="#the-problem">The Problem</a>
<ul>
<li><a href="#why-is-this-useful">Why is this useful?</a></li>
<li><a href="#plumbing">Plumbing</a></li>
<li><a href="#example-tree">Example Tree</a></li>
<li><a href="#traditional-solution-state-threads">Traditional Solution, State Threads</a></li>
<li><a href="#simple-recursion-schemes">Simple Recursion Schemes</a></li>
</ul></li>
<li><a href="#why-finding-the-right-solution-is-sometimes-hard">Why Finding the Right Solution is Sometimes Hard?</a>
<ul>
<li><a href="#human-condition">Human condition</a></li>
<li><a href="#time-pressure">Time Pressure</a></li>
<li><a href="#large-bag-of-tricks">Large Bag of Tricks</a></li>
<li><a href="#not-exactly-muscle-memory">Not exactly Muscle Memory</a></li>
<li><a href="#cookie-cutters">Cookie cutters</a></li>
<li><a href="#summary-1">Summary</a></li>
</ul></li>
</ul>
</div>
<p>Code for this project can be found in my <a href="https://github.com/rpeszek/experiments" target="_blank">experiments</a> github repo (<a href="https://github.com/rpeszek/experiments/tree/master/probability-tree-schemes" target="_blank">probability-tree-schemes</a> folder).</p>
<p>The goal of this post is to present a simple example that uses recursion schemes. My other goal is to discuss my thoughts about reasons for getting stuck on finding the right solution. It will be a bit of a rant.</p>
<p><strong>Motivation:</strong><br />
Last week I encountered a programming problem that kept defeating me. It took me forever just to figure out how to translate the requirements into something I can code. The gist of this problem turned out to be very straightforward: implement a probability tree diagram (a decision tree annotated with probabilities). Well not really, but close enough.<br />
I think, now, that the problem is simple, but it was not the case during the few hours I initially have spent on it. This experience was somewhat surprising to me as I have worked for several years with decision graphs (not trees, but still). I just I failed to make the association.</p>
<p>I am sharing my experience in this post. This post shows the solution program, and as such, ended up becoming a “tutorial” of sorts about the recursion schemes. I tried to make it easy to read even if some Haskell code is more at an intermediate level. In this tutorial I will get in trouble couple of times arriving at an incorrect solution.</p>
<p>At the end of this post (<a href="#why-finding-the-right-solution-is-sometimes-hard">Why Finding the Right Solution is Sometimes Hard?</a>) I rant about my beliefs pertaining to the question in the title.</p>
<h2 id="the-problem">The Problem</h2>
<p>Consider a tree with edges (or nodes) annotated with probability weights. The problem I am going to solve is simple: calculate the path likelihoods for each of the <em>leaves</em>. Basically multiply all the probabilities down each branch all the way to the leaf.</p>
<p>This is obviously not so hard, and the biggest challenge was to figure out that this was what the requirements needed.<br />
The solution seems like a good exercise and I am sharing my solutions here.</p>
<p>All the goodies (<code>a</code>) are at the leaves, in addition, each node is annotated with some probability <code>p</code> and a label <code>String</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">Data.Functor.Foldable.TH</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">ProbTree</span> p a <span class="ot">=</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>    <span class="dt">Leaf</span> p <span class="dt">String</span> a</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>    <span class="op">|</span> <span class="dt">Branches</span> p <span class="dt">String</span> [<span class="dt">ProbTree</span> p a]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>    <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Traversable</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>makeBaseFunctor '<span class="dt">'ProbTree</span></span></code></pre></div>
<p>The goal is implement a function that transforms <code>ProbTree NodeProb a</code> into <code>ProbTree CumulativeProb a</code>.</p>
<p>I will be using <a href="https://hackage.haskell.org/package/recursion-schemes" target="_blank"><em>recursion-schemes</em></a> package and <code>makeBaseFunctor</code> generates the code I will need to fold or unfold the tree. All the instances I have declared, <code>Functor, Foldable, Traversable</code>, are intended for the consumption of the goodies <code>a</code>. I will not care much about <code>a</code>-s in this post. I will care about the <code>p</code>-s.</p>
<p>This type is really a <code>Bifunctor</code> (Functor in both <code>p</code> and <code>a</code>), and most of the code I am going to show could just use that. Instead of implementing <code>Bifunctor</code> instance I will use:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.List</span> <span class="kw">as</span> <span class="dt">L</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="ot">probMap ::</span> (p1 <span class="ot">-&gt;</span> p2) <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> p1 a <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> p2 a</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>probMap fn (<span class="dt">Leaf</span> p l a) <span class="ot">=</span> <span class="dt">Leaf</span> (fn p) l a</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>probMap fn (<span class="dt">Branches</span> p l xs) <span class="ot">=</span> <span class="dt">Branches</span> (fn p) l <span class="op">$</span> L.map (probMap fn) xs</span></code></pre></div>
<p>However, for some examples I will need something stronger, I need it to be <code>Traversable</code> in <code>p</code>.<br />
I will just use the <a href="https://hackage.haskell.org/package/lens" target="_blank"><em>lens</em></a> package to get what I need. You do not need to know much about lenses to read on. I will try to explain the usage as I go.</p>
<p>Keeping <code>p</code> as a type variable is convenient and, for example, could allow me to use it for (<code>Natural</code>) distribution counts or other things that probabilities can morph into.</p>
<h3 id="why-is-this-useful">Why is this useful?</h3>
<p>Decision Trees are popular because of their ability to visualize outcomes of various processes.<br />
It is sometimes useful to know the distribution of the final outcomes. Think about using <em>QuickCheck</em> to randomly generate final outcomes or, maybe, randomly pick these outcomes from some big dataset of samples.<br />
<code>ProbTree p a</code> would use <code>a</code> to hold the generated values or to describe them in some way. It is convenient to keep the data samples <code>a</code> separate from probabilities <code>p</code> (instead of just using something like <code>RoseTree (p,a)</code>) because we care about these samples only at the final outcome / leaf level.<br />
The extra <code>String</code> label is for my own convenience. It allows me to trace how the recursion schemes work and will be handy in this presentation.<br />
<code>ProbTree p a</code> may not be the nicest to use when implementing recursion-schemes. All the better as the choice of training!</p>
<h3 id="plumbing">Plumbing</h3>
<p>So I have a lens that will let me ‘focus’ on the <code>p</code>-s:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">Control.Lens</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a><span class="co">-- | needs to be non-polymorphic because of nesting</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a><span class="ot">probability ::</span> <span class="dt">Lens'</span> (<span class="dt">ProbTree</span> p a) p</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>probability <span class="ot">=</span> lens get set </span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>    get (<span class="dt">Leaf</span> p _ _) <span class="ot">=</span> p</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>    get (<span class="dt">Branches</span> p _ _) <span class="ot">=</span> p</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>    set (<span class="dt">Leaf</span> _ l x) r <span class="ot">=</span> <span class="dt">Leaf</span> r l x</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a>    set (<span class="dt">Branches</span> _ l x) r <span class="ot">=</span> <span class="dt">Branches</span> r l x</span></code></pre></div>
<p>It is considered a bad karma to use Record syntax for types that have several constructors. So I coded this by hand. Otherwise template Haskell <code>makeLenses</code> could create <code>probability</code> if both constructors had a field with the same name <code>_probability :: p</code>. If you new to lenses, think that the above code <em>encapsulates</em> getting and setting <code>p</code>-s.<br />
This thing is what is called a simple lens. That means it does not allow me to change the <code>p</code> type. I will need something more flexible than that(<code>makeLenses</code> does not create what I need anyway).</p>
<p>In a dream, dependently typed, world there would be a type level guarantee that in <code>Branches (p1 :: p) String [ProbTree (pn :: p) a]</code> we have <code>1 ~ sum pn</code> for probability weights and <code>p1 ~ sum pn</code> for cumulative case.<br />
In reality, it would be nice to, at least, not use <code>p ~ Float</code> all the time.<br />
Since I will be changing the meaning of what <code>p</code> is from a probability assigned to a node to calculated cumulative probability of getting to this node:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">NodeProb</span> <span class="ot">=</span> <span class="dt">NodeProb</span> {<span class="ot">unNodeProb ::</span> <span class="dt">Float</span>} <span class="kw">deriving</span> <span class="dt">Eq</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">CumulativeProb</span> <span class="ot">=</span> <span class="dt">CumulativeProb</span> {<span class="ot">unCumulativeProb ::</span> <span class="dt">Float</span>} <span class="kw">deriving</span> <span class="dt">Eq</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a><span class="co">-- Show instances implemented, but not shown (pun not intended)</span></span></code></pre></div>
<p>To deal with swapping <code>p</code>’s I need to implement an honest to god traversal. Consider this as just a boilerplate:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="ot">probabilityT ::</span> <span class="kw">forall</span> p r a f <span class="op">.</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> </span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>    (p <span class="ot">-&gt;</span> f r) </span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>    <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> p a </span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>    <span class="ot">-&gt;</span> f (<span class="dt">ProbTree</span> r a)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>probabilityT fn (<span class="dt">Leaf</span> p l a) <span class="ot">=</span> <span class="dt">Leaf</span> <span class="op">&lt;$&gt;</span> fn p <span class="op">&lt;*&gt;</span> <span class="fu">pure</span> l <span class="op">&lt;*&gt;</span> <span class="fu">pure</span> a</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>probabilityT fn (<span class="dt">Branches</span> p l xs) <span class="ot">=</span> <span class="dt">Branches</span> <span class="op">&lt;$&gt;</span> fn p <span class="op">&lt;*&gt;</span> <span class="fu">pure</span> l <span class="op">&lt;*&gt;</span> fx xs</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>  <span class="kw">where</span><span class="ot"> fx ::</span> [<span class="dt">ProbTree</span> p a] <span class="ot">-&gt;</span> f [<span class="dt">ProbTree</span> r a]</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>        fx xs <span class="ot">=</span> <span class="fu">traverse</span> (probabilityT fn) xs</span></code></pre></div>
<p>Now I can implement cumulative probabilities working with <code>Float</code>s and expose them to external code using more descriptive types (<em>lens</em> <a href="https://hackage.haskell.org/package/lens-5.0.1/docs/Control-Lens-Iso.html"><code>Iso</code></a>-s would be nicer, this seems to work better in the context of this post):</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="ot">compWithFloats ::</span> </span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>   (<span class="dt">ProbTree</span> <span class="dt">Float</span> a <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">Float</span> a) </span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>   <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">NodeProb</span> a </span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>   <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">CumulativeProb</span> a</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>compWithFloats fn <span class="ot">=</span> over probabilityT <span class="dt">CumulativeProb</span> <span class="op">.</span> fn <span class="op">.</span> over probabilityT unNodeProb</span></code></pre></div>
<h3 id="example-tree">Example Tree</h3>
<p>I am now in the position to define a simple example tree:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="ot">exTree ::</span> <span class="dt">ProbTree</span> <span class="dt">NodeProb</span> ()</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>exTree <span class="ot">=</span> over probabilityT <span class="dt">NodeProb</span> <span class="op">$</span> <span class="dt">Branches</span> <span class="dv">1</span> <span class="st">&quot;R&quot;</span> [</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>   <span class="dt">Branches</span> <span class="fl">0.5</span> <span class="st">&quot;1&quot;</span> [</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>      <span class="dt">Branches</span> <span class="fl">0.5</span> <span class="st">&quot;11&quot;</span> [</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>          <span class="dt">Leaf</span> <span class="fl">0.5</span> <span class="st">&quot;111&quot;</span> ()</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a>          , <span class="dt">Leaf</span> <span class="fl">0.5</span> <span class="st">&quot;112&quot;</span> ()</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a>       ]</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>       , <span class="dt">Branches</span> <span class="fl">0.5</span> <span class="st">&quot;12&quot;</span> [</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>          <span class="dt">Leaf</span> <span class="dv">1</span> <span class="st">&quot;121&quot;</span> ()</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a>       ]</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a>   ]</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a>   , <span class="dt">Branches</span> <span class="fl">0.5</span> <span class="st">&quot;2&quot;</span> [</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true"></a>      <span class="dt">Leaf</span> <span class="fl">0.2</span> <span class="st">&quot;21&quot;</span> ()</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true"></a>      , <span class="dt">Leaf</span> <span class="fl">0.4</span> <span class="st">&quot;22&quot;</span> ()</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true"></a>      , <span class="dt">Branches</span> <span class="fl">0.4</span> <span class="st">&quot;23&quot;</span> [</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true"></a>          <span class="dt">Leaf</span> <span class="fl">0.5</span> <span class="st">&quot;231&quot;</span> ()</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true"></a>          , <span class="dt">Leaf</span> <span class="fl">0.5</span> <span class="st">&quot;232&quot;</span> ()</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true"></a>       ]</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true"></a>   ]</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true"></a> ]</span></code></pre></div>
<p>the lens <code>over</code> allows me to type the Floats and <code>map</code> these to the <code>NodeProb</code> type to indicate what the numbers represent at the type level. I will use this example moving forward. The final result (leaves only) of what I want to compute annotated with labels should look like this:</p>
<pre><code>&quot;(0.125,&quot;111&quot;),(0.125,&quot;112&quot;),(0.25,&quot;121&quot;),(0.1,&quot;21&quot;),(0.2,&quot;22&quot;),(0.1,&quot;231&quot;),(0.1,&quot;232&quot;)&quot;</code></pre>
<h3 id="traditional-solution-state-threads">Traditional Solution, State Threads</h3>
<p>There is a good possibility of finding a ready solution for the problem on <em>stackoverflow</em> or even in <em>wikipedia</em>.<br />
The code in some psedo-language that mutates variables would look something like:</p>
<pre><code>// some C-like language
// mutate in-place all probabilities on all nodes on a tree. 

calculateProbNode (weight, node) = 
   node.prob = weight * node.prob
   children = node.children
   for (child :: children) {
     calculateProb (node.prob, child)
   } 

calcuateProb (node) =  calculateProbNode (1, node)    </code></pre>
<p>Since I moved to Haskell, code like this started to scare me. It mutates things, returns nothing, and it is easy to get it wrong.<br />
However, there are reasons (e.g. performance) when code like this is needed.<br />
There it the misconceptions about Haskell not being able to mutate variables. In particular, variable mutation in internal implementation that leads to a referentially transparent result can be even implemented as a pure function. The tooling for this is called <code>ST</code> monad.</p>
<p>This is the above code implemented in Haskell:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">Control.Monad.ST</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">Data.STRef</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">MutableFloat</span> s <span class="ot">=</span> <span class="dt">STRef</span> s <span class="dt">Float</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a><span class="ot">computeProbMutable ::</span> <span class="kw">forall</span> a <span class="op">.</span> <span class="dt">ProbTree</span> <span class="dt">NodeProb</span> a <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">CumulativeProb</span> a </span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a>computeProbMutable <span class="ot">=</span> compWithFloats (</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a>    \t <span class="ot">-&gt;</span> runST <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a>        mutable <span class="ot">&lt;-</span> makeMutable t </span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true"></a>        mutableres <span class="ot">&lt;-</span> recursion <span class="dv">1</span> mutable</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true"></a>        makeNonMutable mutableres</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true"></a>    )</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true"></a> <span class="kw">where</span> </span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true"></a><span class="ot">   recursion ::</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> (<span class="dt">MutableFloat</span> s) a <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">ProbTree</span> (<span class="dt">MutableFloat</span> s) a)   </span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true"></a>   recursion n (<span class="dt">Branches</span> mutp l xs)  <span class="ot">=</span> <span class="kw">do</span> </span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true"></a>     modifySTRef mutp (n <span class="op">*</span>) <span class="co">-- modify probability in place</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true"></a>     n1 <span class="ot">&lt;-</span> readSTRef mutp   <span class="co">-- read modified probablity</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true"></a>     xs1 <span class="ot">&lt;-</span> <span class="fu">mapM</span> (recursion n1) xs <span class="co">-- recursively apply modified value to children</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true"></a>     <span class="fu">return</span> <span class="op">$</span> <span class="dt">Branches</span> mutp l xs1  </span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true"></a></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true"></a>   recursion n x<span class="op">@</span>(<span class="dt">Leaf</span> mutp _ _) <span class="ot">=</span> <span class="kw">do</span> </span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true"></a>     modifySTRef mutp (n <span class="op">*</span>)  <span class="co">-- on Leaf there is not much to do, only modify the propability</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true"></a>     <span class="fu">return</span> x</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true"></a></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true"></a><span class="co">-- | Traverse all Tree nodes and replace Float's with `MutableFloat`-s.</span></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true"></a><span class="ot">makeMutable ::</span> <span class="dt">ProbTree</span> <span class="dt">Float</span> a <span class="ot">-&gt;</span>  <span class="dt">ST</span> s (<span class="dt">ProbTree</span> (<span class="dt">MutableFloat</span> s) a)</span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true"></a>makeMutable <span class="ot">=</span>  </span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true"></a>   traverseOf probabilityT (newSTRef <span class="op">@</span><span class="dt">Float</span>)</span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true"></a></span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true"></a><span class="co">-- | Traverse all Tree nodes and replace `MutableFloat`-s with not mutable regular `Float`s</span></span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true"></a><span class="ot">makeNonMutable ::</span>  <span class="dt">ProbTree</span> (<span class="dt">MutableFloat</span> s) a <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">ProbTree</span> <span class="dt">Float</span> a) </span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true"></a>makeNonMutable <span class="ot">=</span> traverseOf probabilityT readSTRef</span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true"></a></span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt; tstMutable</span></span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true"></a><span class="co">-- &quot;(0.125,\&quot;111\&quot;,()),(0.125,\&quot;112\&quot;,()),(0.25,\&quot;121\&quot;,()),(0.1,\&quot;21\&quot;,()),(0.2,\&quot;22\&quot;,()),(0.1,\&quot;231\&quot;,()),(0.1,\&quot;232\&quot;,())&quot;</span></span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true"></a><span class="ot">tstMutable ::</span> <span class="dt">String</span></span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true"></a>tstMutable <span class="ot">=</span> printLeaves <span class="op">$</span> computeProbMutable exTree  </span></code></pre></div>
<p>The bulk of the code is translating from not mutable Haskell to mutable variable <code>type MutableFloat s = STRef s Float</code>. The rest is very similar to the psedo-code above.</p>
<p>If you are not familiar with <code>ST</code>, the <code>s</code> is existential and prevents mutable Floats from escaping the <code>ST</code> Monad. You can use them inside <code>ST</code> but not after you leave it.</p>
<p>What is mind-blowing to me is that Haskell introduced this in 1993! Now such existential tricks are used a lot (e.g. in dependently typed code) so the concept probably does not need much introduction.</p>
<h3 id="simple-recursion-schemes">Simple Recursion Schemes</h3>
<p>The above solution leaves a bad taste in my mouth. The idea I will pursue is that I can compute these values by <em>folding</em> or maybe <em>unfolding</em> the tree. This example uses the <a href="https://hackage.haskell.org/package/recursion-schemes" target="_blank"><em>recursion-schemes</em></a> package. I am not going to delve deep into recursion schemes. My goal is to show the code with high level explanations for how and why it works.</p>
<p>Great information about some of the category theoretical background can be found in Bartosz Milewski’s <a href="https://bartoszmilewski.com/2017/02/28/f-algebras/" target="_blank">CTFP Book, F-Algebras secion</a>.<br />
There is a series of blogs devoted to recursion-schemes by Patrick Thomson that are very good reading as well <a href="https://blog.sumtypeofway.com/posts/introduction-to-recursion-schemes.html" target="_blank">An Introduction to Recursion Schemes</a>.</p>
<p><strong>Quick intro to recursion-schemes.</strong></p>
<p>The Template Haskell instruction, <code>makeBaseFunctor ''ProbTree</code>, we have started with generated a new type that looks like this:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">ProbTreeF</span> p a r <span class="ot">=</span> <span class="dt">LeafF</span> p <span class="dt">String</span> a <span class="op">|</span> <span class="dt">BranchesF</span> p <span class="dt">String</span> [r]</span></code></pre></div>
<p>As you can see, <code>ProbTreeF</code> is very similar to <code>ProbTree</code>, except the original ‘recursive’ <code>ProbTree p a</code> in <code>Branches p String [ProbTree p a]</code> got replaced with a new type variable <code>r</code> in <code>BranchesF p String [r]</code>.</p>
<p><em>recursion_schemes</em> uses <code>Base t</code> type family and <code>ProbTreeF p a r</code> is the <em>Base</em> functor for <code>ProbTree</code>.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Base</span><span class="ot"> t ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Base</span> (<span class="dt">ProbTree</span> p a) <span class="ot">=</span> <span class="dt">ProbTreeF</span> p a</span></code></pre></div>
<p>and the library uses <code>Base</code> in all of its definitions. I will use <code>ProbTreeF</code> for clarity.</p>
<p>Classic recursion scheme code often starts with the base functor and derives the recursive target type by applying <a href="https://hackage.haskell.org/package/data-fix-0.3.1/docs/Data-Fix.html#g:1" target="_blank"><em>Fix</em></a> from <a href="https://hackage.haskell.org/package/data-fix" target="_blank"><code>data-fix</code></a>. Both are isomorphic:</p>
<pre><code>Fix (ProbTreeF p a) =~ ProbTree p a</code></pre>
<p>If this is new to you it will take some time digest. (<strong>end</strong>)</p>
<h4 id="catamorphism">Catamorphism</h4>
<p>As a warm-up let’s fold the tree by collecting information about leaves onto a single String:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="ot">printLeaves ::</span> <span class="kw">forall</span> p a<span class="op">.</span> (<span class="dt">Show</span> p, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">ProbTree</span> p a <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>printLeaves <span class="ot">=</span> fold fn</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a><span class="ot">      fn ::</span> <span class="dt">ProbTreeF</span> p a <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>      fn (<span class="dt">LeafF</span> n lb a) <span class="ot">=</span> <span class="fu">show</span> (n, lb, a)</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a>      fn (<span class="dt">BranchesF</span> _ _ xs) <span class="ot">=</span> L.intercalate <span class="st">&quot;,&quot;</span> xs</span></code></pre></div>
<p>This code folds the tree onto a String by spelling out the <code>LeafF</code> content and then by concatenating the strings using comma when processing <code>BranchesF</code>.</p>
<p><strong>Back to a quick into:</strong><br />
The <em>Base</em> functor for <em>List</em> (i.e. <code>[]</code>) looks like this:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">ListF</span> a b <span class="ot">=</span> <span class="dt">Nil</span> <span class="op">|</span> <span class="dt">Cons</span> a b </span></code></pre></div>
<p>folding a list would amount to:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="ot">printList ::</span> (<span class="dt">Show</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>printList <span class="ot">=</span> fold fn</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a><span class="ot">      fn ::</span> <span class="dt">ListF</span> a <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>      fn <span class="dt">Nil</span> <span class="ot">=</span> <span class="st">&quot;(START)&quot;</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a>      fn (<span class="dt">Cons</span> a str) <span class="ot">=</span> <span class="fu">show</span> a <span class="op">&lt;&gt;</span> <span class="st">&quot;:&quot;</span> <span class="op">&lt;&gt;</span> str</span></code></pre></div>
<p>compare it to</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>printList' <span class="ot">=</span> L.foldr (\a str <span class="ot">-&gt;</span> <span class="fu">show</span> a <span class="op">&lt;&gt;</span> <span class="st">&quot;,&quot;</span> <span class="op">&lt;&gt;</span> str) <span class="st">&quot;(START)&quot;</span> </span></code></pre></div>
<p>These are effectively the same!</p>
<p>Ability to fold arbitrary recursive data is rely very convenient. For example, JSON data served by some micro-services may lack consistency (not all micro-services are implemented in Haskell, you know)</p>
<blockquote>
<p>“What if I told you it is possible to fold JSON values?”</p>
</blockquote>
<p>Morpheus, The Matrix</p>
<p><em>recursion-schemes</em> defines <em>cata</em> as an alternative name for <em>fold</em>. <em>cata</em> seems to be more popular and stands for <em>catamorphism</em>. (<strong>end</strong>)</p>
<p><strong>Continuing the warm-up:</strong></p>
<p>We can do effectful things too!</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="ot">printIO ::</span> <span class="kw">forall</span> p a<span class="op">.</span> (<span class="dt">Show</span> p, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">ProbTree</span> p a <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">String</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a>printIO <span class="ot">=</span> fold fn</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a><span class="ot">      fn ::</span> <span class="dt">ProbTreeF</span> p a (<span class="dt">IO</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">String</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a>      fn (<span class="dt">LeafF</span> n lb a) <span class="ot">=</span> <span class="kw">do</span> </span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a>          <span class="fu">print</span> (n, lb, a) <span class="co">-- as before</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true"></a>          <span class="fu">return</span> <span class="op">$</span> <span class="st">&quot;done leaf &quot;</span> <span class="op">&lt;&gt;</span> lb</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true"></a>      fn (<span class="dt">BranchesF</span> _ lb ixs) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true"></a>           xs <span class="ot">&lt;-</span> <span class="fu">sequence</span> ixs</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true"></a>           <span class="fu">print</span> <span class="op">$</span> <span class="st">&quot;Processed so far: &quot;</span> <span class="op">++</span> <span class="fu">show</span> xs</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true"></a>           <span class="fu">return</span> <span class="op">$</span> <span class="st">&quot;done branch &quot;</span> <span class="op">&lt;&gt;</span> lb</span></code></pre></div>
<p>This will print content of leaves, when processing branches will print what it processed before.</p>
<p>It produces this output:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="op">*</span><span class="dt">Schemes</span><span class="op">&gt;</span> tstPrintIO</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a>(<span class="fl">0.5</span>,<span class="st">&quot;111&quot;</span>,())</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a>(<span class="fl">0.5</span>,<span class="st">&quot;112&quot;</span>,())</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a><span class="st">&quot;Processed so far: [\&quot;done leaf 111\&quot;,\&quot;done leaf 112\&quot;]&quot;</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a>(<span class="fl">1.0</span>,<span class="st">&quot;121&quot;</span>,())</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true"></a><span class="st">&quot;Processed so far: [\&quot;done leaf 121\&quot;]&quot;</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true"></a><span class="st">&quot;Processed so far: [\&quot;done branch 11\&quot;,\&quot;done branch 12\&quot;]&quot;</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true"></a>(<span class="fl">0.2</span>,<span class="st">&quot;21&quot;</span>,())</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true"></a>(<span class="fl">0.4</span>,<span class="st">&quot;22&quot;</span>,())</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true"></a>(<span class="fl">0.5</span>,<span class="st">&quot;231&quot;</span>,())</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true"></a>(<span class="fl">0.5</span>,<span class="st">&quot;232&quot;</span>,())</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true"></a><span class="st">&quot;Processed so far: [\&quot;done leaf 231\&quot;,\&quot;done leaf 232\&quot;]&quot;</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true"></a><span class="st">&quot;Processed so far: [\&quot;done leaf 21\&quot;,\&quot;done leaf 22\&quot;,\&quot;done branch 23\&quot;]&quot;</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true"></a><span class="st">&quot;Processed so far: [\&quot;done branch 1\&quot;,\&quot;done branch 2\&quot;]&quot;</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true"></a><span class="st">&quot;done branch R&quot;</span></span></code></pre></div>
<h4 id="solution-using-anamorphism">Solution using Anamorphism</h4>
<p>Instead of using <code>fold</code> / <code>cata</code>-morphism, I will first use its opposite: <code>unfold</code> / <code>ana</code>-morphism to solve the problem of computing the commutative probabilities.<br />
We will solve the problem by unfolding the tree onto itself (I will be constructing <code>ProbTreeF</code>).<br />
<em>recusion-schemes</em> provides a convenient <code>project</code> function that typically can be used to implement all the uninteresting cases when unfolding the structure onto itself:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt; printLeaves . computeProb $ exTree</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a><span class="co">-- &quot;(0.125,\&quot;111\&quot;,()),(0.125,\&quot;112\&quot;,()),(0.25,\&quot;121\&quot;,()),(0.1,\&quot;21\&quot;,()),(0.2,\&quot;22\&quot;,()),(0.1,\&quot;231\&quot;,()),(0.1,\&quot;232\&quot;,())&quot;</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a><span class="ot">computeProb ::</span> <span class="dt">ProbTree</span> <span class="dt">NodeProb</span> a <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">CumulativeProb</span> a</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a>computeProb <span class="ot">=</span> compWithFloats (unfold fn)</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true"></a><span class="ot">    fn ::</span> <span class="dt">ProbTree</span> <span class="dt">Float</span> a <span class="ot">-&gt;</span> <span class="dt">ProbTreeF</span> <span class="dt">Float</span> a (<span class="dt">ProbTree</span> <span class="dt">Float</span> a)</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true"></a>    fn (<span class="dt">Branches</span> n l xs) <span class="ot">=</span> <span class="dt">BranchesF</span> n l (L.map (over probability (<span class="op">*</span> n)) xs)</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true"></a>    fn x <span class="ot">=</span> project x</span></code></pre></div>
<p>the only interesting case is unfolding the <code>Branches n l xs</code> constructor. It is unfolded into <code>BranchesF n l xs'</code> where <code>xs'</code> is a list of children with probability modified by the current value on the branch. This line makes the computation flow towards the leaves. Thus, we can assume that the current probability value <code>n</code> has been already computed.</p>
<p>Note that to test print the outcome, we have unfolded the tree in <code>computeProb</code> and then folded it using <code>printLeaves</code> there is a convenience function <code>hylo</code> or <code>refold</code> included in <em>recursion-schemes</em> package that does exactly that.</p>
<h4 id="back-to-catamorphism.">Back to Catamorphism.</h4>
<p>(EDITED, previous version of this post had it wrong, thanks <a href="https://www.reddit.com/r/haskell/comments/onrhtw/probability_tree_diagrams_recursion_schemes_why/h684cpr?utm_source=share&amp;utm_medium=web2x&amp;context=3" target="_blank">r/Tarmen</a>)</p>
<p>In the previous section, I have unfolded the tree onto itself. That did not really unfold or construct much as the unfolding type was the tree itself. We can as well try the same trick using <code>cata</code> or <code>fold</code>, since we will not be destroying / folding much either.</p>
<p><em>recusion-schemes</em> provides a convenient <code>embed</code> function that typically can be used to implement all the uninteresting cases:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="co">-- |</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt; printLeaves . computeProbBad $ exTree</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a><span class="co">-- &quot;(0.25,\&quot;111\&quot;,()),(0.25,\&quot;112\&quot;,()),(0.5,\&quot;121\&quot;,()),(0.1,\&quot;21\&quot;,()),(0.2,\&quot;22\&quot;,()),(0.2,\&quot;231\&quot;,()),(0.2,\&quot;232\&quot;,())&quot;</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a><span class="ot">computeProbBad ::</span> <span class="dt">ProbTree</span> <span class="dt">NodeProb</span> a <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">CumulativeProb</span> a</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a>computeProbBad <span class="ot">=</span> compWithFloats (cata fn)</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true"></a><span class="ot">      fn ::</span> <span class="dt">ProbTreeF</span> <span class="dt">Float</span> a (<span class="dt">ProbTree</span> <span class="dt">Float</span> a) <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">Float</span> a</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true"></a>      fn (<span class="dt">BranchesF</span> n l xs) <span class="ot">=</span> <span class="dt">Branches</span> n l (L.map (over probability (<span class="op">*</span> n)) xs)</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true"></a>      fn x <span class="ot">=</span> embed x</span></code></pre></div>
<p>notice there is a problem, the numbers are off. The problem is subtle. The <em>lens</em> over just modifies the current node, what we want is to apply the probability modification to the whole subtree:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt; printLeaves . computeProbCata $ exTree</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a><span class="co">-- &quot;(0.125,\&quot;111\&quot;,()),(0.125,\&quot;112\&quot;,()),(0.25,\&quot;121\&quot;,()),(0.1,\&quot;21\&quot;,()),(0.2,\&quot;22\&quot;,()),(0.1,\&quot;231\&quot;,()),(0.1,\&quot;232\&quot;,())&quot;</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a><span class="ot">computeProbCata ::</span> <span class="dt">ProbTree</span> <span class="dt">NodeProb</span> a <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">CumulativeProb</span> a</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a>computeProbCata <span class="ot">=</span> compWithFloats (cata fn)</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true"></a><span class="ot">      fn ::</span> <span class="dt">ProbTreeF</span> <span class="dt">Float</span> a (<span class="dt">ProbTree</span> <span class="dt">Float</span> a) <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">Float</span> a</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true"></a>      fn (<span class="dt">BranchesF</span> n l xs) <span class="ot">=</span> <span class="dt">Branches</span> n l (L.map (probMap (<span class="op">*</span> n)) xs)</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true"></a>      fn x <span class="ot">=</span> embed x</span></code></pre></div>
<p>This works, but it is interesting to play little more with folding just to see how else I can get in trouble.</p>
<h4 id="st-example">ST Example</h4>
<p><strong>Bad attempt:</strong></p>
<p>If you looked closely at the <code>printIO</code> example in the <a href="#catamorphism">Catamorphism</a> section, you may have noticed that that the fold of <code>Branches</code> was able to do effecty things on the children. We can use the same approach to our advantage.<br />
We will go into a mutating franzy and fold <code>ProbTree</code> into just <code>MutableFloat s</code>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="ot">computeSTBad ::</span> <span class="kw">forall</span> s a <span class="op">.</span> <span class="dt">ProbTree</span> (<span class="dt">ST</span> s (<span class="dt">MutableFloat</span> s)) a <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">MutableFloat</span> s)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a>computeSTBad <span class="ot">=</span> fold fn</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a><span class="ot">      fn ::</span> <span class="dt">ProbTreeF</span> (<span class="dt">ST</span> s (<span class="dt">MutableFloat</span> s)) a (<span class="dt">ST</span> s (<span class="dt">MutableFloat</span> s)) <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">MutableFloat</span> s)</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a>      fn (<span class="dt">LeafF</span> n _ _) <span class="ot">=</span> n</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true"></a></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true"></a>      fn (<span class="dt">BranchesF</span> stmn lb ixs) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true"></a><span class="ot">           mn ::</span> <span class="dt">MutableFloat</span> s <span class="ot">&lt;-</span> stmn</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true"></a><span class="ot">           n ::</span> <span class="dt">Float</span> <span class="ot">&lt;-</span> readSTRef mn <span class="co">-- read branch proability</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true"></a><span class="ot">           mxs ::</span> [<span class="dt">MutableFloat</span> s] <span class="ot">&lt;-</span> <span class="fu">sequence</span> ixs <span class="co">-- get access to mutable probablities for direct children </span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true"></a>           <span class="fu">mapM_</span> (<span class="ot">`modifySTRef`</span> (n <span class="op">*</span>)) mxs <span class="co">-- mutate the children's probabilities (This even sounds wrong!)</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true"></a>           stmn <span class="co">-- return back the untouched branch probability</span></span></code></pre></div>
<p>Making this into a pure function requires even crazier mutations (this reuses previously defined <code>makeMutable</code> and <code>makeNonMutable</code>):</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="ot">computeProbMutableBad ::</span> <span class="kw">forall</span> a <span class="op">.</span> <span class="dt">ProbTree</span> <span class="dt">NodeProb</span> a <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">CumulativeProb</span> a</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a>computeProbMutableBad <span class="ot">=</span> compWithFloats (</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a>    \t <span class="ot">-&gt;</span> runST <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a>        mutable <span class="ot">&lt;-</span> makeMutable t</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a>        mutable' <span class="ot">&lt;-</span> traverseOf probabilityT (<span class="fu">pure</span> <span class="op">.</span> <span class="fu">pure</span>) mutable</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true"></a>        computeSTBad mutable'</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true"></a>        makeNonMutable mutable</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true"></a>    )</span></code></pre></div>
<p>the result of <code>computeST mutable</code> is discarded, and I use <code>pure . pure</code> (double effectful?), how crazy is that!</p>
<p>But, we see exactly the same issue as with our naive <code>cata</code> attempt in the previous section:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a><span class="co">-- |</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt; tstMutableBad</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a><span class="co">-- &quot;(0.25,\&quot;111\&quot;,()),(0.25,\&quot;112\&quot;,()),(0.5,\&quot;121\&quot;,()),(0.1,\&quot;21\&quot;,()),(0.2,\&quot;22\&quot;,()),(0.2,\&quot;231\&quot;,()),(0.2,\&quot;232\&quot;,())&quot;</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true"></a><span class="ot">tstMutableBad ::</span> <span class="dt">String</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true"></a>tstMutableBad <span class="ot">=</span> printLeaves <span class="op">$</span> computeProbMutableBad exTree</span></code></pre></div>
<p>This approach applies the correction to probabilities of the node children. We need to apply the correction all the way down the child subtree!</p>
<p><strong>So let’s fix it:</strong></p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a><span class="ot">computeST ::</span> <span class="kw">forall</span> s a <span class="op">.</span> <span class="dt">ProbTree</span> (<span class="dt">ST</span> s (<span class="dt">MutableFloat</span> s)) a <span class="ot">-&gt;</span> <span class="dt">ST</span> s [<span class="dt">MutableFloat</span> s]</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a>computeST <span class="ot">=</span> fold fn</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true"></a><span class="ot">      fn ::</span> <span class="dt">ProbTreeF</span> (<span class="dt">ST</span> s (<span class="dt">MutableFloat</span> s)) a (<span class="dt">ST</span> s [<span class="dt">MutableFloat</span> s]) <span class="ot">-&gt;</span> <span class="dt">ST</span> s [<span class="dt">MutableFloat</span> s]</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true"></a>      fn (<span class="dt">LeafF</span> n _ _) <span class="ot">=</span>  (<span class="op">:</span>[]) <span class="op">&lt;$&gt;</span> n</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true"></a>      </span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true"></a>      fn (<span class="dt">BranchesF</span> stmn lb ixs) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true"></a><span class="ot">        mn ::</span> <span class="dt">MutableFloat</span> s <span class="ot">&lt;-</span> stmn</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true"></a><span class="ot">        n ::</span> <span class="dt">Float</span> <span class="ot">&lt;-</span> readSTRef mn <span class="co">-- read branch proability</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true"></a><span class="ot">        mxs ::</span> [<span class="dt">MutableFloat</span> s] <span class="ot">&lt;-</span> <span class="fu">concat</span> <span class="op">&lt;$&gt;</span> <span class="fu">sequence</span> ixs <span class="co">-- get access to mutable probablities for children </span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true"></a>        <span class="fu">mapM_</span> (<span class="ot">`modifySTRef`</span> (n <span class="op">*</span>)) mxs <span class="co">-- mutate the subtree's probabilities </span></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true"></a>        <span class="fu">pure</span> <span class="op">$</span> mn <span class="op">:</span> mxs <span class="co">--return all mutable floats, including the current node</span></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true"></a></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true"></a><span class="ot">computeProbMutable ::</span> <span class="kw">forall</span> a <span class="op">.</span> <span class="dt">ProbTree</span> <span class="dt">NodeProb</span> a <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">CumulativeProb</span> a</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true"></a>computeProbMutable <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true"></a></span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true"></a><span class="co">-- |</span></span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt; tstMutable</span></span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true"></a><span class="co">-- &quot;(0.125,\&quot;111\&quot;,()),(0.125,\&quot;112\&quot;,()),(0.25,\&quot;121\&quot;,()),(0.1,\&quot;21\&quot;,()),(0.2,\&quot;22\&quot;,()),(0.1,\&quot;231\&quot;,()),(0.1,\&quot;232\&quot;,())&quot;</span></span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true"></a><span class="ot">tstMutable ::</span> <span class="dt">String</span></span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true"></a>tstMutable <span class="ot">=</span> printLeaves <span class="op">$</span> computeProbMutable exTree</span></code></pre></div>
<p>It works! The trick was to change to folding structure to accumulate all mutable floats for the whole subtree and keep mutating them.<br />
The key is to find the correct structure to fold onto.</p>
<p>I do not like code like this type of code, but, I think, it does provide interesting imperative intuitions about the recursive fold.</p>
<h4 id="catamorphism.-reader-example.">Catamorphism. Reader Example.</h4>
<p>But there is a nice solution that learns from the previous <code>ST</code> example and is very close to the idea of folding the tree onto itself:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">Control.Monad.Reader</span> </span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt; printLeaves . computeProbRdr $ exTree</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true"></a><span class="co">-- &quot;(0.125,\&quot;111\&quot;,()),(0.125,\&quot;112\&quot;,()),(0.25,\&quot;121\&quot;,()),(0.1,\&quot;21\&quot;,()),(0.2,\&quot;22\&quot;,()),(0.1,\&quot;231\&quot;,()),(0.1,\&quot;232\&quot;,())&quot;</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true"></a><span class="ot">computeProbRdr ::</span> <span class="dt">ProbTree</span> <span class="dt">NodeProb</span> a <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">CumulativeProb</span> a</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true"></a>computeProbRdr <span class="ot">=</span> compWithFloats (\t <span class="ot">-&gt;</span> runReader (computePropRdr t) <span class="dv">1</span>)</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true"></a></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true"></a><span class="ot">computePropRdr ::</span> <span class="dt">ProbTree</span> <span class="dt">Float</span> a <span class="ot">-&gt;</span> <span class="dt">Reader</span> <span class="dt">Float</span> (<span class="dt">ProbTree</span> <span class="dt">Float</span> a)</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true"></a>computePropRdr <span class="ot">=</span> cata fn</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true"></a><span class="ot">    fn ::</span> <span class="dt">ProbTreeF</span> <span class="dt">Float</span> a (<span class="dt">Reader</span> <span class="dt">Float</span> (<span class="dt">ProbTree</span> <span class="dt">Float</span> a)) <span class="ot">-&gt;</span> <span class="dt">Reader</span> <span class="dt">Float</span> (<span class="dt">ProbTree</span> <span class="dt">Float</span> a)</span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true"></a>    fn (<span class="dt">BranchesF</span> n l xs) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true"></a>      p <span class="ot">&lt;-</span> ask</span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true"></a>      xss <span class="ot">&lt;-</span> <span class="fu">mapM</span> (local (<span class="op">*</span>n)) xs</span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true"></a>      <span class="fu">pure</span> <span class="op">$</span> <span class="dt">Branches</span> (p <span class="op">*</span> n) l xss</span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true"></a>    fn (<span class="dt">LeafF</span> n l a) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true"></a>      p <span class="ot">&lt;-</span> ask</span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true"></a>      <span class="fu">pure</span> <span class="op">$</span> <span class="dt">Leaf</span> (p <span class="op">*</span> n) l a  </span></code></pre></div>
<p>If you are not using <code>Reader</code> a lot it may be easier to look at this, more explicit solution:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a><span class="ot">computeProbFn ::</span> <span class="dt">ProbTree</span> <span class="dt">Float</span> a <span class="ot">-&gt;</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">Float</span> a</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true"></a>computeProbFn <span class="ot">=</span> cata fn</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true"></a><span class="ot">    fn ::</span> <span class="dt">ProbTreeF</span> <span class="dt">Float</span> a (<span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">Float</span> a) <span class="ot">-&gt;</span> (<span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">ProbTree</span> <span class="dt">Float</span> a)</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true"></a>    fn (<span class="dt">BranchesF</span> n l xs) p <span class="ot">=</span> <span class="dt">Branches</span> (p <span class="op">*</span> n) l <span class="op">$</span> L.map (\fn <span class="ot">-&gt;</span> fn <span class="op">.</span> ( <span class="op">*</span>n ) <span class="op">$</span> p ) xs</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true"></a>    fn (<span class="dt">LeafF</span> n l a) p <span class="ot">=</span> <span class="dt">Leaf</span> (p <span class="op">*</span> n) l a</span></code></pre></div>
<p>What we are accumulating, is the ability to conjure a descendant tree at any point from the current probability <code>Float</code>.<br />
We “conjure” the tree by modifying how the children are being “conjured”: we pre-compose <code>(* n)</code> (<code>n</code> is current node probability) to each of the functions that “conjure” the children. This forces recomputation of the probabilities all the way down to the leaves.<br />
This, no longer stops at depth 2.</p>
<h4 id="summary">Summary</h4>
<p>I have shown a few ways to compute <code>ProbTree CumulativeProb a</code>. I ended up getting in trouble a couple of times. <em>In fact, the original version of this post had bugs in it!</em> Recursion is dangerous, recursion has gotcha’s, it has to! Recursion is power with a price tag. Types is not very helpful when we recurse:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a><span class="ot">myUndefined ::</span> a</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true"></a>myUndefined <span class="ot">=</span> myUndefined</span></code></pre></div>
<p>It is easy to get in trouble!</p>
<h2 id="why-finding-the-right-solution-is-sometimes-hard">Why Finding the Right Solution is Sometimes Hard?</h2>
<p><strong>Rant Alert.</strong> This is about the cases where we know or knew how to do thing well but we get stuck anyway. Obviously, finding better and even better ways for writing code is a subject of a never ending research, I am not going to discuss that.</p>
<p>Haskell is an amazingly efficient tool for writing new code when our fingertips know what to do.<br />
Sometimes they do not, and then it is not much better than other languages. It lets us brute-force the code to satisfy the requirements. It is Turing complete, meaning that you can write as much nonsense as you want.</p>
<p>What bit me is:</p>
<ul>
<li>Short amount of time (few hours)</li>
<li>Difficulty in identifying a nice abstraction to solve the problem</li>
<li>The abstractions I ended up wanting to use were not in my short memory</li>
</ul>
<p>So instead I went pushing a brute-force solution…</p>
<p>This experience put me in a philosophical mood of trying to pin-point the reasons why sometimes the code just writes itself and sometimes we get stuck.</p>
<h3 id="human-condition">Human condition</h3>
<p>The underlying reason for why I do something wrong is typically me.<br />
We are not perfect, probably nothing shows it better than the software we write.</p>
<blockquote>
<p>“The universal aptitude for ineptitude makes any human accomplishment an incredible miracle”</p>
</blockquote>
<p>Stapp’s Law</p>
<p>Stapp and Murphy (his coworker) laws are not about giving up, these statements are about understanding our limitations and acting on this understanding.</p>
<h3 id="time-pressure">Time Pressure</h3>
<p>A hard deadline of a few hours does not (typically) happen in software engineering when writing a new code. It does for some data scientist. It also happens in competitive programming. I am not a competitive programmer and I believe very few programmers are.</p>
<p>Software engineers have to (sometimes) work with a short hard timeline when troubleshooting critical application errors. I believe, seasoned developers get years of conditioning that puts them into a troubleshooting mindset when under stress. This is not a creative mindset effective in designing a new code.</p>
<p>For code that is not a cookie-cutter, I believe I write the best code at night, when I sleep. Sometimes I need a few nights. It took two nights (no involvement otherwise) and then &lt; 1 hour of coding for the core examples presented here. It is not just about the time spend on the task, it is often about the latency.</p>
<p>Time pressure can be very destructive. It can reduce both the development speed and the code quality.<br />
That applies to longer time scales as well. Software industry, in my experience, is focused on short term goals. Quality is a long term goal.<br />
No project can afford to have no time constraints, so a balance needs to be struck. I believe the trade-offs are not well understood by the decision makers. … But this is well beyond what this post is about.</p>
<p>‘Uncle Bob’ (Robert C. Martin) likes to talk about a process in which you are not done when you finish writing the code and it works. It is the sweat time for making the code nice.</p>
<h3 id="large-bag-of-tricks">Large Bag of Tricks</h3>
<p>In this analogy a programmer is a magician with a bag of tricks. The bigger the bag the better the programmer. It takes more effort to sort through a bigger bag. There are some interesting indexers in that solution space allowing really good programmers to find a trick faster. One such indexer is the Category Theory. In general, any conceptual understanding of something is a record in some imaginary index.</p>
<p>The index record does not contain all the details, it is just a pointer, it takes time to load the actual details into short memory. That could involve looking up some stuff in the code or re-reading an article… Developer is a magician that needs time to prepare before he pulls out an <strong>old</strong> trick.</p>
<h3 id="not-exactly-muscle-memory">Not exactly Muscle Memory</h3>
<p><em>Muscle Memory</em> is a sports term. You train muscle memory so the movements happen on an auto-pilot.<br />
Muscle memory tends to be a long term memory (“it is like riding a bike”), it is also hard to change. This resistance to change could manifest itself as ‘bad muscle habits’ (e.g. a ski instructor skiing with a slight wedge, static body when making a shot in tennis…). Muscle memory is a long term memory, however athletes still require a warm-up lap / game / run…</p>
<p>For a long time, I have observed something very similar in programmers. Programming work is surprisingly repetitive, we develop something that resembles ‘muscle memory’ without even realizing it. We can do things much faster when we work on familiar problems. We are expert cookie-cutters.</p>
<p>Programmers tend to repeat the previously used patterns, even if these patterns are inferior to other methods (“bad muscle habits”).</p>
<p>Mainstream resistance to FP can be viewed as an example of resistance to change the “muscle memory”.</p>
<p>The analogy is not perfect. We do not need to do a warm-up typing when we start work, instead, we do need longer warm-up period when switching to a programming area we neglected for months or years. For me, that applies especially to the ability to translate ‘real world requirements’ to code design. I will just not think in terms that are not in my short memory, especially when under time pressure.</p>
<h3 id="cookie-cutters">Cookie cutters</h3>
<p>Cookie cutting is not just about repeating ingrained habits. I believe there is some project to project, program to program inertia which makes us want to repeat the same approach. This is not necessarily a bad thing if we are aware of it and if we are not afraid to explore other options.</p>
<p>Even looking at the job interview process, notice the focus on finding someone with a very closely fitting background.<br />
Have you ever seen a job posting asking for someone with a significantly different skill set from what the group already has? Hiring managers want to find cookie-cutters that can make cookies of a very similar shape that their team bakes.<br />
I think this is not optimal in long term. This bias creates groups with a narrow pool of experience and expertise.</p>
<p>I have to consider myself a cookie cutter too. The choices I made in the code I design are be biased by my other work.</p>
<h3 id="summary-1">Summary</h3>
<p>We can’t change who we are, we are unlikely to change the industry.</p>
<p>Instead, we can try to train “good movements” into our “muscle memory” and grow our bag of tricks.</p>
<blockquote>
<p>“In short, I suggest that the programmer should continue to understand what he is doing, that his growing product remains firmly within his intellectual grip.”</p>
</blockquote>
<p>Edsger W. Dijkstra</p>
<p>My conclusion is this: it does not really matter if I get stuck and can’t figure it out for a few days. For some problems I will be stuck for much longer.<br />
I am talking about pursuit of a well designed code, not finding a brute-force kludge.<br />
What really matters is not giving up and eventually figuring it out.</p>
<blockquote>
<p>“You must understand, young Hobbit, it takes a long time to say anything in Old Entish. And we never say anything unless it is worth taking a long time to say.”</p>
</blockquote>
<p>J.R.R Tolkien and Treebeard</p>
<p>The original version of this post had bugs.<br />
Yeah, what really matters is not giving up and eventually figuring it out;) I this post I ate my own dog food.</p>

    </section>
</article>
]]></description>
    <pubDate>Sun, 18 Jul 2021 00:00:00 UT</pubDate>
    <guid>https://rpeszek.github.io//posts/2021-07-18-prob-tree-scheme.html</guid>
    <dc:creator>Robert Peszek</dc:creator>
</item>
<item>
    <title>Arming polysemy with Arrows</title>
    <link>https://rpeszek.github.io//posts/2021-06-28-polysemy-arrows.html</link>
    <description><![CDATA[<article>
    <section class="header">
        Posted on June 28, 2021
        
            by Robert Peszek
        
        
          <br /> Last Modified on Jul 04, 2021
        
        
        <div class="changelog"> <div>Revision History: <ul> <li> (2021.07.02) Added Semantic Note in <a href="#creating-arrow-effects">Creating Arrow Effects</a> section </li> <li> (2021.07.02-05) Added <a href="#tweag-workflows">Tweag Workflows</a> section </li> <li> (2021.07.24) Minor changes in <a href="#tweag-workflows">Tweag Workflows</a> section </li> </ul> </div></div>
        
        
        <div class="info">Tags: <a title="All pages tagged 'Haskell'." href="../tags/Haskell.html">Haskell</a></div>
        
    </section>
    <section>

    </section>
    <section>
        <div class="toc"><div class="header">Table of Contents</div>
<ul>
<li><a href="#arrow-effects.-semantics">Arrow Effects. Semantics</a>
<ul>
<li><a href="#tweag-workflows">Tweag Workflows</a></li>
<li><a href="#chris-penners-arrow-idea">Chris Penner’s <del>arr</del>ow idea</a></li>
</ul></li>
<li><a href="#monadic-polysemy-working-example">Monadic polysemy, Working example</a></li>
<li><a href="#semarr-type"><code>SemArr</code> type</a></li>
<li><a href="#consuming-polysemy-effects-using-arrows">Consuming <em>polysemy</em> effects using arrows</a></li>
<li><a href="#arrow-effects.-the-plumbing">Arrow Effects. The Plumbing</a></li>
<li><a href="#creating-arrow-effects">Creating Arrow Effects</a></li>
<li><a href="#creating-nested-effects">Creating Nested Effects</a></li>
<li><a href="#final-thoughts">Final Thoughts</a></li>
</ul>
</div>
<p>Code for this project can be found in my <a href="https://github.com/rpeszek/experiments" target="_blank">experiments</a> github repo (<a href="https://github.com/rpeszek/experiments/tree/master/polysemy-arrows" target="_blank">polysemy-arrows</a> folder).<br />
It is based on <a href="https://hackage.haskell.org/package/polysemy-1.3.0.0" target="_blank"><em>polysemy 1.3.0.0</em></a>.</p>
<p>The goal of this post is to show how to use arrows when working with or creating <em>polysemy</em> effects.</p>
<p><strong>Motivation:</strong> At work I use a proprietary effect system which is based on <a href="https://www.haskell.org/arrows" target="_blank">arrows</a>. I like it quite a bit, but… For something like an effect system, proprietary is not ideal. The effect system has a huge syntactic and semantic impact on the code. IMO it is a worthy goal to try limit the fragmentation of the ecosystem and (in the industrial context) focus on a small set of effect libraries.<br />
This task became my weekend pet project, and I have done some proof of concept work that added arrows to <a href="https://hackage.haskell.org/package/polysemy" target="_blank"><em>polysemy</em></a>. This post summarizes my effort. I believe similar approach can be used with other monadic effect libraries (like <a href="https://hackage.haskell.org/package/fused-effects" target="_blank"><em>fused-effects</em></a>). <em>polysemy</em> seems much closer to the design of the library I use at work, and was my first choice for this proof of concept work.</p>
<p><strong>Nutshell:</strong> There are two reasons for using arrows: syntactic and semantic. This blog, I am afraid, is about the first one. It is mostly about syntax sugar. Polysemy’s <a href="https://hackage.haskell.org/package/polysemy-1.3.0.0/docs/Polysemy.html#t:Sem" target="_blank"><code>Sem r</code></a> Monad instance is unconstrained, and that translates to arrow effects getting the equivalent <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Arrow.html#t:ArrowMonad" target="_blank"><code>ArrowApply</code></a> typeclass instance for free.<br />
The code I am about to present is trivial (at least in the mathematical sense). Monads and arrows loaded with the power of <code>ArrowApply</code> are equivalent. Semantic arrows I am going to implement here are just monads in arrow’s clothing. There is still some coding that needs to happen to implement the transformation and this code is the main subject of this post.</p>
<p>Algebraic effects for arrows <em>that are less expressive</em> (i.e. are not <code>ArrowApply</code> or even <code>ArrowChoice</code>) are meaningfully different and will be briefly discussed in the next section.</p>
<p>The code I write at work uses DSLs with “fully loaded” <code>ArrowApply</code> semantic arrows. We have build a lot of functionality that is directly concerned with inputs and outputs and arrows are a perfect syntactic match for us. DSL expressiveness is also what we want.</p>
<p>My coding goal in this post is to:</p>
<ul>
<li>be able to consume monadic polysemy effects using arrows</li>
<li>write arrow-like effects and consume them in monadic code</li>
</ul>
<p>Another words, a programmer should be able to create monadic effects using arrow effects and vice-versa.<br />
This is largely accomplished by using the <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Arrow.html#t:Kleisli" target="_blank">Control.Arrow.Kleisli</a> type and an effect construction that mimics <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Arrow.html#t:ArrowMonad" target="_blank">Control.Arrow.ArrowMonad</a>.</p>
<p>Many of my coworkers have, at some point, done a presentation or a tutorial about arrows. (<a href="https://www.youtube.com/watch?v=msQiLyExM3w" target="_blank">Jake’s talk</a>, <a href="https://www.youtube.com/watch?v=YqVTCZFPoyQ" target="_blank">Jason’s talk</a>).<br />
I guess this post qualifies as one and, thus, I am joining the club.</p>
<p>This post assumes the reader has at least basic familiarity with the concepts of arrows and algebraic effects.</p>
<h2 id="arrow-effects.-semantics">Arrow Effects. Semantics</h2>
<p>Since this will mostly be a syntax sugar, I need to talk about the semantics … just to add some depth.<br />
In this section I want to explore the realm of theoretical possibilities for what arrow algebraic effects could possibly look like and how they could differ from monadic algebraic effects.</p>
<p>It is interesting to think about arrows from the point of view of code expressiveness. Syntax aside, you can view arrow code as a subset of monadic code. Monadic code is the most expressive, arrows are much more restrictive (<a href="https://www.cl.cam.ac.uk/~jdy22/papers/idioms-are-oblivious-arrows-are-meticulous-monads-are-promiscuous.pdf" target="_blank">Idioms are oblivious, arrows are meticulous, monads are promiscuous</a> by Lindley, Wadler, Yallop). In Haskell, additional <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Arrow.html#t:ArrowChoice" target="_blank"><code>ArrowChoice</code></a> instance is needed to be able to write conditional (<code>if</code> and <code>case</code>) statements, <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Arrow.html#t:ArrowMonad" target="_blank"><code>ArrowApply</code></a> is needed to partially apply things. To focus this fantasy exploration, I want to forget about <code>ArrowChoice</code> and <code>ArrowApply</code> for a moment and consider what arrow effect system would look like for DSLs based on the <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Arrow.html#t:Arrow" target="_blank"><code>Arrow</code></a> typeclass only.</p>
<p>If an arrow code is a subset of a monadic code then monadic handlers (interpreters) have to also work on arrow DSLs. (With some adjustments of course, this is exactly what this post implements.) The question is what kind of other interesting interpreters one could come up with, that wouldn’t work on promiscuous monads but would work on meticulous arrows?</p>
<p>For one, arrow effects should be able to interpret to other interesting arrows. Basically, the handler (defined as the final interpreter / compilation target) should be able live outside of the standard (monadic) function space. There are examples of open source code out there that make steps in this direction. One example is tweag’s <a href="https://hackage.haskell.org/package/funflow-1.3.2/docs/Control-Arrow-Free.html" target="_blank">funflow</a>.</p>
<p>That sounds interesting but it is good to see a more practical benefit. To do that let’s think about what it means to have lack of conditional statements.</p>
<p>A great reading (somewhat on a theoretical side) is the Lindley’s paper <a href="https://homepages.inf.ed.ac.uk/slindley/papers/aeia.pdf" target="_blank">Algebraic Effects and Effect Handlers for Idioms and Arrows</a>.</p>
<p>Lindley uses the terms <em>static control flow</em> and <em>dynamic control flow</em>. Arrows allow for <em>static control flow</em> only.</p>
<p>Consider this monadic code:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>countTo10 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>  i <span class="ot">&lt;-</span> get</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>  <span class="kw">if</span> i <span class="op">&lt;</span> <span class="dv">10</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>  <span class="kw">then</span> put (i <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>  <span class="kw">else</span> <span class="fu">pure</span> ()</span></code></pre></div>
<p>that uses some <em>State</em> effect and increments it until it reaches 10.<br />
This code uses dynamic control flow (<code>if</code>-s on the result of the previous computation) and cannot be implemented with plain arrows.</p>
<p>This leads to the following 2 interesting observations:</p>
<ul>
<li>Arrow effects need to be more precise</li>
<li>Arrow effect handlers could conceivably do crazy stuff</li>
</ul>
<p><strong>Arrow Effects need to be more precise:</strong><br />
Monadic effect algebra GADT for <em>State</em> is likely to look like this (actually copied it from polysemy):</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">State</span> s m a <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>  <span class="dt">Get</span><span class="ot"> ::</span> <span class="dt">State</span> s m s</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>  <span class="dt">Put</span><span class="ot"> ::</span> s <span class="ot">-&gt;</span> <span class="dt">State</span> s m ()</span></code></pre></div>
<p>to implement <code>countTo10</code> without conditional statements I need more precise instructions! For example, I could add:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>  <span class="dt">Modify</span><span class="ot"> ::</span> (s <span class="ot">-&gt;</span> s) <span class="ot">-&gt;</span> <span class="dt">State</span> s m ()</span></code></pre></div>
<p>This forced precision could be perceived as a benefit in some situations. It gives more power to the interpreter to do different things when interpreting <code>Modify</code> than just <code>Get</code>/<code>Put</code> (for example, do something that is more performant or use different log messages).</p>
<p><strong>Arrow effect handlers could conceivably do crazy stuff:</strong><br />
Static control flow makes for a much more predictable syntax tree. In an example mentioned in the above paper, the interpreter statically infers when the <code>put</code> operation is used and when is not!<br />
Again, this translates to more power given to the interpreters, no <code>put</code>-s could, for example, mean a more aggressive optimization that somehow caches the state…</p>
<h3 id="tweag-workflows">Tweag Workflows</h3>
<p><em>u/Ywen</em> pointed out to me <a href="https://www.reddit.com/r/haskell/comments/o9y7re/arming_polysemy_with_arrows/h3oru2a?utm_source=share&amp;utm_medium=web2x&amp;context=3" target="_blank">here</a> that I missed a very cool presentation in the last ICFP, and indeed I did!<br />
References: <a href="https://richarde.dev/papers/2020/workflows/workflows.pdf" target="_blank">Composing Effects into Tasks and Workflows</a> by Parès, Bernardy, and Eisenberg; <a href="https://github.com/tweag/kernmantle" target="_blank"><em>kernmantle</em></a> effects library; here it is on <a href="https://www.youtube.com/watch?v=AiHOBF3BiLY&amp;t=834s" target="_blank">youtube</a>.</p>
<p>The paper is about creating data science workflow pipelines that decouple two runtime phases: config-time and process-time. This allows for fail-early benefits (if config-time effects fail).</p>
<p>This approach uses an arrow (without <em>ArrowApply</em> and with optional (opt-in) <em>ArrowChoice</em>) DSL that contains both applicative (config-phase) effects that do not depend on the result of previous computation and monadic (process-time) effects that do. The effect algebra GADTs separately define parameters that the DSL <em>has to provide statically</em> and parameters that can be used in dynamic arrow invocation. Thus, the interpreters have more power to infer information about the statically used configuration. This allows interpreters to perform config-time checks, for example, if some statically specified model training data file exists and fail early if it does not, interpreters can pre-download needed artifacts at the config-time, etc.</p>
<p>The presentation (see the youtube link) also shows a general <code>ArrowFromEffects</code> arrow type that generalizes <code>Kleisli</code>, <a href="https://hackage.haskell.org/package/comonad-5.0.8/docs/Control-Comonad.html#t:Cokleisli" target="_blank"><code>Cokleisli</code></a> (from <em>comondad</em>), and <a href="https://hackage.haskell.org/package/profunctors-5.6.2/docs/Data-Profunctor-Cayley.html" target="_blank"><code>Cayley</code></a> (from <em>profunctors</em>). <code>Cayley</code> plays an important role in <em>kernmantle</em>. As the interpretation target, it allows for isolating: the process-time computation and the config-time computation that can be used to analyze program configuration without running it.</p>
<p>The ideas in the paper apply well beyond data-science workflows. I am still in the process of absorbing this paper and code.</p>
<p>Separation between static and dynamic data is impossible when using monadic / ArrowApply computations. I will discuss this a little bit more in the <a href="#creating-arrow-effects">Creating Arrow Effects</a> section of this post.</p>
<h3 id="chris-penners-arrow-idea">Chris Penner’s <del>arr</del>ow idea</h3>
<p>A very interesting <a href="https://www.youtube.com/channel/UCNp-DVb8cQRIOo32sZhWgNg" target="_blank">Berlin’s FP Group</a> presentation by Chris Penner <a href="https://www.youtube.com/watch?v=xZmPuz9m2t0" target="_blank">Deconstructing Lambdas—An Awkward Guide to Programming Without Functions</a> envisions a world with something <code>Arrow</code>-like that does not have the <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Arrow.html#v:arr" target="_blank"><code>arr</code></a>.<br />
From a DSLs prospective, <code>Arrow</code>’s <code>arr</code> translates to the ability to use any Haskell <code>a -&gt; b</code> function inside the DSL.<br />
Removing this ability is very interesting. It is also a hard stop when trying to reuse any monadic effects library.</p>
<p>It seems that Chris Penner’s vision could be implemented with some Arrow-Minus like construction that cares about inputs and outputs and algebraic effect system that will be completely divorced from monadic effects.</p>
<p><strong>The point</strong> I tried to make in this section is that Arrow-like effect systems that are not convertible to monadic effects are very interesting and semantically important. The rest of this post is about interpreting arrows using polysemy and is more a syntax sugar thing.</p>
<p>Now back to <em>polysemy</em> and monads:</p>
<h2 id="monadic-polysemy-working-example">Monadic polysemy, Working example</h2>
<p>I will use the classic <code>Teletype</code> effect as my driving example. This is taken (almost) straight from the polysemy’s github readme:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Teletype</span> m a <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>  <span class="dt">ReadTTY</span><span class="ot">  ::</span> <span class="dt">Teletype</span> m <span class="dt">String</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>  <span class="dt">WriteTTY</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Teletype</span> m ()</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>makeSem '<span class="dt">'Teletype</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a><span class="ot">echo ::</span> <span class="dt">Member</span> <span class="dt">Teletype</span> r <span class="ot">=&gt;</span> <span class="dt">Sem</span> r ()</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>echo <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>  i <span class="ot">&lt;-</span> readTTY</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>  <span class="kw">case</span> i <span class="kw">of</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a>    <span class="st">&quot;&quot;</span> <span class="ot">-&gt;</span> writeTTY <span class="st">&quot;Need some input&quot;</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a>    _  <span class="ot">-&gt;</span> writeTTY <span class="op">$</span> <span class="st">&quot;You said &quot;</span> <span class="op">&lt;&gt;</span> i</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a><span class="co">-- * interpreters</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a><span class="ot">teletypeToIO ::</span> <span class="dt">Member</span> (<span class="dt">Embed</span> <span class="dt">IO</span>) r <span class="ot">=&gt;</span> <span class="dt">Sem</span> (<span class="dt">Teletype</span> '<span class="op">:</span> r) a <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a>teletypeToIO <span class="ot">=</span> interpret \<span class="kw">case</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a>  <span class="dt">ReadTTY</span>      <span class="ot">-&gt;</span> embed <span class="fu">getLine</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true"></a>  <span class="dt">WriteTTY</span> msg <span class="ot">-&gt;</span> embed <span class="op">$</span> <span class="fu">putStrLn</span> msg</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true"></a></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true"></a><span class="ot">interpreter ::</span> r <span class="op">~</span> '[<span class="dt">Teletype</span>, <span class="dt">Embed</span> <span class="dt">IO</span>] <span class="ot">=&gt;</span> <span class="dt">Sem</span> r a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true"></a>interpreter <span class="ot">=</span> runM <span class="op">.</span> teletypeToIO</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true"></a></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true"></a><span class="ot">test ::</span> <span class="dt">IO</span> ()</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true"></a>test <span class="ot">=</span> interpreter echo</span></code></pre></div>
<p>I have spelled out the effect stack in the type signature of the <code>interpreter</code> combinator to add the clarity. I will do that in following examples as well. Compiler can infer these and typical <em>polysemy</em> examples do not list the complete effect list.<br />
The goal is to replace monadic computations with arrows.</p>
<h2 id="semarr-type"><code>SemArr</code> type</h2>
<p>Let me introduce our semantic arrow type:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Control.Arrow</span> <span class="kw">as</span> <span class="dt">Arr</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a><span class="co">-- | Semantic arrows in polysemy</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">SemArr</span> r a b <span class="ot">=</span> <span class="dt">Arr.Kleisli</span> (<span class="dt">Sem</span> r) a b</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a><span class="co">-- | Used to define atomic effect arrows</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a><span class="ot">constSemArr ::</span> (<span class="dt">Sem</span> r) b <span class="ot">-&gt;</span> <span class="dt">SemArr</span> r () b</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>constSemArr c <span class="ot">=</span> <span class="dt">Arr.Kleisli</span> (<span class="fu">const</span> c)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a><span class="co">-- | Used to define atomic effect arrows</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a><span class="ot">semArr ::</span> (a <span class="ot">-&gt;</span> (<span class="dt">Sem</span> r) b)<span class="ot">-&gt;</span> <span class="dt">SemArr</span> r a b</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a>semArr <span class="ot">=</span> <span class="dt">Arr.Kleisli</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true"></a><span class="co">-- | transforms @Sem@ compilation stacks to @SemArr@ compilation stacks.</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true"></a><span class="ot">semArrCompl ::</span> (<span class="dt">Sem</span> r1 b1 <span class="ot">-&gt;</span> <span class="dt">Sem</span> r2 b2) <span class="ot">-&gt;</span> <span class="dt">SemArr</span> r1 a b1 <span class="ot">-&gt;</span> <span class="dt">SemArr</span> r2 a b2 </span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true"></a>semArrCompl comp (<span class="dt">Arr.Kleisli</span> fn) <span class="ot">=</span> <span class="dt">Arr.Kleisli</span> (comp <span class="op">.</span> fn)</span></code></pre></div>
<p><code>Kleisli m a b</code> wraps <code>a -&gt; m b</code> function and is the standard way to express monadic computations as arrows.</p>
<p>It is probably obvious, but it is good to remember that <code>Kleisli</code> is just a type and it does not imply monad payload by itself. In particular, it has these instances:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Functor</span> m <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">Kleisli</span> m a)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">Kleisli</span> m a)</span></code></pre></div>
<p><code>SemArr r a b</code> comes fully loaded with all <code>Arrow</code> typeclass instances (like <code>ArrowApply</code>) because <code>(Sem r)</code> has the unconstrained <code>Monad</code> instance:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">Sem</span> f)</span></code></pre></div>
<p><code>SemArr r a b</code> is a monad in arrow’s clothing.</p>
<h2 id="consuming-polysemy-effects-using-arrows">Consuming <em>polysemy</em> effects using arrows</h2>
<p>This is section will not be interesting. We can tranform monads to arrows using Kleisli, duh:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="ot">readTTYA ::</span> <span class="kw">forall</span> (<span class="ot">r ::</span> [<span class="dt">Effect</span>])<span class="op">.</span> <span class="dt">MemberWithError</span> <span class="dt">Teletype</span> r <span class="ot">=&gt;</span> <span class="dt">SemArr</span> r () <span class="dt">String</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>readTTYA <span class="ot">=</span> constSemArr readTTY</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a><span class="ot">writeTTYA ::</span> <span class="kw">forall</span> (<span class="ot">r ::</span> [<span class="dt">Effect</span>])<span class="op">.</span> <span class="dt">MemberWithError</span> <span class="dt">Teletype</span> r <span class="ot">=&gt;</span> <span class="dt">SemArr</span> r <span class="dt">String</span> ()</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>writeTTYA <span class="ot">=</span> semArr writeTTY</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a><span class="ot">echoA ::</span> <span class="dt">Member</span> <span class="dt">Teletype</span> r <span class="ot">=&gt;</span> <span class="dt">SemArr</span> r () ()</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a>echoA <span class="ot">=</span> proc _ <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a>    i <span class="ot">&lt;-</span> readTTYA <span class="op">-&lt;</span> ()</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a>    <span class="kw">case</span> i <span class="kw">of</span> </span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a>       <span class="st">&quot;&quot;</span> <span class="ot">-&gt;</span> </span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true"></a>           writeTTYA <span class="op">-&lt;</span> <span class="st">&quot;Need some input&quot;</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true"></a>       _ <span class="ot">-&gt;</span>  </span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true"></a>           writeTTYA <span class="op">-&lt;</span> <span class="st">&quot;You said &quot;</span> <span class="op">&lt;&gt;</span> i</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true"></a></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true"></a><span class="co">-- Notice interpreter is input - output based, the last bit @a -&gt; IO b@ is effectively Kleisli arrow</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true"></a></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true"></a><span class="ot">interpreter ::</span>  r <span class="op">~</span> '[<span class="dt">Teletype</span>, <span class="dt">Embed</span> <span class="dt">IO</span>] <span class="ot">=&gt;</span> <span class="dt">SemArr</span> r a b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> b</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true"></a>interpreter arr a <span class="ot">=</span> runM <span class="op">.</span> teletypeToIO <span class="op">$</span> Arr.runKleisli arr a</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true"></a></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true"></a><span class="ot">testA ::</span> <span class="dt">IO</span> ()</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true"></a>testA <span class="ot">=</span> interpreter echoA ()</span></code></pre></div>
<p><code>readTTYA</code> and <code>writeTTYA</code> are arrow-ised versions of the monadic <code>readTTY</code> and <code>writeTTY</code> primitives.</p>
<p>Notice the change in the type signature for <code>interpreter</code>. <code>interpreter</code> now threads the input data into the computation and spells out the output at the end. You can also view it as compiling the <code>SemArr r a b</code> arrow down to <code>Kleisli IO a b</code> (only with <code>Kleisli</code> unwrapped for extra convenience).</p>
<p>Let’s move onto some more interesting stuff:</p>
<h2 id="arrow-effects.-the-plumbing">Arrow Effects. The Plumbing</h2>
<p>One of the syntactic advantages of using arrow effects, at least for me, is the simplified construction of the effect algebra GADT. This definition nicely spells out the input and the output:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Teletype2</span> a b <span class="kw">where</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>  <span class="dt">ReadTTY2</span><span class="ot">  ::</span> <span class="dt">Teletype2</span> () <span class="dt">String</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>  <span class="dt">WriteTTY2</span><span class="ot"> ::</span> <span class="dt">Teletype2</span> <span class="dt">String</span> ()</span></code></pre></div>
<p>I want to be able to add <code>Teletype2</code> to the list of polysemy effects. This needs some plumbing:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Eff2</span> arr r b <span class="kw">where</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>  <span class="dt">MkEff2</span><span class="ot"> ::</span> arr () b <span class="ot">-&gt;</span> <span class="dt">Eff2</span> arr r b</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a><span class="ot">interpretEff2 ::</span> (<span class="kw">forall</span> x <span class="op">.</span> m x <span class="ot">-&gt;</span> <span class="dt">Sem</span> r x) <span class="ot">-&gt;</span> (<span class="kw">forall</span> x y <span class="op">.</span> arr x y <span class="ot">-&gt;</span>  <span class="dt">Arr.Kleisli</span> m x y) <span class="ot">-&gt;</span> <span class="dt">Sem</span> (<span class="dt">Eff2</span> arr '<span class="op">:</span> r) a <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>interpretEff2 comp fn <span class="ot">=</span> interpret \<span class="kw">case</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>  <span class="dt">MkEff2</span> arr   <span class="ot">-&gt;</span> comp (Arr.runKleisli (fn arr) ())</span></code></pre></div>
<p><code>MkEff2</code> is the bit which mimics <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Arrow.html#t:ArrowMonad" target="_blank">Control.Arrow.ArrowMonad</a>! This trick is based on the fact <code>B = B ^ 1</code>: one can represent elements in a set <code>B</code> by using fuctions from a one element set (here <code>()</code>) ending in <code>B</code> that pick that element. That observation nicely generalizes to categorical constructions that use terminal objects and this principled idea works great for what I need.</p>
<p><code>interpretEff2</code> is actually quite powerful. It allows me to implement an equivalent to polysemy’s <code>embed</code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="ot">embedEff2 ::</span> <span class="dt">Member</span> (<span class="dt">Embed</span> m) r <span class="ot">=&gt;</span> (<span class="kw">forall</span> x y <span class="op">.</span> arr x y <span class="ot">-&gt;</span>  <span class="dt">Arr.Kleisli</span> m x y) <span class="ot">-&gt;</span> <span class="dt">Sem</span> (<span class="dt">Eff2</span> arr '<span class="op">:</span> r) a <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>embedEff2 <span class="ot">=</span> interpretEff2 embed</span></code></pre></div>
<p>it will also allow me to reinterpret an arrow effect using other (possibly arrow) effects. We will see it again in the <a href="#effects-based-on-arrow-effects">Nested Effects</a> section.</p>
<p>However, there is a clear problem with what we have so far: <code>arr () b</code> in the definition of <code>Eff2</code> does not match with the <code>WriteTTY2</code> constructor. We need to embed <code>WriteTTY2</code> in a bigger instruction set that has enough expressiveness to be able use the above <code>() -&gt;</code> trick. To do that I will do the following, minimalist, free construction:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Eff2Free</span> eff a b <span class="kw">where</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>  <span class="dt">Pure</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Eff2Free</span> eff a b</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>  <span class="dt">Effect</span><span class="ot"> ::</span> eff a b <span class="ot">-&gt;</span> <span class="dt">Eff2Free</span> eff a b</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>  <span class="dt">Seq</span><span class="ot"> ::</span> <span class="dt">Eff2Free</span> eff a b <span class="ot">-&gt;</span> <span class="dt">Eff2Free</span> eff b c <span class="ot">-&gt;</span> <span class="dt">Eff2Free</span> eff a c</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Category</span> (<span class="dt">Eff2Free</span> eff) <span class="kw">where</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a>  <span class="fu">id</span> <span class="ot">=</span> <span class="dt">Pure</span> Cat.id</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a>  (<span class="op">.</span>) <span class="ot">=</span> <span class="fu">flip</span> <span class="dt">Seq</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true"></a><span class="ot">liftCompKl ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (<span class="kw">forall</span> x y <span class="op">.</span> eff x y <span class="ot">-&gt;</span>  <span class="dt">Arr.Kleisli</span> m x y) <span class="ot">-&gt;</span> <span class="dt">Eff2Free</span> eff a b <span class="ot">-&gt;</span> <span class="dt">Arr.Kleisli</span> m a b</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true"></a>liftCompKl _ (<span class="dt">Pure</span> f) <span class="ot">=</span>  <span class="dt">Arr.Kleisli</span> (<span class="fu">pure</span> <span class="op">Cat..</span> f)</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true"></a>liftCompKl fn (<span class="dt">Effect</span> eff) <span class="ot">=</span> fn eff</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true"></a>liftCompKl fn (<span class="dt">Seq</span> a1 a2) <span class="ot">=</span> liftCompKl fn a1 <span class="op">&gt;&gt;&gt;</span> liftCompKl fn a2</span></code></pre></div>
<p>Combining <code>Eff2</code> with <code>Eff2Free</code> is what I need to move forward.</p>
<p><code>liftCompKl</code> allows me to expand <code>Kleisli</code> encoding of <code>Teletype2</code> to the mini-DSL: <code>Eff2Free Teletype2</code>.</p>
<p><strong>Semantic Note:</strong> When I started working on this, I assumed my <code>Eff2Free</code> will be a free construction of the <code>Arrow</code>, and possibly <code>ArrowChoice</code> or even <code>ArrowApply</code>. This ended up being much more minimalist, we get arrows for free from using <code>SemArr r a b</code>.</p>
<p>What is really needed, is the ability to pre-compose mapped (i.e. <code>Pure</code>) functions with the lifted effect. This free construction needs only to be compatible with the <code>Contravariant</code> Functor (or <code>Profunctor</code> <code>lmap</code>) and there should be some flexibility of how it is done.</p>
<h2 id="creating-arrow-effects">Creating Arrow Effects</h2>
<p>Here is the whole program that uses an Arrow-like effect algebra, arrow instruction primitives, and a DSL program that uses arrows:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Teletype2</span> a b <span class="kw">where</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>  <span class="dt">ReadTTY2</span><span class="ot">  ::</span> <span class="dt">Teletype2</span> () <span class="dt">String</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>  <span class="dt">WriteTTY2</span><span class="ot"> ::</span> <span class="dt">Teletype2</span> <span class="dt">String</span> ()</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a><span class="co">-- type Effect2 arr r b = Eff2 (Eff2Free arr) r b</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a><span class="co">-- | arrow frienly combinator</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a><span class="ot">readTTY2A ::</span> <span class="kw">forall</span> (<span class="ot">r ::</span> [<span class="dt">Effect</span>])<span class="op">.</span> <span class="dt">Member</span> (<span class="dt">Eff2</span> (<span class="dt">Eff2Free</span> <span class="dt">Teletype2</span>)) r <span class="ot">=&gt;</span> <span class="dt">SemArr</span> r () <span class="dt">String</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a>readTTY2A <span class="ot">=</span>  constSemArr readTTY2</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a><span class="co">-- | monad frienly combinator, can be consumed by monadic programs and effects</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true"></a><span class="ot">readTTY2 ::</span> <span class="kw">forall</span> (<span class="ot">r ::</span> [<span class="dt">Effect</span>])<span class="op">.</span> <span class="dt">Member</span> (<span class="dt">Eff2</span> (<span class="dt">Eff2Free</span> <span class="dt">Teletype2</span>)) r <span class="ot">=&gt;</span> <span class="dt">Sem</span> r <span class="dt">String</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true"></a>readTTY2 <span class="ot">=</span> send (<span class="dt">MkEff2</span> (<span class="dt">Effect</span> <span class="dt">ReadTTY2</span>)) </span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true"></a></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true"></a><span class="ot">writeTTY2A ::</span> <span class="kw">forall</span> (<span class="ot">r ::</span> [<span class="dt">Effect</span>])<span class="op">.</span> <span class="dt">Member</span> (<span class="dt">Eff2</span> (<span class="dt">Eff2Free</span> <span class="dt">Teletype2</span>)) r <span class="ot">=&gt;</span> <span class="dt">SemArr</span> r <span class="dt">String</span> ()</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true"></a>writeTTY2A <span class="ot">=</span> semArr writeTTY2</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true"></a></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true"></a><span class="co">-- | mini-DLS @Eff2Free Teletype2@ allows me to encode input paramter to the @WriteTTY2@ instruction</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true"></a><span class="ot">writeTTY2 ::</span> <span class="kw">forall</span> (<span class="ot">r ::</span> [<span class="dt">Effect</span>])<span class="op">.</span> <span class="dt">Member</span> (<span class="dt">Eff2</span> (<span class="dt">Eff2Free</span> <span class="dt">Teletype2</span>)) r <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Sem</span> r ()</span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true"></a>writeTTY2 s <span class="ot">=</span> send (<span class="dt">MkEff2</span> (<span class="dt">Pure</span> (<span class="fu">const</span> s) <span class="op">&gt;&gt;&gt;</span> <span class="dt">Effect</span> <span class="dt">WriteTTY2</span>)) </span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true"></a></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true"></a><span class="ot">echo2A ::</span> <span class="dt">Member</span> (<span class="dt">Eff2</span> (<span class="dt">Eff2Free</span> <span class="dt">Teletype2</span>)) r <span class="ot">=&gt;</span> <span class="dt">SemArr</span> r () ()</span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true"></a>echo2A <span class="ot">=</span> proc _ <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true"></a>    i <span class="ot">&lt;-</span> readTTY2A <span class="op">-&lt;</span> ()</span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true"></a>    <span class="kw">case</span> i <span class="kw">of</span> </span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true"></a>       <span class="st">&quot;&quot;</span> <span class="ot">-&gt;</span> </span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true"></a>           writeTTY2A <span class="op">-&lt;</span> <span class="st">&quot;Need some input&quot;</span></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true"></a>       _ <span class="ot">-&gt;</span>  </span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true"></a>           writeTTY2A <span class="op">-&lt;</span> <span class="st">&quot;You said &quot;</span> <span class="op">&lt;&gt;</span> i</span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true"></a></span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true"></a><span class="co">-- * interpreters</span></span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true"></a></span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true"></a><span class="co">-- | Teletype2 instructions are interpreted as Kleisli</span></span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true"></a><span class="ot">tele2ToKlIO ::</span> <span class="dt">Teletype2</span> a b <span class="ot">-&gt;</span> <span class="dt">Arr.Kleisli</span> <span class="dt">IO</span> a b</span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true"></a>tele2ToKlIO <span class="dt">ReadTTY2</span> <span class="ot">=</span> <span class="dt">Arr.Kleisli</span> <span class="op">$</span> <span class="fu">const</span> <span class="fu">getLine</span></span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true"></a>tele2ToKlIO <span class="dt">WriteTTY2</span> <span class="ot">=</span> <span class="dt">Arr.Kleisli</span> <span class="fu">putStrLn</span></span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true"></a></span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true"></a><span class="co">-- | tele2ToKlIO is extended to the the mini-DLS @Eff2Free Teletype2@</span></span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true"></a><span class="ot">interpreter ::</span>  r <span class="op">~</span> '[<span class="dt">Eff2</span> (<span class="dt">Eff2Free</span> <span class="dt">Teletype2</span>), <span class="dt">Embed</span> <span class="dt">IO</span>] <span class="ot">=&gt;</span> <span class="dt">SemArr</span> r a b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> b</span>
<span id="cb13-39"><a href="#cb13-39" aria-hidden="true"></a>interpreter arr a <span class="ot">=</span> runM <span class="op">.</span> embedEff2 (liftCompKl tele2ToKlIO)  <span class="op">$</span> Arr.runKleisli arr a</span>
<span id="cb13-40"><a href="#cb13-40" aria-hidden="true"></a></span>
<span id="cb13-41"><a href="#cb13-41" aria-hidden="true"></a><span class="ot">testA2 ::</span> <span class="dt">IO</span> ()</span>
<span id="cb13-42"><a href="#cb13-42" aria-hidden="true"></a>testA2 <span class="ot">=</span> interpreter echo2A ()</span></code></pre></div>
<ul>
<li><code>readTTY2</code> and <code>writeTTY2</code> primitives can be used by any monadic polysemy code to create new effects or to use in programs where effect the <code>Eff2 (Eff2Free Teletype2)</code> is available.</li>
<li><code>readTTY2A</code> and <code>writeTTY2A</code> are available for any arrow code. In particular, these can be used to create new arrow effects that compile down to <code>Eff2 (Eff2Free Teletype2)</code>.</li>
</ul>
<p><strong>Semantic Note:</strong> Notice that, when defining monadic version of <code>Teletype</code> GADT, we used value level <code>String</code> in the <code>WriteTTY</code> constructor, now the <code>String</code> input is defined squarely on the type level.<br />
We could consider defining <code>WriteTTY2</code> as <code>WriteTTY2 :: String -&gt; Teletype2 () ()</code> instead.<br />
This would yield <code>String -&gt; SemArr r () ()</code> type for the above <code>writeTTY2A</code>. In the expressive world of <em>monads</em> / <em>ArrowApply</em> both constructions are largely equivalent. Not so in the more restrictive universe of general arrows we discussed in the <a href="#arrow-effects.-semantics">Semantics</a> section.<br />
The new construction would allow a more static handling of the <code>String</code> parameter by the interpreter but the <code>String</code> parameter would not be available for dynamic use at the DSL level. We would not be able to write the above <code>echo2A</code> program. A code example of this is provided in the included repo <a href="https://github.com/rpeszek/experiments/blob/05e23cdca5766b947b731d9084bdfe96c7bcbaae/polysemy-arrows/src/Teletype2B.hs" target="_blank">here</a></p>
<p>Implementing arrow effects on top of other arrows effects seems to be the most interesting case of nesting and is shown next:</p>
<h2 id="creating-nested-effects">Creating Nested Effects</h2>
<p><code>DoEcho2</code> instruction has a non-unit input and output making it more interesting. We will interpret it down to <code>Teletype2</code> effect by writing its input, reading a new input and returning it as the result.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Echoer2</span> a b <span class="kw">where</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>  <span class="dt">DoEcho2</span><span class="ot"> ::</span> <span class="dt">Echoer2</span> <span class="dt">String</span> <span class="dt">String</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a><span class="ot">doEcho2 ::</span> <span class="kw">forall</span> (<span class="ot">r ::</span> [<span class="dt">Effect</span>])<span class="op">.</span> <span class="dt">Member</span> (<span class="dt">Eff2</span> (<span class="dt">Eff2Free</span> <span class="dt">Echoer2</span>)) r <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Sem</span> r <span class="dt">String</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>doEcho2 s <span class="ot">=</span> send (<span class="dt">MkEff2</span> (<span class="dt">Pure</span> (<span class="fu">const</span> s) <span class="op">&gt;&gt;&gt;</span> <span class="dt">Effect</span> <span class="dt">DoEcho2</span>)) </span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a><span class="ot">doEcho2A ::</span> <span class="kw">forall</span> (<span class="ot">r ::</span> [<span class="dt">Effect</span>])<span class="op">.</span> <span class="dt">Member</span> (<span class="dt">Eff2</span> (<span class="dt">Eff2Free</span> <span class="dt">Echoer2</span>)) r <span class="ot">=&gt;</span> <span class="dt">SemArr</span> r <span class="dt">String</span> <span class="dt">String</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true"></a>doEcho2A <span class="ot">=</span> semArr doEcho2 </span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true"></a></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true"></a><span class="co">-- | nice use of arrows to create complex effects</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true"></a><span class="ot">echoer2ToKl ::</span> <span class="dt">Member</span> (<span class="dt">Eff2</span> (<span class="dt">Eff2Free</span> <span class="dt">Teletype2</span>)) r <span class="ot">=&gt;</span> <span class="dt">Echoer2</span> a b <span class="ot">-&gt;</span> <span class="dt">Arr.Kleisli</span> (<span class="dt">Sem</span> r) a b</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true"></a>echoer2ToKl <span class="dt">DoEcho2</span> <span class="ot">=</span> proc inp <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true"></a>  _ <span class="ot">&lt;-</span> writeTTY2A <span class="op">-&lt;</span> inp</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true"></a>  txt <span class="ot">&lt;-</span> readTTY2A <span class="op">-&lt;</span> ()</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true"></a>  <span class="kw">if</span> txt <span class="op">==</span> <span class="st">&quot;&quot;</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true"></a>  <span class="kw">then</span> arr <span class="fu">id</span> <span class="op">-&lt;</span> <span class="st">&quot;No Input&quot;</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true"></a>  <span class="kw">else</span> arr <span class="fu">id</span> <span class="op">-&lt;</span> <span class="st">&quot;You said &quot;</span> <span class="op">&lt;&gt;</span> txt</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true"></a></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true"></a><span class="co">-- | interpretEff2 allows to intepret down the effect</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true"></a><span class="ot">echoer2ToTeletype2 ::</span> <span class="kw">forall</span> r a <span class="op">.</span> <span class="dt">Member</span> (<span class="dt">Eff2</span> (<span class="dt">Eff2Free</span> <span class="dt">Teletype2</span>)) r <span class="ot">=&gt;</span> <span class="dt">Sem</span> (<span class="dt">Eff2</span> (<span class="dt">Eff2Free</span> <span class="dt">Echoer2</span>) '<span class="op">:</span> r) a <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true"></a>echoer2ToTeletype2 <span class="ot">=</span> interpretEff2 <span class="fu">id</span> (liftCompKl <span class="op">@</span> (<span class="dt">Sem</span> r) echoer2ToKl)</span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true"></a></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true"></a><span class="ot">interpreter ::</span>  r <span class="op">~</span> '[<span class="dt">Eff2</span> (<span class="dt">Eff2Free</span> <span class="dt">Echoer2</span>), <span class="dt">Eff2</span> (<span class="dt">Eff2Free</span> <span class="dt">Teletype2</span>), <span class="dt">Embed</span> <span class="dt">IO</span>] <span class="ot">=&gt;</span> <span class="dt">SemArr</span> r a b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> b</span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true"></a>interpreter arr a <span class="ot">=</span> runM <span class="op">.</span> embedEff2 (liftCompKl tele2ToKlIO) <span class="op">.</span> echoer2ToTeletype2 <span class="op">$</span> Arr.runKleisli arr a</span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true"></a></span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true"></a><span class="ot">testEchoerA ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">String</span></span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true"></a>testEchoerA  <span class="ot">=</span> interpreter (doEcho2A <span class="op">&gt;&gt;&gt;</span> doEcho2A) </span></code></pre></div>
<p><code>echoer2ToKl</code> plays the role of an interpreter for the effect algebra. It is implemented using arrows!<br />
The <code>interpretEff2</code> combinator (defined in the <a href="#arrow-effects-the-plumbing">plumbing</a> section) returns an interpreter that <em>polysemy</em> understands.<br />
Again, I view <code>interpreter</code> as a natural transformation between <code>SemArr r a b</code> arrow and <code>Kelisly IO a b</code> arrow (ignoring the <code>runKleisli</code> unwrapping).</p>
<p>We have a two way street to writing compilation stacks:</p>
<ul>
<li>compose <code>Sem r</code> interpreters that remove effects from the <code>r</code> record and compile <code>Sem r1 a</code> monadic computation to a simpler monadic computation <code>Sem r2 a</code> (the standard <em>polysemy</em>’s approach)</li>
<li>compose <code>SemArr r</code> interpreters that compile <code>SemArr r1 a b</code> arrow to a simpler <code>SemArr r2 a b</code> arrow.</li>
</ul>
<p>or mixing both ways. These options are all possible (my git repo has the necessary combinators).</p>
<h2 id="final-thoughts">Final Thoughts</h2>
<p>We have accomplished the goal. We can program <em>polysemy</em> effects by using interchangeably both the monadic and the arrow syntax.</p>
<p>This seems to be an interesting engineering problem: effective refactoring methods for swapping effect systems.<br />
The task of refactoring a large code base to change its effect library will not be easy and I am not even sure it will be attempted.<br />
The differences are not just in the use of arrows vs monads. The effects are declared polymorphically in both cases but in very different ways. The collections of the base (batteries included) effects has subtle differences. There are subtle but important differences in error handling …<br />
It will require much more footwork to be able to do it piece by piece.</p>
<p>The <code>Eff2</code> / <code>Eff2Free</code> tooling is not really arrow specific. I believe, it could be used with other things. That is the reason behind the names (for not using something like <code>EffArr</code>). However, whatever you come up with (e.g. a free Profunctor construction) this will be just dressing a monad in some other clothing - it will be syntactic only. The <code>Arrow</code> seems to be the only meaningful exception, because it comes with the syntax extension (the Arrows pragma).</p>
<p>This was all very much a quick prototype. I am sure the presented code can be improved in many ways. I hope it was good enough to allow for an interesting reading.</p>

    </section>
</article>
]]></description>
    <pubDate>Mon, 28 Jun 2021 00:00:00 UT</pubDate>
    <guid>https://rpeszek.github.io//posts/2021-06-28-polysemy-arrows.html</guid>
    <dc:creator>Robert Peszek</dc:creator>
</item>
<item>
    <title>Is Alternative a Wrong Abstraction for Handling Failures?</title>
    <link>https://rpeszek.github.io//posts/2021-02-13-alternative.html</link>
    <description><![CDATA[<article>
    <section class="header">
        Posted on February 13, 2021
        
            by Robert Peszek
        
        
          <br /> Last Modified on February 17, 2021
        
        
        <div class="changelog"> <div>Revision History: <ul> <li> (2021.02.13) Edited <a href="#pessimistic-instances">Pessimistic Instances</a> top section</li> <li> (2021.02.14) <a href="#pessimists-intro-to-alternative">Intro</a> adds a clarification paragraph linking failures to instances (prompted by reddit), <a href="#nutshell">Nutshell</a> clearly lists goals </li> <li> (2021.02.15-16) Added <a href="#readers-response">Reader's Response</a> section</li> <li> (2021.02.16) Laws&colon; clarified some text</li> <li> (2021.02.17) <a href="#rethinking-the-typeclass-itself">Rethinking</a> section reworded a little</li> </ul> </div></div>
        
        
        <div class="info">Tags: <a title="All pages tagged 'Haskell'." href="../tags/Haskell.html">Haskell</a>, <a title="All pages tagged 'error-messages'." href="../tags/error-messages.html">error-messages</a>, <a title="All pages tagged 'maintainability'." href="../tags/maintainability.html">maintainability</a>, <a title="All pages tagged 'correctness'." href="../tags/correctness.html">correctness</a></div>
        
    </section>
    <section>

    </section>
    <section>
        <div class="toc"><div class="header">Table of Contents</div>
<ul>
<li><a href="#nutshell">Nutshell</a></li>
<li><a href="#pessimists-intro-to-alternative">Pessimist’s Intro to <code>Alternative</code></a></li>
<li><a href="#alternative-laws-pessimistically">Alternative Laws, Pessimistically</a></li>
<li><a href="#real-world-alternative-optimism-with-experience">Real-World <code>Alternative</code> (Optimism with Experience)</a>
<ul>
<li><a href="#failure-at-the-end">Failure at the end</a></li>
<li><a href="#permissive-computation-at-the-end">Permissive computation at the end</a></li>
</ul></li>
<li><a href="#pessimistic-instances">Pessimistic Instances</a>
<ul>
<li><a href="#either-e-a"><code>Either [e] a</code></a></li>
<li><a href="#a-decent-blueprint-either-e-e-a">A Decent Blueprint: <code>Either [e] ([e], a)</code></a></li>
<li><a href="#code-example">Code Example</a></li>
<li><a href="#extending-either-e-e-a">Extending <code>Either [e] ([e], a)</code></a></li>
</ul></li>
<li><a href="#rethinking-the-typeclass-itself">Rethinking the Typeclass Itself</a></li>
<li><a href="#alternative-beyond-parsing"><code>Alternative</code> Beyond Parsing</a></li>
<li><a href="#relevant-work-on-hackage">Relevant work on Hackage</a></li>
<li><a href="#conclusions-thoughts">Conclusions, Thoughts</a>
<ul>
<li><a href="#readers-response">Reader’s Response</a></li>
</ul></li>
</ul>
</div>
<p><strong><em>subtitle:</em> A Constructive <del>Criticism</del> Pessimism about the Alternative Typeclass</strong></p>
<p>Code for this project can be found in my <a href="https://github.com/rpeszek/experiments" target="_blank">experiments</a> repo (<a href="https://github.com/rpeszek/experiments/tree/master/alternative" target="_blank">alternative</a> folder).<br />
This is my second post dedicated to the <em>error information loss</em> in Haskell (the first was about <a href="https://rpeszek.github.io/posts/2021-01-17-maybe-overuse.html" target="_blank">Maybe Overuse</a>).</p>
<h2 id="nutshell">Nutshell</h2>
<p><code>Alternative</code> is a popular functional programming concept and the name of a frequently used Haskell typeclass. <code>Alternative</code> helps in writing elegant, concise code. <code>Alternative</code> instances are also known for producing confusing errors. In this post, we do a deep dive into the alternative thinking only about the errors.</p>
<p>The goals for this post are:</p>
<ul>
<li>discuss how <code>Alternative</code> laws impact the instance ability to keep error information</li>
<li>provide examples of how some <code>Alternative</code> instances can get programmers in trouble</li>
<li>show a ‘blueprint’ <a href="#a-decent-blueprint-either-e-e-a"><code>Either [e] ([e],_)</code></a> instance with a strong ability to preserve error information. This blueprint can be extended to a transformer, parser, etc.</li>
<li>very briefly discuss extending or rethinking the <code>Alternative</code> typeclass itself</li>
</ul>
<p>I realized that there is an interesting connection between many <code>Alternative</code> instances and optimism:<br />
Thinking about <em>the glass being half empty or half full</em>, look at this computation: <code>a &lt;|&gt; b</code> and assume that <code>a</code> fails and <code>b</code> succeeds.<br />
<em>A half empty glass</em> makes us think about the failure of <code>a</code>:<br />
<em>Why</em> did <code>a</code> fail?<br />
Would it not be better if some <code>a</code> failures caused the whole computation to fail?…<br />
<em>A half full glass</em> makes us ignore the failure and focus on <code>b</code>… this is exactly the semantics of <code>&lt;|&gt;</code>.<br />
A half full glass is not what you always want. This post looks at the alternative, its laws, and its instances from the “pessimistic” point of view. In this post pessimism is defined as, simply, thinking about the errors.</p>
<p>This is a long post. You may prefer to pick a section you consider interesting and backtrack from it. The information is largely self-contained (except for referring to the laws).</p>
<p>Implementing good error messages is not trivial. This post should not be viewed as criticism but as a challenge.</p>
<p>I am using the term <em>error</em> colloquially, the correct term is <em>exception</em>. <em>Exception information loss</em> just does not have a ring to it.</p>
<h2 id="pessimists-intro-to-alternative">Pessimist’s Intro to <code>Alternative</code></h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Alternative</span> f <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="ot">  empty ::</span> f a</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="ot">  (&lt;|&gt;) ::</span> f a <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f a</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="ot">  some ::</span> f a <span class="ot">-&gt;</span> f [a] <span class="co">-- optional</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a><span class="ot">  many ::</span> f a <span class="ot">-&gt;</span> f [a] <span class="co">-- optional</span></span></code></pre></div>
<p>The typeclass does not specify the semantics of <code>empty</code> and <code>&lt;|&gt;</code> other than their monoidal nature.<br />
However, many instances link the <code>empty</code> and <code>&lt;|&gt;</code> semantics to computation failures.</p>
<p><em>Optimist, First Look</em>:</p>
<ul>
<li><code>empty</code> typically represents a failed computation</li>
<li><code>(&lt;|&gt;)</code> combines 2 alternatives returning one that is successful. The most common approach is to return the left-to-right first success. This is called left-bias, I like to think about it as <em>right-catch semantics</em>.</li>
<li><code>some</code> and <code>many</code> run the computation until first failure and return the successful results, <code>some</code> expects at least one success, otherwise it will fail. <code>some</code> and <code>many</code> are a nod towards parsers or other computations that change state. <code>some</code> and <code>many</code> are likely to yield bottom (e.g. <code>many (Just 1)</code> does not terminate).</li>
</ul>
<p><code>Alternative</code> is the <code>Monoid</code> for the <code>* -&gt; *</code> types, <code>empty</code> representing <code>mempty</code> and <code>&lt;|&gt;</code> representing <code>mappend</code>. This equivalence is “witnessed” by the <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Monoid.html#t:Alt" target="_blank"><code>Data.Monoid.Alt</code></a> monoid instance. The left-bias semantics is equivalent to the <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Monoid.html#t:First." target="_blank"><code>Data.Monoid.First</code></a> monoid.</p>
<p>The definition of <code>Alternative</code> begs this question: Why the <code>Applicative</code> superclass? As far as I know this is because the intended use of <code>empty</code> and <code>&lt;|&gt;</code> is in the applicative context. More on this later.</p>
<p>As we know, <code>MonadPlus</code> provides a similar semantics for monads. <code>Alternative</code> and <code>MonadPlus</code> are most commonly used with parsers. You are likely to use it with <em>aeson</em>, <em>parsec</em> / <em>megaparsec</em>, <em>attoparsec</em>, etc.<br />
In this post the focus is the <code>Alternative</code> with the typical right-catching, left-biased <code>&lt;|&gt;</code> and the examples typically use <em>attoparsec</em>.</p>
<p><em>Pessimist, First Look</em>:</p>
<ul>
<li><code>empty</code> does not accept any error information. It represents a failure of some unknown reason.<br />
I consider this problematic and an oversimplification.<br />
Unless we introduce a zero-information (let me call it <em>noOp</em>) failure, this probably will bite.<br />
I will leave it to you to ponder philosophical questions about <em>noOp</em> (e.g. <code>Left []</code>) failure.<br />
What does: nothing went wrong but the computation failed mean?<br />
</li>
<li><code>(&lt;|&gt;)</code> semantics is unclear about error information.</li>
<li><code>some</code> and <code>many</code> provide no error information about the failure that ended the production of the result list. I will not discuss <code>some</code> or <code>many</code> in this post.</li>
</ul>
<p>A somewhat popular behavior is: If all alternatives fail, then the error information comes from the last tried computation. Examples of alternatives that behave this way are: <em>attoparsec</em> <code>Parser</code>, <em>aeson</em> <code>Parser</code>, <code>IO</code>.</p>
<p>I am not that deeply familiar with GHC internals. However, as a black box, the GHC compiler often behaves in a very similar way. For example, GHC message could indicate a problem with unifying types; it may suggest that my function needs to be applied to more arguments; … while the real issue is that I am missing a typeclass instance somewhere or something else is happening that is completely not related to the error message. Generating useful compiler messages must be very hard and this is not a criticism of GHC but a familiar UX example.<br />
From time to time, GHC will throw Haskell developers for a loop.</p>
<p><strong>Side-Note:</strong> <em>parsec</em> and <em>megaparsec</em> packages implemented sophisticated ways to provide better error messages by looking at things like longest parsed path. Lack of backtracking is what makes the <em>(maga)parsec</em> <code>Parser</code> not a fully lawful <em>Alternative/MonadPlus</em> (violating <em>right zero</em>). The <em>megaparsec</em> haddock suggest adding <code>try</code> to improve the lawfulness. Adding <code>try</code> can mess up error messages. There appears to be an interesting pragmatic trade-off: <em>good error messages</em> vs <em>more lawful alternative behavior</em>.<br />
A great, related, reading is: <a href="http://blog.ezyang.com/2014/05/parsec-try-a-or-b-considered-harmful/" target="_blank">Parsec: “try a &lt;|&gt; b” considered harmful</a>.</p>
<p>A random advice from a discussion about <em>attoparsec</em> errors:</p>
<blockquote>
<p><em>The trick is to use the parsers library, which lets you switch out parsing backends. You can prototype with the trifecta library (which has good error messages) and then switch to attoparsec when you’re done</em></p>
</blockquote>
<p>(I assume that the author was thinking about parsing something, like a standard protocol, where user input cannot cause errors.)<br />
So, this is clearly a bit of a mess and we are looking for crazy workarounds. I will delve deeper into alternative error outputs by looking at the alternative laws next.</p>
<h2 id="alternative-laws-pessimistically">Alternative Laws, Pessimistically</h2>
<p>The required laws (copied from <a href="https://wiki.haskell.org/Typeclassopedia#Laws_6" target="_blank">Typeclassopedia</a>, see also <a href="https://en.wikibooks.org/wiki/Haskell/Alternative_and_MonadPlus#Alternative_and_MonadPlus_laws" target="_blank">Haskell wikibooks</a>) are:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>empty <span class="op">&lt;|&gt;</span> u  <span class="ot">=</span>  u    <span class="co">-- (1)</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>u <span class="op">&lt;|&gt;</span> empty  <span class="ot">=</span>  u    <span class="co">-- (2)</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>u <span class="op">&lt;|&gt;</span> (v <span class="op">&lt;|&gt;</span> w)  <span class="ot">=</span>  (u <span class="op">&lt;|&gt;</span> v) <span class="op">&lt;|&gt;</span> w  <span class="co">-- (3)</span></span></code></pre></div>
<p>Note that these laws do not link <code>Applicative</code> and <code>Alternative</code> in any way. That happens in the following, optional, set of laws:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>f <span class="op">&lt;*&gt;</span> empty <span class="ot">=</span> empty                        <span class="co">-- (4) Rigth Zero</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>(a <span class="op">&lt;|&gt;</span> b) <span class="op">&lt;*&gt;</span> c <span class="ot">=</span> (a <span class="op">&lt;*&gt;</span> c) <span class="op">&lt;|&gt;</span> (b <span class="op">&lt;*&gt;</span> c)  <span class="co">-- (5) Left Distribution</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>a <span class="op">&lt;*&gt;</span> (b <span class="op">&lt;|&gt;</span> c) <span class="ot">=</span> (a <span class="op">&lt;*&gt;</span> b) <span class="op">&lt;|&gt;</span> (a <span class="op">&lt;*&gt;</span> c)  <span class="co">-- (6) Right Distribution</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>(<span class="fu">pure</span> a) <span class="op">&lt;|&gt;</span> x <span class="ot">=</span> <span class="fu">pure</span> a                    <span class="co">-- (7) Left catch</span></span></code></pre></div>
<p>For example, when writing a parser you may decide to use one of these approaches:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>p1 <span class="ot">=</span> <span class="dt">Employee</span> <span class="op">&lt;$&gt;</span> employeeIdParser <span class="op">&lt;*&gt;</span> (nameParser1 <span class="op">&lt;|&gt;</span> nameParser2)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>p2 <span class="ot">=</span> (<span class="dt">Employee</span> <span class="op">&lt;$&gt;</span> employeeIdParser <span class="op">&lt;*&gt;</span> nameParser1) <span class="op">&lt;|&gt;</span> (<span class="dt">Employee</span> <span class="op">&lt;$&gt;</span> employeeIdParser <span class="op">&lt;*&gt;</span> nameParser2)</span></code></pre></div>
<p>it is good to know that these approaches are equivalent.</p>
<p>The laws are strong enough to restrict what failures can be (this is not necessarily a bad thing). For example, <em>(1)</em> and <em>(4)</em> prevent expressing the concept of a critical failure. A sane definition would be: <code>f</code> is a critical failure if <code>f &lt;|&gt; a = f</code> and <code>f &lt;*&gt; a = f</code> for any <code>a</code>.<br />
<code>empty</code> cannot represent a critical failure because of <em>(1)</em><br />
non-<code>empty</code> cannot represent a critical failure because of <em>(4)</em>.<br />
Critical failures are simply not what <code>Alternative</code> is about and that is OK.</p>
<p><em>Pessimist’s Concerns</em>:</p>
<ul>
<li><code>empty</code> typically represents a failure. <em>(4)</em> is problematic if you want to have other possible failures (e.g. failures with different error messages):<br />
<code>otherFailure &lt;*&gt; empty</code> is likely to be <code>otherFailure</code> not <code>empty</code>.<br />
</li>
<li><em>(1 - 3)</em> force a monoidal structure on the failures themselves (under a reasonable assumption that <code>empty</code> is a failure and alternating two failures produces a failure). This is a good property but instances often ignore it. A semigroup structure would make more pragmatic sense (i.e. what is <code>empty</code> error?).<br />
</li>
<li>Note that any instance of <code>Alternative</code> that tries to accumulate failures is likely to have a problem satisfying the distribution laws <em>(5,6)</em>, as the <em>rhs</em> combines 4 potential failures and <em>lhs</em> combines 3.<br />
Would you expect <em>(5,6)</em> to hold in the context of a failure (e.g. parser error messages)? My answer is: I do not! Violating these laws is not necessarily a bad thing. The end result is that the programmer needs to make an explicit choice between <code>p1</code> and <code>p2</code> selecting one with the more desirable error output. The trade-off is similar to one made by the <em>monad_validate</em> package linked at the end of this article.</li>
</ul>
<p>Let me return to the basic laws, particularly <em>(2)</em>: <code>u &lt;|&gt; empty  =  u</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Attoparsec.ByteString</span> <span class="kw">as</span> <span class="dt">A</span> </span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a><span class="ot">testSuccess ::</span> <span class="dt">A.Parser</span> a <span class="ot">-&gt;</span> <span class="dt">A.Result</span> a</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>testSuccess p <span class="ot">=</span> A.parse p <span class="st">&quot;foo&quot;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a><span class="ot">testFail ::</span> <span class="dt">A.Parser</span> a <span class="ot">-&gt;</span> <span class="dt">A.Result</span> a</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>testFail p <span class="ot">=</span> A.parse p <span class="st">&quot;bar&quot;</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>u <span class="ot">=</span> A.string <span class="st">&quot;foo&quot;</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a>lhs <span class="ot">=</span> u <span class="op">&lt;|&gt;</span> empty</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a>rhs <span class="ot">=</span> u</span></code></pre></div>
<p>Here are the results:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt; testFail lhs</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="co">-- Fail &quot;bar&quot; [] &quot;Failed reading: empty&quot;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt;  testFail rhs</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a><span class="co">-- Fail &quot;bar&quot; [] &quot;string&quot;</span></span></code></pre></div>
<p>So we broke the required second law. Incidentally, we would not be able to break this law using <code>testSuccess</code>.<br />
This should not be surprising, (1-3) imply a monoidal structure on failures and this is not what <em>attoparsec</em> does.</p>
<p><em>attoparsec</em> gets a lot of blame for its error output. Let’s try the <code>IO</code> alternative:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>uIO <span class="ot">=</span> <span class="fu">fail</span> <span class="st">&quot;foo&quot;</span><span class="ot"> ::</span> <span class="dt">IO</span> a</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>lhsIO <span class="ot">=</span> uIO <span class="op">&lt;|&gt;</span> empty</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>rhsIO <span class="ot">=</span> uIO</span></code></pre></div>
<p>ghci:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> lhsIO</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="op">***</span> <span class="dt">Exception</span><span class="op">:</span> user <span class="fu">error</span> (mzero)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> rhsIO</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a><span class="op">***</span> <span class="dt">Exception</span><span class="op">:</span> user <span class="fu">error</span> (foo)</span></code></pre></div>
<p>We see the same issue.</p>
<p>One way to look at this, and I believe this is how some programmers are looking at this issue, is that any failure with any error message is considered equivalent to <code>empty</code>. The laws hold if the error information is ignored. Somewhat of a downer if you care about errors.</p>
<p><strong>Side-Note:</strong> Numerous instances of <code>Alternative</code> manage to satisfy <em>(2)</em>.<br />
That includes <code>ExceptT</code>, the <code>Validatation</code> type listed at the end of this post. Here is the law working for ‘trifecta’</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Text.Trifecta</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>u <span class="ot">=</span> string <span class="st">&quot;foo&quot;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>lhs <span class="ot">=</span> parseTest (u <span class="op">&lt;|&gt;</span> empty) <span class="st">&quot;bar&quot;</span><span class="ot"> ::</span> <span class="dt">IO</span> ()</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>rhs <span class="ot">=</span> parseTest u <span class="st">&quot;bar&quot;</span><span class="ot"> ::</span> <span class="dt">IO</span> ()</span></code></pre></div>
<p>ghci:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> lhs</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>(interactive)<span class="op">:</span><span class="dv">1</span><span class="op">:</span><span class="dv">1</span><span class="op">:</span> <span class="fu">error</span><span class="op">:</span> expected<span class="op">:</span> <span class="st">&quot;foo&quot;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a><span class="dv">1</span> <span class="op">|</span> bar<span class="op">&lt;</span><span class="dt">EOF</span><span class="op">&gt;</span> </span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>  <span class="op">|</span> <span class="op">^</span>        </span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> rhs</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>(interactive)<span class="op">:</span><span class="dv">1</span><span class="op">:</span><span class="dv">1</span><span class="op">:</span> <span class="fu">error</span><span class="op">:</span> expected<span class="op">:</span> <span class="st">&quot;foo&quot;</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a><span class="dv">1</span> <span class="op">|</span> bar<span class="op">&lt;</span><span class="dt">EOF</span><span class="op">&gt;</span> </span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a>  <span class="op">|</span> <span class="op">^</span>    </span></code></pre></div>
<p>We will see the blueprint <code>Monoid</code> fix for <em>(2)</em> in the <a href="#either-e-a"><code>Either [e] a</code></a> section.</p>
<h2 id="real-world-alternative-optimism-with-experience">Real-World <code>Alternative</code> (Optimism with Experience)</h2>
<p>Here are some examples of problems arising from the use of <code>Alternative</code> semantics</p>
<h3 id="failure-at-the-end">Failure at the end</h3>
<p>Laws are important, functional programmers use laws (sometimes even subconsciously) when thinking about, implementing, or designing the code. The second law tells us that we can slap a computation that always errors out at the end without messing things up.</p>
<p>Consider this (a slightly adjusted real-world) situation: your app needs to talk to an external website which can decide to do A, B, or C and will reply with A, B, or C json message. Based on what happened, your app will need to do different things. You need to parse the reply to know how to proceed.<br />
The good news is that only A and B are needed in the short term, C can wait. For now, you are only required to tell the user when C happens.</p>
<p>This should be <em>aeson</em> but I keep <em>attoparsec</em> for consistency (the behavior is the same):</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a>parseReply <span class="ot">=</span> parseA <span class="op">&lt;|&gt;</span> parseB <span class="op">&lt;|&gt;</span> parseC </span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>    parseA <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>    parseB <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>    parseC <span class="ot">=</span> <span class="fu">fail</span> <span class="st">&quot;C is not supported yet!&quot;</span></span></code></pre></div>
<p>The external website changed how they report A, now when A is processed <code>parseA</code> fails, the user sees: “C is not supported yet!”.</p>
<p>The following would be a slightly better code, the user would see <code>parseB</code> error message instead:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a>parseReply <span class="ot">=</span> parseC <span class="op">&lt;|&gt;</span> parseA <span class="op">&lt;|&gt;</span> parseB </span></code></pre></div>
<p><em>(sigh)</em></p>
<p>One way out is to parse A, B, and C separately and handle the results (and the parsing errors) outside of the <code>Parser</code>.</p>
<p>The other design risk is in thinking about the second law as ‘stable’: We will not disturb the computation too much if we append (add at the end of the <code>&lt;|&gt;</code> chain) a very restrictive parser that fails most of the time.<br />
An example would be fixing an existing parser <code>p</code> with a missed corner case parser, <code>p &lt;|&gt; cornerCaseP</code>. Errors from <code>p</code> are now almost not visible.</p>
<p>So would <code>cornerCaseP &lt;|&gt; p</code> be a better solution? Next section covers that case.</p>
<h3 id="permissive-computation-at-the-end">Permissive computation at the end</h3>
<p>This is the example I started with. Consider code like this:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a>specificComputation <span class="op">&lt;|&gt;</span> bestEffortComputation</span></code></pre></div>
<p>The specs may change and you will never learn that <code>specificComputation</code> no longer works because <code>bestEffortComputation</code> effectively hides the issue.</p>
<p>The way out is to run <code>specificComputation</code> and <code>bestEffortComputation</code> separately and handle results (e.g. parsing errors if the computation is a parser) outside, or come up with a different way of not using the alternative.</p>
<p><em>Failure at the end</em> situation improves a bit with certain (other than <em>aeson</em> or <em>attoparsec</em>) alternatives, <em>Permissive computation at the end</em> does not seem to have a good available solution.</p>
<h2 id="pessimistic-instances">Pessimistic Instances</h2>
<p>It would be ideal if the following property was true:</p>
<p><em>If a typeclass A is defined in the <strong>base</strong> package and A has something to do with failures, then there exist at least one instance of <em>A</em> in the <strong>base</strong> allowing to recover the error information</em></p>
<p><code>MonadFail</code> fails this property (especially when combined with <code>MonadPlus</code>: <a href="https://rpeszek.github.io/posts/2021-01-17-maybe-overuse.html#monadfail-and-maybe" target="_blank">Maybe Overuse - MonadFail</a>).</p>
<p><code>Alternative</code> <del>fails it as well</del>. (<strong>EDIT Feb 13, 2021</strong>: It has been pointed out to me on <a href="https://www.reddit.com/r/haskell/comments/lj3h47/is_alternative_a_wrong_abstraction_for_handling/gnas3y2?utm_source=share&amp;utm_medium=web2x&amp;context=3" target="_blank">reddit by u/gcross</a> that this is <strong>not a fair criticism</strong>. <em>base</em> typeclass definition does not really claim any relationship to failures. I stand corrected on this. I still think that it would be very nice to have error information friendly instance of Alternative in <em>base</em>.)</p>
<p>Can we come up with <code>Alternative</code> instances that do a decent job of maintaining error information? It seems that the answer is yes.</p>
<h3 id="either-e-a"><code>Either [e] a</code></h3>
<p>This is a warm-up.</p>
<p>This instance is not new. It matches the <code>ExceptT</code> alternative instance from <em>transformers</em> / <em>mtl</em>. It uses standard <code>Either</code> monad and this is a <code>MonadPlus</code> (with a somewhat questionable right-zero law):</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Monoid</span> e <span class="ot">=&gt;</span> <span class="dt">Alternative</span> (<span class="dt">Either</span> e) <span class="kw">where</span> </span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>    empty  <span class="ot">=</span> <span class="dt">Left</span> <span class="fu">mempty</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>    <span class="dt">Left</span> e1 <span class="op">&lt;|&gt;</span> <span class="dt">Left</span> e2 <span class="ot">=</span> <span class="dt">Left</span> <span class="op">$</span> e1 <span class="op">&lt;&gt;</span> e2</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a>    (<span class="dt">Left</span> _) <span class="op">&lt;|&gt;</span> r <span class="ot">=</span> r</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>    r <span class="op">&lt;|&gt;</span> _ <span class="ot">=</span> r</span></code></pre></div>
<p><em>(Note: transformers package has a conflicting instance in the deprecated <code>Control.Monad.Trans.Error</code> module, in a real code a <code>newtype</code> would be needed to avoid this conflict)</em></p>
<p>I have included <code>Monoid e =&gt; Alternative (Either e)</code> instance as a warm-up and to discuss the laws.</p>
<p><strong>Laws:</strong><br />
The required <em>(1-3)</em> laws are satisfied without resorting to any sort of questionable reasoning that treats all errors as <code>empty</code>. However, <code>empty</code> represents a <em>noOp failure</em> computation (somewhat questionable meaning).</p>
<p>Optional <em>(4 Right Zero)</em> law (<code>f &lt;*&gt; empty = empty</code>) is questionable (consider <code>f = Left e</code> with a non-trivial <code>e</code>).<br />
<em>(7 Left Catch)</em> is OK.<br />
As we have predicted, the distribution laws are not satisfied.<br />
<em>(5)</em> is NOT satisfied:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a>(f <span class="op">&lt;|&gt;</span> g) <span class="op">&lt;*&gt;</span> a <span class="ot">=</span> (f <span class="op">&lt;*&gt;</span> a) <span class="op">&lt;|&gt;</span> (g <span class="op">&lt;*&gt;</span> a) </span></code></pre></div>
<p>If <code>f</code> and <code>g</code> represent successful computation and <code>a</code> is a list of errors then the <em>rhs</em> has twice as many errors as the <em>lhs</em>.</p>
<p><em>(6)</em> is not satisfied either:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a>f <span class="op">&lt;*&gt;</span> (b <span class="op">&lt;|&gt;</span> c) <span class="ot">=</span> (f <span class="op">&lt;*&gt;</span> b) <span class="op">&lt;|&gt;</span> (f <span class="op">&lt;*&gt;</span> c) </span></code></pre></div>
<p>If <code>f</code> represents a failed computation then <em>rhs</em> will duplicate <code>f</code> errors.<br />
This looks like a bigger problem than it really is. The <em>lhs</em> and <em>rhs</em> contain the same amount of error information.</p>
<p>So, overall, <code>Either [e] a</code> has done quite well as an alternative!</p>
<h3 id="a-decent-blueprint-either-e-e-a">A Decent Blueprint: <code>Either [e] ([e], a)</code></h3>
<p>What would really be nice, is to have a standard “right-catch with warnings” <code>Alternative</code> instance (please let me know if you have seen it somewhere on Hackage):</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">ErrWarn</span> e w a <span class="ot">=</span> <span class="dt">EW</span> {<span class="ot">runEW ::</span> <span class="dt">Either</span> e (w, a)} <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Functor</span>)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>  </span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a><span class="kw">instance</span> (<span class="dt">Monoid</span> e) <span class="ot">=&gt;</span> <span class="dt">Alternative</span> (<span class="dt">ErrWarn</span> e e) <span class="kw">where</span> </span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a>    empty  <span class="ot">=</span> <span class="dt">EW</span> <span class="op">$</span> <span class="dt">Left</span> <span class="fu">mempty</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a>    <span class="dt">EW</span> (<span class="dt">Left</span> e1) <span class="op">&lt;|&gt;</span> <span class="dt">EW</span> (<span class="dt">Left</span> e2) <span class="ot">=</span> <span class="dt">EW</span> (<span class="dt">Left</span> <span class="op">$</span> e1 <span class="op">&lt;&gt;</span> e2)</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a>    <span class="dt">EW</span> (<span class="dt">Left</span> e1) <span class="op">&lt;|&gt;</span> <span class="dt">EW</span> (<span class="dt">Right</span> (w2, r)) <span class="ot">=</span> <span class="dt">EW</span> <span class="op">$</span> <span class="dt">Right</span> (e1 <span class="op">&lt;&gt;</span> w2, r) <span class="co">-- coupling between @Either e@ and @(e,)@</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true"></a>    r<span class="op">@</span>(<span class="dt">EW</span> (<span class="dt">Right</span> _)) <span class="op">&lt;|&gt;</span> _ <span class="ot">=</span> r</span></code></pre></div>
<p>This approach, when computing <code>a &lt;|&gt; b</code>, does not try to compute <code>b</code> if <code>a</code> succeeds. Thus, this instance matches the common left bias semantics. The approach accumulates all errors encountered up to the point of the first success and returns them as warnings.<br />
This is a lawful <code>Alternative</code> (satisfies required laws <em>(1-3)</em>) and it does not rely on any questionable unification of <code>empty</code> with non-trivial errors.</p>
<p>I now feel justified using <code>Monoid e</code> constraint. Empty failure makes no sense, but empty warnings make a lot of sense!</p>
<p>But wait! To have <code>Alternative</code> we need <code>Applicative</code>. It is possible to implement <code>Applicative</code> for this type in more than one way, one even leads to a valid <code>Monad</code> and <code>MonadPlus</code> (with the right-zero caveat discussed above).<br />
That approach is equivalent to <code>WriterT w (Except e)</code>, it does not try to <code>&lt;*&gt;</code>-accumulate <code>e</code>-s, it only accumulates <code>w</code>-s:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="kw">instance</span> (<span class="dt">Monoid</span> w) <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">ErrWarn</span> e w) <span class="kw">where</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a>    <span class="fu">pure</span> x <span class="ot">=</span> <span class="dt">EW</span> <span class="op">$</span> <span class="dt">Right</span> (<span class="fu">mempty</span>, x)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a>    <span class="dt">EW</span> (<span class="dt">Left</span> e) <span class="op">&lt;*&gt;</span> _ <span class="ot">=</span> <span class="dt">EW</span> <span class="op">$</span> <span class="dt">Left</span> e</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a>    <span class="dt">EW</span> (<span class="dt">Right</span> (u, f)) <span class="op">&lt;*&gt;</span> <span class="dt">EW</span> (<span class="dt">Right</span> (v, x)) <span class="ot">=</span> <span class="dt">EW</span> (<span class="dt">Right</span> (u <span class="op">&lt;&gt;</span> v, f x))</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a>    <span class="dt">EW</span> (<span class="dt">Right</span> (u, f)) <span class="op">&lt;*&gt;</span> <span class="dt">EW</span> (<span class="dt">Left</span> e)  <span class="ot">=</span> <span class="dt">EW</span> <span class="op">$</span> <span class="dt">Left</span> e</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true"></a><span class="kw">instance</span> (<span class="dt">Monoid</span> w) <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">ErrWarn</span> e w) <span class="kw">where</span> </span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true"></a>    <span class="dt">EW</span> (<span class="dt">Left</span> e) <span class="op">&gt;&gt;=</span> _  <span class="ot">=</span> <span class="dt">EW</span> <span class="op">$</span> <span class="dt">Left</span> e</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true"></a>    <span class="dt">EW</span> (<span class="dt">Right</span> (u, x)) <span class="op">&gt;&gt;=</span> k <span class="ot">=</span> </span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true"></a>        <span class="kw">case</span> k x <span class="kw">of</span> </span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true"></a>            <span class="dt">EW</span> (<span class="dt">Right</span> (v, b)) <span class="ot">-&gt;</span> <span class="dt">EW</span> (<span class="dt">Right</span> (u <span class="op">&lt;&gt;</span> v, b))</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true"></a>            <span class="dt">EW</span> (<span class="dt">Left</span> e) <span class="ot">-&gt;</span> <span class="dt">EW</span> (<span class="dt">Left</span> e)</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true"></a></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true"></a><span class="kw">instance</span> (<span class="dt">Monoid</span> e) <span class="ot">=&gt;</span> <span class="dt">MonadPlus</span> (<span class="dt">ErrWarn</span> e e)    </span></code></pre></div>
<p>Please note the small difference. Standard <em>transformers</em> / <em>mtl</em> <code>ExeptT</code> and <code>WriterT</code> both support <code>Alternative</code></p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a> (<span class="dt">Monad</span> m, <span class="dt">Monoid</span> e) <span class="ot">=&gt;</span> <span class="dt">Alternative</span> (<span class="dt">ExceptT</span> e m)	</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a> (<span class="dt">Monoid</span> w, <span class="dt">Alternative</span> m) <span class="ot">=&gt;</span> <span class="dt">Alternative</span> (<span class="dt">WriterT</span> w m) <span class="co">-- Monoid only used to define @empty@</span></span></code></pre></div>
<p>but in a decoupled way, <code>ErrWarn</code> couples these two by “writing” <code>e</code>-s.</p>
<p>This instance exhibits similar problems with matching the <code>&lt;*&gt;</code> semantics as the <code>Monoid e =&gt; Either e</code> instance from the previous section (i.e. <em>(5,6)</em> are not satisfied). Overall it is a very well behaved alternative.</p>
<h3 id="code-example">Code Example</h3>
<p>Here is a very convoluted (and not very good) parsing code that is intended only to demonstrate how <code>ErrWarn</code> works. This code creates a natural transformation from the <em>attoparsec</em> parser to <code>ErrWarn</code> and compares the error outputs from both.</p>
<p>This code will parse <em>ByteStrings</em> like “id last-first-name dept boss2” to produce, if successful, a hard-coded <em>id, name, department, and boss name</em>:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a>idP <span class="ot">=</span> <span class="dv">123</span> <span class="ot">`onKeyword`</span> <span class="st">&quot;id&quot;</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a>nameP1 <span class="ot">=</span> <span class="st">&quot;Smith John&quot;</span>  <span class="ot">`onKeyword`</span> <span class="st">&quot;last-first-name&quot;</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a>nameP2 <span class="ot">=</span> <span class="fu">fail</span> <span class="st">&quot;first-last-name not implemented yet&quot;</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a>deptP <span class="ot">=</span>  <span class="st">&quot;Billing&quot;</span> <span class="ot">`onKeyword`</span> <span class="st">&quot;dept&quot;</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a>bossP1 <span class="ot">=</span> <span class="st">&quot;Jim K&quot;</span> <span class="ot">`onKeyword`</span> <span class="st">&quot;boss1&quot;</span>     </span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true"></a>bossP2 <span class="ot">=</span> <span class="st">&quot;Kim J&quot;</span> <span class="ot">`onKeyword`</span> <span class="st">&quot;boss2&quot;</span>    </span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true"></a>bossP3 <span class="ot">=</span> <span class="fu">pure</span> <span class="st">&quot;Mij K bosses everyone&quot;</span> </span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true"></a></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true"></a><span class="ot">onKeyword ::</span> a <span class="ot">-&gt;</span> <span class="dt">B.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">AT.Parser</span> <span class="dt">B.ByteString</span> a</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true"></a>onKeyword val key <span class="ot">=</span> <span class="fu">const</span> val <span class="op">&lt;$&gt;</span> A.manyTill ACh.anyChar</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true"></a>                    (A.lookAhead <span class="op">$</span> A.string key)</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true"></a>                    <span class="op">A.&lt;?&gt;</span> <span class="fu">show</span> key</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true"></a></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Employee</span> <span class="ot">=</span> <span class="dt">Employee</span> {</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true"></a><span class="ot">    id ::</span> <span class="dt">Int</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true"></a>    ,<span class="ot"> name ::</span> <span class="dt">String</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true"></a>    ,<span class="ot"> dept  ::</span> <span class="dt">String</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true"></a>    ,<span class="ot"> boss ::</span> <span class="dt">String</span></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true"></a>   } <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true"></a></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true"></a><span class="ot">emplP ::</span> <span class="dt">A.Parser</span> <span class="dt">B.ByteString</span> <span class="dt">Employee</span></span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true"></a>emplP <span class="ot">=</span> </span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true"></a>   <span class="dt">Employee</span> </span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true"></a>   <span class="op">&lt;$&gt;</span> idP</span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true"></a>   <span class="op">&lt;*&gt;</span> (nameP1 <span class="op">&lt;|&gt;</span> nameP2)</span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true"></a>   <span class="op">&lt;*&gt;</span> deptP</span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true"></a>   <span class="op">&lt;*&gt;</span> (bossP1 <span class="op">&lt;|&gt;</span> bossP2 <span class="op">&lt;|&gt;</span> bossP3) </span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true"></a></span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true"></a><span class="ot">emplP' ::</span> <span class="dt">B.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">ErrWarn</span> [<span class="dt">String</span>] [<span class="dt">String</span>] <span class="dt">Employee</span></span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true"></a>emplP' txt <span class="ot">=</span> </span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true"></a>   <span class="dt">Employee</span> </span>
<span id="cb20-32"><a href="#cb20-32" aria-hidden="true"></a>   <span class="op">&lt;$&gt;</span> ew idP </span>
<span id="cb20-33"><a href="#cb20-33" aria-hidden="true"></a>   <span class="op">&lt;*&gt;</span> (ew nameP1  <span class="op">&lt;|&gt;</span> ew nameP2 )</span>
<span id="cb20-34"><a href="#cb20-34" aria-hidden="true"></a>   <span class="op">&lt;*&gt;</span> ew deptP </span>
<span id="cb20-35"><a href="#cb20-35" aria-hidden="true"></a>   <span class="op">&lt;*&gt;</span> (ew bossP1  <span class="op">&lt;|&gt;</span> ew bossP2 <span class="op">&lt;|&gt;</span> ew bossP3)</span>
<span id="cb20-36"><a href="#cb20-36" aria-hidden="true"></a>   <span class="kw">where</span></span>
<span id="cb20-37"><a href="#cb20-37" aria-hidden="true"></a><span class="ot">        ew ::</span> <span class="dt">A.Parser</span> a  <span class="ot">-&gt;</span> <span class="dt">ErrWarn</span> [<span class="dt">String</span>] [<span class="dt">String</span>] a</span>
<span id="cb20-38"><a href="#cb20-38" aria-hidden="true"></a>        ew p <span class="ot">=</span> singleErr <span class="op">$</span> A.parseOnly p txt</span>
<span id="cb20-39"><a href="#cb20-39" aria-hidden="true"></a></span>
<span id="cb20-40"><a href="#cb20-40" aria-hidden="true"></a><span class="ot">        singleErr ::</span> <span class="dt">Either</span> e a <span class="ot">-&gt;</span> <span class="dt">ErrWarn</span> [e] [e] a</span>
<span id="cb20-41"><a href="#cb20-41" aria-hidden="true"></a>        singleErr (<span class="dt">Left</span> e) <span class="ot">=</span> <span class="dt">EW</span> <span class="op">$</span> <span class="dt">Left</span> [e]</span>
<span id="cb20-42"><a href="#cb20-42" aria-hidden="true"></a>        singleErr (<span class="dt">Right</span> r) <span class="ot">=</span> <span class="dt">EW</span> <span class="op">$</span> <span class="dt">Right</span> ([], r)</span></code></pre></div>
<p>Trying it with a good input:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt; A.parseOnly emplP &quot;id last-first-name dept boss1&quot;</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a><span class="co">-- Right (Employee {id = 123, name = &quot;Smith John&quot;, dept = &quot;Billing&quot;, boss = &quot;Jim K&quot;})</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt; emplP' &quot;id last-first-name dept boss1&quot;</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a><span class="co">-- EW {runEW = Right ([],Employee {id = 123, name = &quot;Smith John&quot;, dept = &quot;Billing&quot;, boss = &quot;Jim K&quot;})}</span></span></code></pre></div>
<p>Trying <a href="#failure-at-the-end">failure at the end</a> situation (typo in <code>"last-first-name"</code>):</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt; A.parseOnly emplP &quot;id last-firs-name dept boss2&quot;</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a><span class="co">-- Left &quot;Failed reading: first-last-name not implemented yet&quot;</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt; runEW $ emplP' &quot;id last-firs-name dept boss2&quot;</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a><span class="co">-- Left [&quot;\&quot;last-first-name\&quot;: not enough input&quot;,&quot;Failed reading: first-last-name not implemented yet&quot;]</span></span></code></pre></div>
<p>(A similar benefit can be achieved by using one of the Hackage <em>validation</em> packages listed at the end of this post or using the <code>ExceptT</code> alternative.)</p>
<p>Trying <a href="#permissive-computation-at-the-end">permissive computation at the end</a> situation (<code>"boss"</code> parsing error):</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt; A.parseOnly emplP &quot;id last-first-name dept boss&quot;</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a><span class="co">-- Right (Employee {id = 123, name = &quot;Smith John&quot;, dept = &quot;Billing&quot;, boss = &quot;Mij K bosses everyone&quot;})</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a><span class="co">-- &gt;&gt;&gt;runEW $ emplP' &quot;id last-first-name dept boss&quot;</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a><span class="co">-- Right ([&quot;\&quot;boss1\&quot;: not enough input&quot;,&quot;\&quot;boss2\&quot;: not enough input&quot;],Employee {id = 123, name = &quot;Smith John&quot;, dept = &quot;Billing&quot;, boss = &quot;Mij K bosses everyone&quot;})</span></span></code></pre></div>
<p>(A similar benefit cannot be achieved by using a <em>validation</em> package from the list at the end of this post or a <em>transformers</em> stack. Please let me know if something like this exists elsewhere.)</p>
<p>We are no longer being thrown for a loop!</p>
<h3 id="extending-either-e-e-a">Extending <code>Either [e] ([e], a)</code></h3>
<p>The <em>right-catch with warnings</em> semantics of <code>Either [e] ([e], a)</code> is a decent principled computation that can be extended to other types. For example, a similar semantics could find its way into some parser internals.</p>
<p>I have created several prototype alternative instances (including a primitive <code>WarnParser</code> parser and <code>ErrWarnT</code> transformer) that follow the same semantics, they can be found in the linked <a href="https://github.com/rpeszek/experiments/tree/master/alternative" target="_blank">repo</a>.</p>
<p><code>ErrWarnT</code> allows to program in a <code>ErrWarnT e e f</code> alternative (e.g. <code>ErrWarnT e e Parser</code>) and annotate additional error information on <code>f</code> (e.g. during parsing). This allows, for example, to <em>pattern match on errors</em> to figure out which alternatives in <code>&lt;|&gt;</code> have failed even if the overall computation has succeeded.<br />
<code>WarnParser</code> accumulates <code>&lt;|&gt;</code> similar errors and warnings out of the box.</p>
<h2 id="rethinking-the-typeclass-itself">Rethinking the Typeclass Itself</h2>
<p>Is <code>Alternative</code> a wrong abstraction for alternating failing computations? I think it is. IMO any abstraction used for working with failures should include failures in its semantics. <code>Alternative</code> typeclass does not do that.</p>
<p><code>Alternative</code> is widely used and creating an ‘alternative’ to it will, probably, be very hard or even impossible. That typeclass would be useful only if the ecosystem accepted it.</p>
<p>One conceptually simple improvement would be to split <code>Alternative</code> to mimic the <code>Semigoup</code> / <code>Monoid</code> split (<em>semigroupoids</em> has <code>Data.Functor.Alt</code> which seems to fit the bill).<br />
This would clean up some instances like <code>ExceptT</code> (the above <a href="#either-e-a"><code>Either [e]</code></a>) or <a href="#relevant-work-on-hackage"><code>Validation</code></a> by reducing the need for questionable <code>empty</code> definitions like <code>Left []</code>. Incidentally, this would be the opposite of the <a href="https://wiki.haskell.org/MonadPlus_reform_proposal" target="_blank"><code>MonadZero</code></a> proposal.</p>
<p>I would really like to see <code>e</code>-s in the typeclass definition:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Semigroup1</span> f <span class="kw">where</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a><span class="ot">   (&lt;|&gt;)  ::</span> f a <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f a </span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">Applicative</span> (f e) <span class="ot">=&gt;</span> <span class="dt">Semigroup2</span> e f <span class="kw">where</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a><span class="ot">   (&lt;||&gt;)  ::</span> f e a <span class="ot">-&gt;</span> f e a <span class="ot">-&gt;</span> f e a </span></code></pre></div>
<p>The linked <a href="https://github.com/rpeszek/experiments/tree/master/alternative" target="_blank">repo</a> contains some loose replacement ideas for <code>Alternative</code> and <code>MonadPlus</code>. It is a work in progress.</p>
<h2 id="alternative-beyond-parsing"><code>Alternative</code> Beyond Parsing</h2>
<p>It should be mentioned that there are instances of <code>Alternative</code> such as the list <code>[]</code>, or <code>ZipList</code> where failures are not a concern. Sorting algorithms using MonadPlus are thumbs up. Examples like <code>LogicT</code> or other backtracking search mechanisms should be in the same boat (at least from the failure point of view, other aspects can be questionable and fascinating <a href="https://stackoverflow.com/questions/15722906/must-mplus-always-be-associative-haskell-wiki-vs-oleg-kiselyov" target="_blank">stackoverflow on mplus associativity</a>).</p>
<p>Also, these instances are rather cool.<br />
Languages like JavaScript, Python, Groovy have a concept of <em>truthiness</em>. <em>Truthy</em> <em>Falsy</em> are a thing and come with a Boolean algebra of sorts. Try evaluating this in you browser’s console:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a><span class="op">&gt;</span> <span class="st">&quot;hello&quot;</span> <span class="op">||</span> <span class="st">&quot;&quot;</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a><span class="st">&quot;hello&quot;</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a><span class="op">&gt;</span> <span class="st">&quot;&quot;</span> <span class="op">||</span> <span class="st">&quot;hello&quot;</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true"></a><span class="st">&quot;hello&quot;</span></span></code></pre></div>
<p><em>Truthiness</em> is questionable because the Boolean algebra laws (like <code>a || b = b || a</code>) no longer hold.</p>
<p>Now try these in ghci:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> <span class="st">&quot;&quot;</span> <span class="op">&lt;|&gt;</span> <span class="st">&quot;hello&quot;</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a><span class="st">&quot;hello&quot;</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> <span class="st">&quot;hello&quot;</span> <span class="op">&lt;|&gt;</span> <span class="st">&quot;&quot;</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true"></a><span class="st">&quot;hello&quot;</span></span></code></pre></div>
<p>Alternative is a principled version of the <em>truthiness</em>. The laws properly state the algebra limitations.<br />
As we have seen, the problem is in going with this generalization too far.</p>
<p><em>async</em> package uses <code>&lt;|&gt;</code> to return result form the computation that finishes first. This seems a good use to me.</p>
<p>Several types like <code>ExceptT</code>, <code>Validation</code> (see <a href="#relevant-work-on-hackage">hackage section</a> below) allow to use user defined monoid error types. <code>mempty</code> may not have much sense as an error, but this setup offers interesting options for accumulating errors. For example, using it with <code>Data.Monoid.Max</code> could be very interesting.</p>
<p><strong>Not so good:</strong><br />
An interesting case is the <code>STM</code> monad. <code>a &lt;|&gt; b</code> is used to chain computations that may want to <code>retry</code>. I imagine, composing <code>STM</code> computations this way is rare. If you wanted to communicate why <code>a</code> has decided to retry, how would you do that? I consider <code>STM</code> use of alternatives problematic.</p>
<p><code>IO</code> itself is an <code>Alternative</code> and uses <code>&lt;|&gt;</code> as a <code>catch</code> that throws away the error information. I dislike the <code>IO</code> instance. “Launching missiles” and not knowing what went wrong seems not ideal.</p>
<h2 id="relevant-work-on-hackage">Relevant work on Hackage</h2>
<p><a href="https://hackage.haskell.org/package/free" target="_blank"><em>free</em></a> package contains a semantic (free) version of <em>Alternative</em>.</p>
<p><a href="https://hackage.haskell.org/package/semigroupoids-5.3.5/docs/Data-Functor-Alt.html" target="_blank"><em>semigroupoids</em></a> offers <em>Alt</em> that is just a <em>Functor</em> and does not need to have <code>empty</code>.</p>
<p><a href="https://hackage.haskell.org/package/transformers-0.5.6.2" target="_blank"><em>transformers</em></a> ExceptT implements <code>Alternative</code> which accumulates “Lefts”.</p>
<p>A list of interesting packages that implement <code>Monoid</code>-like semantics for <code>Applicative</code> (most also implement <code>Alternative</code>) to accumulate errors provided by <a href="https://www.reddit.com/user/affinehyperplane/" target="_blank">u/affinehyperplane</a> on <a href="https://www.reddit.com/r/haskell/comments/kyo4xk/maybe_considered_harmful/gji7fmx?utm_source=share&amp;utm_medium=web2x&amp;context=3" target="_blank">reddit</a>:</p>
<p><a href="https://hackage.haskell.org/package/either-5.0.1.1/docs/Data-Either-Validation.html" target="_blank"><em>either</em></a> defines <code>Either</code> like <code>Validation e a</code> applicative, both <code>&lt;|&gt;</code> and <code>&lt;*&gt;</code> accumulate errors<br />
<a href="https://hackage.haskell.org/package/validation-1.1/docs/Data-Validation.html" target="_blank"><em>validation</em></a> defines a similar <code>Validation</code> type, it does not define alternative instance.<br />
<a href="https://hackage.haskell.org/package/validation-selective-0.1.0.0/docs/Validation.html" target="_blank"><em>validation-selective</em></a> defines a similar <code>Validation</code> type loaded with (non-monad) instances<br />
<a href="https://hackage.haskell.org/package/monad-validate-1.2.0.0/docs/Control-Monad-Validate.html" target="_blank"><em>monad-validate</em></a> provides an interesting and very useful validation <em>monad</em> transformer (this is lawful if you do not compare error outputs) that can accumulate errors, it does not implement <code>Alternative</code>.</p>
<p>In the context of parsers, it should be noted that packages like <em>trifecta</em>, <em>(mega)parsec</em> do nice job returning error messages when <code>&lt;|&gt;</code> fails.</p>
<p>A good references about Alternative and MonadPlus in general is the <a href="https://wiki.haskell.org/Typeclassopedia#Failure_and_choice:_Alternative.2C_MonadPlus.2C_ArrowPlus" target="_blank">Typeclassopedia</a> and <a href="https://en.wikibooks.org/wiki/Haskell/Alternative_and_MonadPlus" target="_blank">wikibooks</a>, both contain interesting links.</p>
<p>There are many stackoverflow answers about Haskell solutions to accumulating errors. These typically refer to some of the packages in the above list, I am not linking them here.<br />
There are many, many discussions about error output from different parsing libraries. These are typically focused on criticizing a particular package (typically <em>attoparsec</em>) not the <code>Alternative</code> typeclass itself.<br />
I am sure, this list is not complete. Please let me know if you see a relevant work elsewhere.</p>
<h2 id="conclusions-thoughts">Conclusions, Thoughts</h2>
<p>It is possible to implement instances that do a decent error management but it feels like this is accomplished despite of the <code>Alternative</code> typeclass definition and its laws. To answer my title: IMO <code>Alternative</code> is a wrong abstraction for managing computational failures.</p>
<p>The more I program in Haskell the more I view Functional Programming as a branch of Applied Mathematics.<br />
Criticizing mathematical abstractions does not make much sense. Criticism of how well an abstraction fits is application if a fair game.</p>
<p>Why errors are being overlooked? I assembled a possible list when writing about the <a href="https://rpeszek.github.io/posts/2021-01-17-maybe-overuse.html#why-maybe-is-overused-possible-explanations" target="_blank">Maybe Overuse</a> and that list seems to translate well to the alternative typeclass. For example, code using <code>&lt;|&gt;</code> is very terse, something with a stronger error semantics will most likely be more verbose; coding with <code>&lt;|&gt;</code> is simple, stronger error semantics will likely be more complex …<br />
I could be wrong on this: the original usages of MonadPlus were probably related to sorting/searching and lists. Alternative computations with more complex error structure were probably introduced later? … and, the instances ended up outgrowing the typeclass?</p>
<p>The <em>pessimist</em> theme was partially inspired by the following two concepts:<br />
<a href="https://link.springer.com/referenceworkentry/10.1007%2F978-94-007-0753-5_2219#:~:text=Definition,favor%20positive%20information%20in%20reasoning." target="_blank"><em>Positivity Bias</em></a> and, its opposite, the <a href="https://en.wikipedia.org/wiki/Negativity_bias" target="_blank"><em>Negativity Bias</em></a> are psychological notions that, I believe, have a deep relevance to the programming in general.<br />
<em>Positivity Bias</em> includes a <em>tendency to favor positive information in reasoning</em> and, by definition, will make you think about “happy path” and “sunny day scenarios”.<br />
<em>Negativity Bias</em> includes a <em>tendency to favor negative information in reasoning</em> and, by definition, will make you consider “rainy day scenarios”, corner cases, error handling, error information.<br />
I think we should embrace some form of <em>pessimism</em> and put in on the pedestal next to the principled construction.</p>
<p>I hope this post will motivate more discussion about the <em>error information</em> handling in Haskell.<br />
My particular interest is in discussing:</p>
<ul>
<li>your views about rethinking the <code>Alternative</code> typeclass</li>
<li>your views on pessimism in programming</li>
<li>your views on the error information loss in Haskell code</li>
<li>is <code>ErrWarn</code> somewhere on Hackage and I did not see it?</li>
<li>other interesting <code>Alternative</code> instances that care about errors</li>
<li>obviously, anything that I got wrong</li>
</ul>
<p><a href="https://www.reddit.com/r/haskell/comments/lj3h47/is_alternative_a_wrong_abstraction_for_handling/" target="_blank">reddit</a> discussion<br />
github <a href="https://github.com/rpeszek/rpeszek.github.io/discussions/1" target="_blank">discussions</a></p>
<p>Thank you for reading!</p>
<h3 id="readers-response">Reader’s Response</h3>
<p>Common critical response on reddit (2021-02-15) can be summarized as: Alternative should not be used like this and there are better ways of writing such code.</p>
<blockquote>
<p>“it seems a bit odd, to me, to criticize and talk about rethinking a typeclass because it does something that it was never intended to do”<br />
“people should be using a typeclass designed for handling errors”<br />
“maybe you are asking too much to Alternative”</p>
</blockquote>
<p>The <code>ErrWarn</code> blueprint or other instances with strong error information preserving abilities were not discussed.</p>
<p>There appears to be mixed response to the error information loss being a problem in general. Some readers claim that this is not a problem, some seem to share my concern.</p>
<p><strong>Author’s Defense</strong></p>
<p>I agree with the: “Alternative should not be used like this”.</p>
<p>Alternative is an example of an abstraction that is very easy to use, it makes coding fast.<br />
It most likely will end up being used (I have seen it) in ways similar to what I described in this post.<br />
It is important that the developers are aware of the gotchas that come with some of the instances.</p>
<p>Any code (alternative or not) producing confusing error output is a concern.<br />
IMO, every abstraction and every instance needs to be concerned about the error output quality. <em>Not being designed for error handling</em> should not be a thing. At the same time, error friendlier instances should be a good thing.</p>

    </section>
</article>
]]></description>
    <pubDate>Sat, 13 Feb 2021 00:00:00 UT</pubDate>
    <guid>https://rpeszek.github.io//posts/2021-02-13-alternative.html</guid>
    <dc:creator>Robert Peszek</dc:creator>
</item>
<item>
    <title>Maybe Overuse, Stories About Error Information Loss</title>
    <link>https://rpeszek.github.io//posts/2021-01-17-maybe-overuse.html</link>
    <description><![CDATA[<article>
    <section class="header">
        Posted on January 17, 2021
        
            by Robert Peszek
        
        
          <br /> Last Modified on February 17, 2021
        
        
        <div class="changelog"> <div>Revision History: <ul> <li> (2021.01.18) Added <a href="#monadfail-and-maybe">MonadFail</a> subsection to <a href="#maybe-on-hackage">Maybe on Hackage</a> </li> <li> (2021.02.17-now) <a href="#more-links">More Links</a> (list of related links)</li> </ul> </div></div>
        
        
        <div class="info">Tags: <a title="All pages tagged 'Haskell'." href="../tags/Haskell.html">Haskell</a>, <a title="All pages tagged 'error-messages'." href="../tags/error-messages.html">error-messages</a>, <a title="All pages tagged 'maintainability'." href="../tags/maintainability.html">maintainability</a></div>
        
    </section>
    <section>

    </section>
    <section>
        <div class="toc"><div class="header">Table of Contents</div>
<ul>
<li><a href="#nutshell">Nutshell</a></li>
<li><a href="#error-clarity-rule">Error Clarity Rule</a></li>
<li><a href="#harmful-real-world-examples">Harmful Real-World Examples</a>
<ul>
<li><a href="#maybe-on-hackage"><code>Maybe</code> on Hackage</a></li>
<li><a href="#cut-catmaybes">Cut <code>catMaybes</code></a></li>
<li><a href="#hkd-pattern">HKD pattern</a></li>
<li><a href="#traversable-with-maybe"><code>Traversable</code> with <code>Maybe</code></a></li>
</ul></li>
<li><a href="#questioning-record-types-with-all-maybe-fields">Questioning Record Types with all <code>Maybe</code> Fields</a>
<ul>
<li><a href="#recreating-java-beans-with-maybe">Recreating <em>Java Beans</em> with <code>Maybe</code> ;)</a></li>
<li><a href="#maybe-first-monoid-fields"><em>Maybe-First</em> <code>Monoid</code> fields</a></li>
</ul></li>
<li><a href="#alternative-typeclass"><code>Alternative</code> typeclass</a></li>
<li><a href="#good-uses-of-maybe">Good uses of Maybe</a></li>
<li><a href="#why-maybe-is-overused-possible-explanations">Why <code>Maybe</code> is Overused? Possible Explanations</a></li>
<li><a href="#more-links">More Links</a></li>
</ul>
</div>
<h4 id="motivating-references">Motivating References:</h4>
<p>I was very happy to find Michael Snoyman’s <a href="https://www.snoyman.com/blog/2020/10/haskell-bad-parts-1/" target="_blank">Haskell The Bad Parts</a> series.<br />
I was also motivated by <a href="https://www.michaelpj.com/blog/2021/01/02/elementary-programming.html" target="_blank">Elementary Programming</a> post (<a href="https://www.reddit.com/r/haskell/comments/kst0d3/elementary_programming/" target="_blank">reddit</a>).</p>
<p><strong>Similar:</strong> <a href="https://www.reddit.com/r/haskell/comments/jxj8i/data_maybe_harmful/" target="_blank">reddit data_maybe_harmful</a></p>
<p>This post is Haskell specific.<br />
This post treats the term error colloquially, it does not distinguish between <a href="https://wiki.haskell.org/Error_vs._Exception" target="_blank"><em>exceptions</em> and <em>errors</em></a>. In particular, <em>error information loss</em> refers to exceptions not errors.</p>
<h2 id="nutshell">Nutshell</h2>
<p><code>Maybe</code> is the functional answer to <code>null</code> - the <a href="https://en.wikipedia.org/wiki/Tony_Hoare" target="_blank">billion dollar mistake</a>. I claim that using <code>Maybe</code> can still be problematic.</p>
<p>IMO <code>Maybe</code> is often overused. I have started to question the use of <code>Maybe</code> every time I see it in the code base I maintain. The result is either accepting its usage or rewriting the code to use <code>Either</code>. This approach has been effective in creating more robust code. I am not claiming that <code>Maybe</code> has no place in a well written code, only that its use should be closely examined. I have seen brilliant code that has been hard to maintain because of its overuse of <code>Maybe</code>. This post shares a perspective of someone who maintains a complex Haskell code base.</p>
<p><code>Maybe</code> improves over <code>null</code>. But it does not supersede it. Languages that have <code>null</code> also have easy access to logging, stack traces etc.</p>
<p><code>Maybe</code> typically represents data that can be <em>missing</em> or a computation that can result in an <em>unknown error</em>.<br />
What you typically care about is <em>what data is missing</em> and <em>what is the error</em>.</p>
<p><em>Code correctness</em>, <em>reasoning about code</em> are, arguably, the defining aspects of FP. <em>Reasoning about code</em> typically refers to some advanced use of the type system or formal methods. IMO “reasoning about code” should start with reasoning about errors and corner cases (like missing data). This is why the use of <code>Maybe</code> needs to be examined and questioned. In my experience this aspect of reasoning about code is often overlooked.</p>
<p>Reasoning about errors is not easy: The type system can’t help with errors that bypass it (e.g. <code>error :: String -&gt; a</code>). It can’t help with exceptions which were intentionally suppressed into <code>Nothing</code> <em>(the focus of this post)</em>. And, the list goes on…</p>
<p>My points / pleas are:</p>
<ul>
<li>The ecosystem would be better off without offering convenience combinators that return <code>Maybe</code> if an equivalent returning <code>Either</code> exists</li>
<li>Examples, tutorials, and blog posts should favor <code>Either</code> over <code>Maybe</code></li>
<li>Developers should be careful about not overusing <code>Maybe</code></li>
</ul>
<h2 id="error-clarity-rule">Error Clarity Rule</h2>
<p><em>What does <code>Nothing</code> mean? If the reason behind it can be disambiguated to one root cause, then I consider the use of <code>Maybe</code> justified. Otherwise, I question its use.</em></p>
<p>Consider this code:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Data.Map</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Key</span> <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Value</span> <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a><span class="co">-- OK</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a><span class="ot">phone ::</span> <span class="dt">Map</span> <span class="dt">Key</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Value</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>phone <span class="ot">=</span> <span class="fu">lookup</span> <span class="st">&quot;phone&quot;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a><span class="co">-- OK</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a><span class="ot">email ::</span> <span class="dt">Map</span> <span class="dt">Key</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Value</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a>email <span class="ot">=</span> <span class="fu">lookup</span> <span class="st">&quot;email&quot;</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true"></a><span class="co">-- OK</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true"></a><span class="ot">creditCardNum ::</span> <span class="dt">Map</span> <span class="dt">Key</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Value</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true"></a>creditCardNum <span class="ot">=</span> <span class="fu">lookup</span> <span class="st">&quot;card-number&quot;</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">FormData</span> <span class="ot">=</span> <span class="dt">FormData</span> {</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true"></a><span class="ot">   fdPhone ::</span> <span class="dt">Value</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true"></a>   ,<span class="ot"> fdEmail ::</span> <span class="dt">Value</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true"></a>   ,<span class="ot"> fdCardNum ::</span> <span class="dt">Value</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true"></a>   }</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true"></a><span class="co">-- less OK</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true"></a><span class="ot">formData ::</span> <span class="dt">Map</span> <span class="dt">Key</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">FormData</span>  </span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true"></a>formData <span class="fu">map</span> <span class="ot">=</span> <span class="dt">FormData</span> <span class="op">&lt;$&gt;</span> phone <span class="fu">map</span> <span class="op">&lt;*&gt;</span> email <span class="fu">map</span> <span class="op">&lt;*&gt;</span> creditCardNum <span class="fu">map</span> </span></code></pre></div>
<p>you can clearly explain the first 3 functions:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="ot">explain ::</span> err <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Either</span> err a</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>explain <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Err</span> <span class="ot">=</span> <span class="dt">MissingEmail</span> <span class="op">|</span> <span class="dt">MissingPhone</span> <span class="op">|</span> <span class="dt">MissingCardNum</span> </span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a><span class="ot">email' ::</span> <span class="dt">Map</span> <span class="dt">Key</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">Err</span> <span class="dt">Value</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>email' <span class="ot">=</span> explain <span class="dt">MissingEmail</span> <span class="op">.</span> email</span></code></pre></div>
<p>How do I explain <code>formData</code>? I am stuck with:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">UnknownFieldMissing</span> <span class="ot">=</span> <span class="dt">UnknownFieldMissing</span> </span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a><span class="ot">formData' ::</span> <span class="dt">Map</span> <span class="dt">Key</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">Err</span> <span class="dt">Value</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>formData' <span class="ot">=</span> explain <span class="dt">UnknownFieldMissing</span> <span class="op">.</span> formData</span></code></pre></div>
<p>and that “Unknown” is not a field name.<br />
The bigger the record, the bigger the problem.</p>
<h2 id="harmful-real-world-examples">Harmful Real-World Examples</h2>
<p>These are in no particular order, other than this presentation reuses types defined earlier.</p>
<h3 id="maybe-on-hackage"><code>Maybe</code> on Hackage</h3>
<h4 id="servant-multipart-example"><em>servant-multipart</em> example:</h4>
<p>If you used older versions of <a href="https://hackage.haskell.org/package/servant-multipart" target="_blank">servant-multipart</a> you are familiar with</p>
<p><em>status code 400, message “fromMultipart returned Nothing”</em>.</p>
<p>You must have noticed that your logs have been silent as well.<br />
The fix was implemented in 0.11.6</p>
<p>New version (much better):</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="co">-- version 0.11.6</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">FromMultipart</span> tag a <span class="kw">where</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a><span class="ot">   fromMultipart ::</span> <span class="dt">MultipartData</span> tag <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> a</span></code></pre></div>
<p>Old version:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="co">-- version 0.11.5</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">FromMultipart</span> tag a <span class="kw">where</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a><span class="ot">  fromMultipart ::</span> <span class="dt">MultipartData</span> tag <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span></code></pre></div>
<p>Any typo, missed form field, wrong form field type submitted from the calling program resulted in a meaningless 400 error.<br />
To work around this issue I ended up implementing <code>fromMultipart</code> in <code>Either MultiformError</code> monad and converting it to <code>Maybe</code> with something like that:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="ot">loggedMultipartMaybe ::</span>  <span class="dt">Either</span> <span class="dt">MultipartException</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>loggedMultipartMaybe (<span class="dt">Left</span> err) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>    <span class="kw">let</span> logDetails <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>    <span class="fu">seq</span> </span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>      (debugLogger logDetails) <span class="co">-- uses unsafePeformIO to match your logging style</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>      <span class="dt">Nothing</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>loggedMultipartMaybe (<span class="dt">Right</span> r) <span class="ot">=</span> <span class="dt">Just</span> r </span></code></pre></div>
<p>to, at least, get some logs.</p>
<p>In just one project, that saved me hours in both new development and troubleshooting cost.<br />
For a more complex multipart form that implements both <code>FromMultipart</code> and <code>ToMultipart</code> by hand, verifying that <code>fromMultipart . toMultipart</code> is the identity would have been very hard without some information about errors. If the multipart is called from a different program, different language …</p>
<h4 id="convenience-combinators">Convenience Combinators:</h4>
<p>It should be noted that many popular packages offer convenience <code>Maybe</code> functions even though it is very easy to write this natural transformation:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="ot">unExplain ::</span> <span class="dt">Either</span> err a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span></code></pre></div>
<p>Why is that? Why not just provide <code>Either</code> versions? Looking at <em>aeson</em> as an example:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="ot">decode ::</span> <span class="dt">FromJSON</span> a <span class="ot">=&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="ot">eitherDecode ::</span> <span class="dt">FromJSON</span> a <span class="ot">=&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> a </span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a><span class="ot">parseEither ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Parser</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> b </span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a><span class="ot">parseMaybe ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Parser</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b </span></code></pre></div>
<p>the name <code>decode</code> is suggestive of being the one commonly used.</p>
<p>Having <code>aeason</code> in the spotlight, I like this part of their <a href="https://hackage.haskell.org/package/aeson-1.5.5.1/docs/Data-Aeson-Types.html##v:parse" target="_blank">documentation</a>:</p>
<blockquote>
<p><em>The basic ways to signal a failed conversion are as follows:</em></p>
<ul>
<li><em>fail yields a custom error message: it is the recommended way of reporting a failure;</em></li>
<li><em>empty (or mzero) is uninformative: use it when the error is meant to be caught by some (&lt;|&gt;);</em></li>
</ul>
</blockquote>
<p>Overuse of <code>mzero</code> in parsing code is as bad as the overuse of <code>Maybe</code>.</p>
<h4 id="monadfail-and-maybe"><code>MonadFail</code> and <code>Maybe</code>:</h4>
<p>Number of packages try to be polymorphic and use <code>MonadFail</code> constraint to provide information about unexpected errors (e.g. <em>time</em>, <em>mongoDB</em>). Sadly <em>base</em> provides no standard way to retrieve this information. The <a href="https://gitlab.haskell.org/ghc/ghc/-/issues/12160" target="_blank">ticket</a> to add <code>Either String</code> instance is a no-go for now.</p>
<p>The packages which use <code>MonadFail</code> do not offer convenience <code>MonadFail</code> monads either. It seems wrong and asymmetric to force the caller to define their type for retrieving error information.</p>
<p>But <code>MonadFail</code> has <code>Maybe</code> instance! I strongly believe in <em>make writing good code easy, bad code hard</em> design principle. This is clearly violated here.</p>
<p>Also, notice this part of documentation (in <em>base</em> Control.Monad.Fail):</p>
<blockquote>
<p>If your Monad is also MonadPlus, a popular definition is</p>
<p><code>fail _ = mzero</code></p>
</blockquote>
<p><em>(quiet sob)</em></p>
<h3 id="cut-catmaybes">Cut <code>catMaybes</code></h3>
<p>Replacing</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="ot">catMaybes ::</span> [<span class="dt">Maybe</span> a] <span class="ot">-&gt;</span> [a]</span></code></pre></div>
<p>with</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="ot">partitionEithers ::</span> [<span class="dt">Either</span> e a] <span class="ot">-&gt;</span> ([e], [a])</span></code></pre></div>
<p>very often improves the robustness of code.</p>
<p>Consider <code>Contact</code> record type with <code>cEmail :: Maybe Email</code> field. We can get</p>
<ul>
<li>lists of emails by using <code>catMaybes</code></li>
<li>list of emails and the information which <code>Contact</code>-s do not have an email using <code>partitionEithers</code>.</li>
</ul>
<p>The <code>Contact</code> list could come from a parsed JSON and could contain a list of company employees or is a parsed mail-mime <em>CC:</em> header. Missing email should be rare.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Control.Arrow</span> ((&amp;&amp;&amp;))</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a><span class="co">-- maybe version</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a><span class="ot">getEmails ::</span> [<span class="dt">Contact</span>] <span class="ot">-&gt;</span> [<span class="dt">Email</span>]</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>getEmails <span class="ot">=</span> catMaybes <span class="op">.</span> <span class="fu">map</span> cEmail</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a><span class="co">-- either version</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">MissingData</span> a <span class="ot">=</span> <span class="dt">MissingEmailData</span> a <span class="op">|</span> <span class="op">...</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true"></a><span class="ot">getEmails' ::</span> [<span class="dt">Contact</span>] <span class="ot">-&gt;</span> ([<span class="dt">MissingData</span> <span class="dt">Contact</span>], [<span class="dt">Email</span>])</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true"></a>getEmails' <span class="ot">=</span> partitionEithers <span class="op">.</span> <span class="fu">map</span> (<span class="fu">uncurry</span> explain <span class="op">.</span> (<span class="dt">MissingEmailData</span> <span class="op">&amp;&amp;&amp;</span> cEmail))</span></code></pre></div>
<p>These are “it is rare, therefore can be ignored” vs “it is rare and therefore cannot be ignored” approaches.<br />
I do not know what is the proper name for software that does not handle corner cases. I call it <em>expensive</em> ;)<br />
I question the use of <code>catMaybes</code> every time I see it.</p>
<p>I try to be terse in the above example, but it is clear that <code>Either</code> is more work. Terseness and ease of programming are IMO some of the reasons for <code>Maybe</code> overuse.</p>
<h3 id="hkd-pattern">HKD pattern</h3>
<p>Higher-Kinded Data pattern is super cool and can be very useful. This post explains what it is: <a href="https://reasonablypolymorphic.com/blog/higher-kinded-data/" target="_blank">reasonablypolymorphic on HKD pattern</a>. My example follows <em>reasonablypolymorphic</em> blog closely.</p>
<p>In nutshell, we can create a record type like</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Person</span> f <span class="ot">=</span> <span class="dt">Person</span> { </span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a><span class="ot">    pName ::</span> f <span class="dt">String</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>  ,<span class="ot"> pAge  ::</span> f <span class="dt">Int</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>  <span class="co">-- imagine a lot more fields here</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a>  } </span></code></pre></div>
<p>parametrized by a type of kind <code>* -&gt; *</code> e.g. <code>Maybe</code> or <code>Identity</code>. All or some of the fields in that record type have an <code>f</code> in front of them.<br />
<em>HKD Patter</em> is about using generic programming to transform that record based on operations that work on the fields.<br />
For example, we can hoist <code>forall a . f a -&gt; g a</code> functions to <code>hkd f -&gt; hkd g</code> (here <code>Person f -&gt; Person g</code>).</p>
<p>Imagine that <code>Person</code> has a long list of fields and there is a web form for entering them.<br />
The post descibes a completely generic validation function that, when restricted to our <code>Person</code> type, looks like this:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="ot">validate ::</span> <span class="dt">Person</span> <span class="dt">Maybe</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Person</span> <span class="dt">Identity</span>)</span></code></pre></div>
<p>I hate when this is done to me: it took 5 minutes to enter the information, the submit button is grayed out, and I see no way to move forward. Typically, when that happens, it is caused by a JavaScript error.</p>
<p>In this example it is not a programming bug, it is a design decision: a very sophisticated way to check that user entered all fields that does not provide information about which fields they missed.<br />
Web form data entry aside, I challenge you to find one meaningful example where the above <code>validate</code> is useful. A one off data science code that processes massive amount of data and requires all fields to be present to be useful? All examples I can come up with seem far-fetched and still would benefit from having <code>Either</code>.</p>
<p>Questions I am asking:</p>
<ul>
<li>Would you expect a production code somewhere out there that validates user input using HKD pattern and actually uses <code>Maybe</code>?</li>
<li>Did <em>reasonablypolymorphic</em> confuse or simplify things by using <code>Maybe</code> in its example?</li>
</ul>
<p>In <em>reasonablypolymorphic</em> post <code>Maybe</code> is not just in the <code>validate</code> function. The post defines the whole <code>GValidate</code> boilerplate that assumes <code>Maybe</code>.</p>
<p>Fortunately, the approach can be generalized to other <code>f</code> types.<br />
A meaningful validation would have a type</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">FieldInfo</span> <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a><span class="ot">validate ::</span> <span class="dt">Person</span> <span class="dt">Maybe</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> [<span class="dt">FieldInfo</span>] (<span class="dt">Person</span> <span class="dt">Identity</span>)</span></code></pre></div>
<p>This is arguably more work to do and beyond what <em>HKD pattern</em> can offer. However, it is quite possible to do something like this generically:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">FieldInfo</span> <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a><span class="ot">validate ::</span> <span class="dt">Person</span> (<span class="dt">Either</span> <span class="dt">FieldInfo</span>) <span class="ot">-&gt;</span> <span class="dt">Either</span> [<span class="dt">FieldInfo</span>] (<span class="dt">Person</span> <span class="dt">Identity</span>)</span></code></pre></div>
<p>Check out the documentation for the <a href="https://hackage.haskell.org/package/barbies" target="_blank">barbies</a> package, it comes with exactly this example! Notice, some boilerplate work is still needed to annotate missing values with field information:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="ot">addFieldInfo ::</span>  <span class="dt">Person</span> <span class="dt">Maybe</span> <span class="ot">-&gt;</span> <span class="dt">Person</span> (<span class="dt">Either</span> <span class="dt">FieldInfo</span>) </span></code></pre></div>
<p><code>addFieldInfo</code> would need to happen outside of the <em>HKD pattern</em>.<br />
One can argue that a better solution would be not to use <code>Person Maybe</code> and convert user form data entry directly to <code>Person (Either FieldInfo)</code>.</p>
<h3 id="traversable-with-maybe"><code>Traversable</code> with <code>Maybe</code></h3>
<p><em>barbies</em> validation of <code>Person</code> required a traversal of the <em>HKD</em> type. So, maybe, we should consider a somewhat simpler design where fields are unified into one type. Keeping up with the <em>reasonablypolymorphic</em> example:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="ot">{-# LANGUAGE DeriveFunctor #-}</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a><span class="ot">{-# LANGUAGE DeriveFoldable #-}</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a><span class="ot">{-# LANGUAGE DeriveTraversable #-}</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Person'</span> a <span class="ot">=</span> <span class="dt">Person'</span> { </span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a><span class="ot">    pName' ::</span> a</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true"></a>  ,<span class="ot"> pAge'  ::</span> a</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true"></a>  <span class="co">-- imagine a lot more fields here</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true"></a>  } <span class="kw">deriving</span> (<span class="op">...</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Traversable</span>)</span></code></pre></div>
<p>And “now we are cooking with gas”!</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">FieldData</span> <span class="ot">=</span> <span class="op">...</span> <span class="co">-- unifying type for Person' fields</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a><span class="ot">validateMaybe ::</span> <span class="dt">Person'</span> (<span class="dt">Maybe</span> <span class="dt">FieldData</span>) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Person'</span> <span class="dt">FieldData</span>)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a>validateMaybe <span class="ot">=</span> <span class="fu">traverse</span> <span class="fu">id</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a><span class="ot">validateEither ::</span> <span class="dt">Person'</span> (<span class="dt">Either</span> <span class="dt">FieldInfo</span> <span class="dt">FieldData</span>) <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">FieldInfo</span> (<span class="dt">Person'</span> <span class="dt">FieldData</span>)</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true"></a>validateEither <span class="ot">=</span> <span class="fu">traverse</span> <span class="fu">id</span></span></code></pre></div>
<p>New <code>validateEither</code> is not as good as the <em>barbies</em> version. It gives the user only one of the fields they missed.<br />
IMO <code>validateMaybe</code> is useless for any data entry form validation.</p>
<p>The <code>validateMaybe</code> example is here for a reason. It directly mimics the example discussed in <a href="https://www.michaelpj.com/blog/2021/01/02/elementary-programming.html" target="_blank">Elementary Programming</a>, which used</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="ot">mapMaybe ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [b]</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a>mapMaybe <span class="ot">=</span> <span class="fu">traverse</span></span></code></pre></div>
<p>as its only example.</p>
<p><code>Maybe</code> is viral.</p>
<h2 id="questioning-record-types-with-all-maybe-fields">Questioning Record Types with all <code>Maybe</code> Fields</h2>
<p>Besides being a natural fit for data coming from something like a web form, there are other reasons for designing record types with many <code>Maybe</code> fields.<br />
Here is my attempt at debunking some of them.</p>
<h3 id="recreating-java-beans-with-maybe">Recreating <em>Java Beans</em> with <code>Maybe</code> ;)</h3>
<p>Defining record types with many <code>Maybe</code> fields allows to construct such records easily if you care about only some of the fields.</p>
<p>This can be done via some <code>empty</code> defaulting mechanism (I will use the <code>Person</code> type defined above to serve as an example):</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="ot">emptyPerson ::</span> <span class="dt">Person</span> <span class="dt">Maybe</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a>emptyPerson <span class="ot">=</span> <span class="dt">Person</span> <span class="dt">Nothing</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>or with a use of <code>Monoid</code> and <code>mempty</code>. <code>emptyPerson</code> could be defined in a generic way as well (see <a href="https://hackage.haskell.org/package/hkd-default" target="_blank">hkd-default</a>).</p>
<p>Say, your code cares about <code>pAge</code> only, you can just set <code>pAge</code>:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="ot">isDrinkingAge ::</span> <span class="dt">Person</span> <span class="dt">Identity</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a>isDrinkingAge p <span class="ot">=</span> runIdentity (pAge p) <span class="op">&gt;=</span> <span class="dv">21</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a>test10YearOld <span class="ot">=</span> emptyPerson {pAge <span class="ot">=</span> <span class="dt">Identity</span> <span class="dv">10</span>}</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a>test <span class="ot">=</span> isDrinkinAge test10YearOld</span></code></pre></div>
<p>I do not like this approach. It feels like a poorly typed code.</p>
<p>It also reminds me of <code>null</code> and hence the <em>Java Bean</em> reference. (<a href="https://stackoverflow.com/questions/1612334/difference-between-dto-vo-pojo-javabeans" target="_blank">Java Bean</a> was a popular pattern in the Java ecosystem. A <em>Bean</em> needs to have an empty constructor, and a <em>setter</em> / <em>getter</em> method for each field. It seems very similar to a record type with lots of <code>Maybe</code> fields.)</p>
<p>An easy improvement would be to create <code>Age</code> type</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">Age</span> <span class="ot">=</span> <span class="dt">Age</span> <span class="dt">Int</span> </span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Person''</span> f <span class="ot">=</span> <span class="dt">Person''</span> { </span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a>  <span class="op">...</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a>  ,<span class="ot"> pAge''  ::</span> f <span class="dt">Age</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true"></a>  <span class="co">-- imagine a lot more fields here</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true"></a>  } </span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true"></a></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true"></a><span class="ot">isDrinkingAge' ::</span> <span class="dt">Age</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true"></a>isDrinkingAge' (<span class="dt">Age</span> a) <span class="ot">=</span> a <span class="op">&gt;=</span> <span class="dv">21</span></span></code></pre></div>
<p>If we feel strongly about checking age on the <code>Person</code> type, we can use Haskell’s ability to program with polymorphic fields:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="ot">{-# LANGUAGE TypeApplications #-}</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a><span class="ot">{-# LANGUAGE FlexibleContexts #-}</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a><span class="ot">{-# LANGUAGE DuplicateRecordFields #-}</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">GHC.Records</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true"></a><span class="ot">isDrinkingAge ::</span> <span class="dt">HasField</span> <span class="st">&quot;pAge&quot;</span> p (<span class="dt">Identity</span> <span class="dt">Int</span>) <span class="ot">=&gt;</span> p <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true"></a>isDrinkingAge p <span class="ot">=</span> runIdentity (getField <span class="op">@</span> <span class="st">&quot;pAge&quot;</span> p) <span class="op">&gt;=</span> <span class="dv">21</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true"></a></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">AgeTest</span> <span class="ot">=</span> <span class="dt">AgeTest</span> {<span class="ot"> pAge ::</span> <span class="dt">Identity</span> <span class="dt">Int</span>}</span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true"></a></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true"></a>test40YearOld <span class="ot">=</span> isDrinkingAge <span class="op">$</span> <span class="dt">AgeTest</span> (<span class="dt">Identity</span> <span class="dv">40</span>)</span></code></pre></div>
<p>IMO creating record types with lots of <code>Maybe</code> fields for the benefit of easy construction is not a good pattern.</p>
<h3 id="maybe-first-monoid-fields"><em>Maybe-First</em> <code>Monoid</code> fields</h3>
<p><code>Maybe (First _)</code> is a valid <code>Monoid</code>.<br />
Using Maybe-First semantics, <code>mappend</code> selects the first non-<code>Nothing</code> element. Appending can be implemented as:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Data.Semigroup</span> (<span class="dt">First</span> (..))</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a>a <span class="op">&lt;&gt;</span> b <span class="ot">=</span> <span class="fu">fmap</span> getFirst <span class="op">$</span> <span class="fu">fmap</span> <span class="dt">First</span> a <span class="op">&lt;&gt;</span> <span class="fu">fmap</span> <span class="dt">First</span> b</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a><span class="co">-- or in more &quot;elemenary&quot; way as:</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true"></a></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true"></a><span class="dt">Nothing</span> <span class="op">&lt;&gt;</span> b <span class="ot">=</span> b</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true"></a>a <span class="op">&lt;&gt;</span> <span class="dt">Nothing</span> <span class="ot">=</span> a</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true"></a>a <span class="op">&lt;&gt;</span> b <span class="ot">=</span> a</span></code></pre></div>
<p>You can use this approach on each field to define <code>Monoid</code> instances for large record types that consist of <code>Maybe</code> fields.<br />
This pattern provides a convenient defaulting mechanism and allows to set groups of fields at once using <code>mappend</code>.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a>overrides <span class="op">&lt;&gt;</span> record</span></code></pre></div>
<p>This approach can also result in very weird data combinations if one is not careful:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a>gd <span class="ot">=</span> (<span class="fu">mempty</span><span class="ot"> ::</span> <span class="dt">Person</span> <span class="dt">Maybe</span>) {pName <span class="ot">=</span> <span class="st">&quot;grandpa&quot;</span>} <span class="co">-- missing age</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a>baby <span class="ot">=</span> (<span class="fu">mempty</span><span class="ot"> ::</span> <span class="dt">Person</span> <span class="dt">Maybe</span>) {pName <span class="ot">=</span> <span class="dt">Just</span> <span class="st">&quot;baby&quot;</span>, pAge <span class="ot">=</span> <span class="dt">Just</span> <span class="dv">1</span>} </span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true"></a>grampatoddler <span class="ot">=</span> gd <span class="op">&lt;&gt;</span> baby <span class="co">-- it is easy to create surprising data</span></span></code></pre></div>
<p>The reverse: <code>First (Maybe _)</code> <code>Monoid</code> instance is far less convenient to use but is much less surprising.</p>
<p>I do not think that <code>Maybe-First</code> <code>Monoid</code> is necessarily bad. There is simply a trade-off between the conveniences it offers and its gotchas. I prefer designs that provide more safety over accidental bugs.</p>
<h2 id="alternative-typeclass"><code>Alternative</code> typeclass</h2>
<p><code>Alternaive</code> <code>(&lt;|&gt;)</code> is very convenient tool often used with parsers. It can be dangerous on its own merit. It can suppress error information in questionable ways if overused (I wrote a separate <a href="https://rpeszek.github.io/posts/2021-02-13-alternative.html" target="_blank">post</a> about it).</p>
<p>There is currently no <code>Alternative</code> instance for <code>Either err</code> but there is one for <code>Maybe</code>. This creates temptation to <code>unExplain</code> the <code>err</code> …</p>
<h2 id="good-uses-of-maybe">Good uses of Maybe</h2>
<p>I think the following old design principle (Postel’s law) is still valid (on the implementation side)</p>
<p><em>Lenient input, Strict Output</em>.</p>
<p>This means <code>Maybe</code> is great as input parameter, less so in the result. The above <em>Error Clarity Rule</em> should be the overriding factor here. If the call-site can disambiguate what <code>Nothing</code> is, then <code>Maybe</code> results are fine.</p>
<p>In particular, <em>prisms</em> are typically used on not nested coproducts, thus, the call-site can disambiguate at which level the pattern match failed. <code>lookup</code> in <code>Data.Map</code>, <code>find</code> for a <code>Foldabe</code> are all perfectly good choices for a <code>Maybe</code> result type.</p>
<h2 id="why-maybe-is-overused-possible-explanations">Why <code>Maybe</code> is Overused? Possible Explanations</h2>
<p>IMO these are the main causes of the overuse:</p>
<ol type="1">
<li><p>Using <code>Maybe</code> is simpler that <code>Either</code>. If doing the right thing takes more time and effort it will often not be done.</p></li>
<li><p>Coding with <code>Maybe</code> is terser. Thus, coding with <code>Maybe</code> may seem more elegant.</p></li>
<li><p><code>Maybe</code> is more expressive. Examples: <code>Alternative</code> instance; to use <code>Monad</code>, <code>Applicative</code> with <code>Either err</code> you need to unify on the <code>err</code> type which is extra work.</p></li>
<li><p>Sophisticated abstractions can obscure common sense. <code>Maybe</code> is likely to fit the abstraction more often and easier than <code>Either</code>.</p></li>
</ol>
<p>Oversimplifications are nothing new in mathematical modeling. Anyone who studied, for example, mathematical physics has seen a lot of crazy oversimplifications. Code design appears not that different.</p>
<ol start="5" type="1">
<li>Non production code. Lots of Haskell code is about CS research. Lots of Haskell code is pet projects. Such code does not need to be maintained in production. <code>Maybe</code> is good enough.</li>
</ol>
<p>If developer can disambiguate the reason for <code>Nothing</code>, then use of <code>Either</code> is optional. This is not an overuse case and is justified.</p>
<p>I started with link to <a href="https://www.michaelpj.com/blog/2021/01/02/elementary-programming.html" target="_blank">Elementary Programming</a> post and want to end with it. Would more explicit “elementary” programs help in spotting obvious things like error information loss? I think they could. Starting from requirements and going back to most elementary solution would probably never arrive at:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a><span class="ot">mapMaybe ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [b]</span></code></pre></div>
<p>if only the requirements cared about errors.<br />
I do not advocate avoiding abstractions, just do not forget errors on the way. Don’t throw the baby out with the bathwater.</p>
<p>I am sure I do not have a full understanding of why and how <code>Maybe</code> is overused. The intent of this post is to start a discussion.</p>
<p>Discussion links:</p>
<ul>
<li>github <a href="https://github.com/rpeszek/rpeszek.github.io/discussions" target="_blank">discussions</a></li>
<li><a href="https://www.reddit.com/r/haskell/comments/kyo4xk/maybe_considered_harmful/" target="_blank">reddit</a></li>
</ul>
<h2 id="more-links">More Links</h2>
<p>(Links and information added later, after the original post)</p>
<ul>
<li><p><a href="https://www.parsonsmatt.org/2018/11/03/trouble_with_typed_errors.html" target="_blank">The Trouble with Typed Errors</a> - My post is often read as “Use Either” (I would prefer just “Do not overuse Maybe”). Matt Parsons’s great article talks about problems with monolithic error types and more. Extensible error types is important topic worth its own github awesome page.</p></li>
<li><p><a href="https://haskellweekly.news/episode/35.html" target="_blank">Haskell Weekly Podcast</a> has discussed this post. Thank you so much!</p></li>
</ul>

    </section>
</article>
]]></description>
    <pubDate>Sun, 17 Jan 2021 00:00:00 UT</pubDate>
    <guid>https://rpeszek.github.io//posts/2021-01-17-maybe-overuse.html</guid>
    <dc:creator>Robert Peszek</dc:creator>
</item>
<item>
    <title>Maybe Considered Harmful (deleted)</title>
    <link>https://rpeszek.github.io//posts/2021-01-16-maybe-harmful.html</link>
    <description><![CDATA[<article>
    <section class="header">
        Posted on January 16, 2021
        
            by Robert Peszek
        
        
        
        
        <div class="info">Tags: </div>
        
    </section>
    <section>

    </section>
    <section>
        <p><strong>… or stories about error information loss </strong></p>
<p>Due to the negative reaction to the title (<a href="https://www.reddit.com/r/haskell/comments/kyo4xk/maybe_considered_harmful/gji0235?utm_source=share&amp;utm_medium=web2x&amp;context=3" target="_blank">reddit</a>) this has been re-posted as <a href="../posts/2021-01-17-maybe-overuse.html">Maybe Overuse, Stories About Error Information Loss</a>.</p>
    </section>
</article>
]]></description>
    <pubDate>Sat, 16 Jan 2021 00:00:00 UT</pubDate>
    <guid>https://rpeszek.github.io//posts/2021-01-16-maybe-harmful.html</guid>
    <dc:creator>Robert Peszek</dc:creator>
</item>
<item>
    <title>Why I stopped "Opinions and Programming" blog</title>
    <link>https://rpeszek.github.io//posts/2021-01-10-OldBlog.html</link>
    <description><![CDATA[<article>
    <section class="header">
        Posted on January 10, 2021
        
            by Robert Peszek
        
        
        
        
        <div class="info">Tags: <a title="All pages tagged 'announcement'." href="../tags/announcement.html">announcement</a></div>
        
    </section>
    <section>

    </section>
    <section>
        <p>I used to blog here: <a href="http://rpeszek.blogspot.com/" target="_blank">Opinions and Programming</a>.</p>
<p>My most read blogs were the series <em>I don’t like Hibernate and Grails</em>. It presented some lessons learned from using Grails in anger. Here are the direct links: the series started with <a href="http://rpeszek.blogspot.com/2014/08/i-dont-like-hibernate-and-grails-part-1.html" target="_blank">Part 1</a> and ended with <a href="http://rpeszek.blogspot.com/2014/10/i-dont-like-hibernategrails-part-11_31.html" target="_blank">Part 11</a>. This series topped the list of most read Groovy language blogs (according to <a href="http://groovyblogs.org" target="_blank">groovyblogs.org</a>) for several months back in 2014.</p>
<p><em>Opinions and Programming</em> site illustrates my programming journey and my fascination with functional programming. Includes my old posts about <a href="https://github.com/rpeszek/fpiglet" target="_blank"><em>figlet</em></a> (functional programming library I wrote for Groovy) staring from <a href="http://rpeszek.blogspot.com/2013/06/making-groovy-more-functional-fpiglet.html" target="_blank">this old post</a> to <a href="http://rpeszek.blogspot.com/2013/08/monadic-comprehensions-in-groovy-and.html" target="_blank">Monadic Comprehensions in Groovy/Fpiglet</a>. Functional programming never caught on in Groovy, <em>fpiglet</em> was one of the first attempts. I also done functional side trips like a <a href="http://rpeszek.blogspot.com/2013/10/functional-groovy-y-combinator-learning.html" target="_blank">Groovy take on Y-combinator</a>.</p>
<p>More recent blogs were more and more focused on Haskell. I have stopped contributing to this blog in 2017. There are many excellent Haskell blogs out there already.</p>
<p>Looking at stats for these blogs was a very interesting exercise. The stats for FP posts were very poor. The difference in number of views between my posts related to mainstream Groovy/Grails and my posts related to functional programming was 10X or bigger. Functional programming remains a niche part within the programming profession. Any estimates I have seen about mainstream vs functional programming jobs show FP to be less than 1% of job market. I believe spamming bots and accidental hits were the reasons why I have seen only a 10X reduction in number of viewer visits. Whatever the actual stats were, the small viewership contributed to my decision to stop blogging.</p>
<p>Playing with code is so much more fun that writing about it. But I still settled on a hybrid. I switched to literate Haskell programs and deployed these as <em>wiki</em> pages on my github projects:<br />
<a href="https://github.com/rpeszek/notes-milewski-ctfp-hs/wiki" target="_blank">Milewski’s Category Theory for Programmers notes</a><br />
<a href="https://github.com/rpeszek/IdrisTddNotes/wiki" target="_blank">Idris TTD book notes</a>.<br />
These seemed better than blog to me. The wiki introduction to my CTFP notes ended up copied on the old blog site <a href="http://rpeszek.blogspot.com/2018/02/" target="_blank">Why read CPFP?</a> but it was just a pandoc copy of the corresponding wiki page.</p>
<p>I still have occasional need to vent my technical thoughts and concerns. For this reason I decided to move my blog here, closer to my github pet projects.</p>
    </section>
</article>
]]></description>
    <pubDate>Sun, 10 Jan 2021 00:00:00 UT</pubDate>
    <guid>https://rpeszek.github.io//posts/2021-01-10-OldBlog.html</guid>
    <dc:creator>Robert Peszek</dc:creator>
</item>

    </channel>
</rss>
